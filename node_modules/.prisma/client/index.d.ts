
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model OTPCode
 * 
 */
export type OTPCode = $Result.DefaultSelection<Prisma.$OTPCodePayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model Executive
 * 
 */
export type Executive = $Result.DefaultSelection<Prisma.$ExecutivePayload>
/**
 * Model PetOwner
 * 
 */
export type PetOwner = $Result.DefaultSelection<Prisma.$PetOwnerPayload>
/**
 * Model PetSpecies
 * 
 */
export type PetSpecies = $Result.DefaultSelection<Prisma.$PetSpeciesPayload>
/**
 * Model PetBreed
 * 
 */
export type PetBreed = $Result.DefaultSelection<Prisma.$PetBreedPayload>
/**
 * Model Pet
 * 
 */
export type Pet = $Result.DefaultSelection<Prisma.$PetPayload>
/**
 * Model VaccineType
 * 
 */
export type VaccineType = $Result.DefaultSelection<Prisma.$VaccineTypePayload>
/**
 * Model VaccinationRecord
 * 
 */
export type VaccinationRecord = $Result.DefaultSelection<Prisma.$VaccinationRecordPayload>
/**
 * Model MedicalRecord
 * 
 */
export type MedicalRecord = $Result.DefaultSelection<Prisma.$MedicalRecordPayload>
/**
 * Model QRCodePool
 * 
 */
export type QRCodePool = $Result.DefaultSelection<Prisma.$QRCodePoolPayload>
/**
 * Model QRCode
 * 
 */
export type QRCode = $Result.DefaultSelection<Prisma.$QRCodePayload>
/**
 * Model QRScanEvent
 * 
 */
export type QRScanEvent = $Result.DefaultSelection<Prisma.$QRScanEventPayload>
/**
 * Model PetLocationEvent
 * 
 */
export type PetLocationEvent = $Result.DefaultSelection<Prisma.$PetLocationEventPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Refund
 * 
 */
export type Refund = $Result.DefaultSelection<Prisma.$RefundPayload>
/**
 * Model WebhookEvent
 * 
 */
export type WebhookEvent = $Result.DefaultSelection<Prisma.$WebhookEventPayload>
/**
 * Model PaymentWebhook
 * 
 */
export type PaymentWebhook = $Result.DefaultSelection<Prisma.$PaymentWebhookPayload>
/**
 * Model PaymentEvent
 * 
 */
export type PaymentEvent = $Result.DefaultSelection<Prisma.$PaymentEventPayload>
/**
 * Model LocationTrack
 * 
 */
export type LocationTrack = $Result.DefaultSelection<Prisma.$LocationTrackPayload>
/**
 * Model NotificationPreference
 * 
 */
export type NotificationPreference = $Result.DefaultSelection<Prisma.$NotificationPreferencePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model DeviceToken
 * 
 */
export type DeviceToken = $Result.DefaultSelection<Prisma.$DeviceTokenPayload>
/**
 * Model SupportTicket
 * 
 */
export type SupportTicket = $Result.DefaultSelection<Prisma.$SupportTicketPayload>
/**
 * Model SupportMessage
 * 
 */
export type SupportMessage = $Result.DefaultSelection<Prisma.$SupportMessagePayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model SystemAnalytics
 * 
 */
export type SystemAnalytics = $Result.DefaultSelection<Prisma.$SystemAnalyticsPayload>
/**
 * Model PetRegistrationApplication
 * 
 */
export type PetRegistrationApplication = $Result.DefaultSelection<Prisma.$PetRegistrationApplicationPayload>
/**
 * Model RegisteredPet
 * 
 */
export type RegisteredPet = $Result.DefaultSelection<Prisma.$RegisteredPetPayload>
/**
 * Model ApplicationDocument
 * 
 */
export type ApplicationDocument = $Result.DefaultSelection<Prisma.$ApplicationDocumentPayload>
/**
 * Model PetDocument
 * 
 */
export type PetDocument = $Result.DefaultSelection<Prisma.$PetDocumentPayload>
/**
 * Model CheckoutItem
 * 
 */
export type CheckoutItem = $Result.DefaultSelection<Prisma.$CheckoutItemPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  pet_owner: 'pet_owner',
  executive: 'executive',
  admin: 'admin'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const OTPPurpose: {
  login: 'login',
  registration: 'registration',
  phone_verification: 'phone_verification',
  email_verification: 'email_verification',
  password_reset: 'password_reset'
};

export type OTPPurpose = (typeof OTPPurpose)[keyof typeof OTPPurpose]


export const AuthProvider: {
  phone: 'phone',
  email: 'email',
  google: 'google',
  apple: 'apple'
};

export type AuthProvider = (typeof AuthProvider)[keyof typeof AuthProvider]


export const Gender: {
  male: 'male',
  female: 'female',
  unknown: 'unknown',
  Male: 'Male',
  Female: 'Female'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const PetStatus: {
  active: 'active',
  lost: 'lost',
  found: 'found',
  deceased: 'deceased',
  inactive: 'inactive'
};

export type PetStatus = (typeof PetStatus)[keyof typeof PetStatus]


export const SizeCategory: {
  toy: 'toy',
  small: 'small',
  medium: 'medium',
  large: 'large',
  giant: 'giant'
};

export type SizeCategory = (typeof SizeCategory)[keyof typeof SizeCategory]


export const QRStatus: {
  available: 'available',
  assigned: 'assigned',
  active: 'active',
  expired: 'expired',
  revoked: 'revoked'
};

export type QRStatus = (typeof QRStatus)[keyof typeof QRStatus]


export const OrderStatus: {
  created: 'created',
  paid: 'paid',
  partially_paid: 'partially_paid',
  cancelled: 'cancelled',
  refunded: 'refunded'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const PaymentStatus: {
  initiated: 'initiated',
  processing: 'processing',
  success: 'success',
  failed: 'failed',
  refunded: 'refunded'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const PaymentStatusNew: {
  created: 'created',
  authorized: 'authorized',
  captured: 'captured',
  failed: 'failed',
  refunded: 'refunded',
  disputed: 'disputed',
  canceled: 'canceled'
};

export type PaymentStatusNew = (typeof PaymentStatusNew)[keyof typeof PaymentStatusNew]


export const VerificationMethod: {
  hmac: 'hmac',
  fetch_api: 'fetch_api'
};

export type VerificationMethod = (typeof VerificationMethod)[keyof typeof VerificationMethod]


export const PaymentPurpose: {
  qr_registration: 'qr_registration',
  premium_features: 'premium_features',
  vet_consultation: 'vet_consultation',
  pet_registration: 'pet_registration',
  pet_tag: 'pet_tag'
};

export type PaymentPurpose = (typeof PaymentPurpose)[keyof typeof PaymentPurpose]


export const RefundStatus: {
  initiated: 'initiated',
  processing: 'processing',
  processed: 'processed',
  failed: 'failed'
};

export type RefundStatus = (typeof RefundStatus)[keyof typeof RefundStatus]


export const NotificationType: {
  qr_scan: 'qr_scan',
  payment_success: 'payment_success',
  system_alert: 'system_alert',
  marketing: 'marketing'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const Platform: {
  ios: 'ios',
  android: 'android',
  web: 'web'
};

export type Platform = (typeof Platform)[keyof typeof Platform]


export const TicketCategory: {
  technical: 'technical',
  billing: 'billing',
  pet_related: 'pet_related',
  general: 'general'
};

export type TicketCategory = (typeof TicketCategory)[keyof typeof TicketCategory]


export const TicketPriority: {
  low: 'low',
  medium: 'medium',
  high: 'high',
  urgent: 'urgent'
};

export type TicketPriority = (typeof TicketPriority)[keyof typeof TicketPriority]


export const TicketStatus: {
  open: 'open',
  in_progress: 'in_progress',
  waiting_user: 'waiting_user',
  resolved: 'resolved',
  closed: 'closed'
};

export type TicketStatus = (typeof TicketStatus)[keyof typeof TicketStatus]


export const SenderType: {
  user: 'user',
  support: 'support',
  system: 'system'
};

export type SenderType = (typeof SenderType)[keyof typeof SenderType]


export const LocationType: {
  login: 'login',
  scan: 'scan',
  manual: 'manual'
};

export type LocationType = (typeof LocationType)[keyof typeof LocationType]


export const DeviceType: {
  mobile: 'mobile',
  tablet: 'tablet',
  desktop: 'desktop'
};

export type DeviceType = (typeof DeviceType)[keyof typeof DeviceType]


export const ScanResult: {
  success: 'success',
  invalid: 'invalid',
  expired: 'expired'
};

export type ScanResult = (typeof ScanResult)[keyof typeof ScanResult]


export const PoolStatus: {
  active: 'active',
  depleted: 'depleted',
  archived: 'archived'
};

export type PoolStatus = (typeof PoolStatus)[keyof typeof PoolStatus]


export const ApplicationType: {
  new: 'new',
  renewal: 'renewal'
};

export type ApplicationType = (typeof ApplicationType)[keyof typeof ApplicationType]


export const IdentifierType: {
  token_or_license: 'token_or_license',
  microchip: 'microchip',
  registration_number: 'registration_number'
};

export type IdentifierType = (typeof IdentifierType)[keyof typeof IdentifierType]


export const ApplicantType: {
  Owner: 'Owner',
  Guardian: 'Guardian',
  Caretaker: 'Caretaker'
};

export type ApplicantType = (typeof ApplicantType)[keyof typeof ApplicantType]


export const DocumentType: {
  pet_photo: 'pet_photo',
  rabies_certificate: 'rabies_certificate',
  aadhaar_card: 'aadhaar_card',
  signature: 'signature',
  other: 'other'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const OperationType: {
  INSERT: 'INSERT',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE'
};

export type OperationType = (typeof OperationType)[keyof typeof OperationType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type OTPPurpose = $Enums.OTPPurpose

export const OTPPurpose: typeof $Enums.OTPPurpose

export type AuthProvider = $Enums.AuthProvider

export const AuthProvider: typeof $Enums.AuthProvider

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type PetStatus = $Enums.PetStatus

export const PetStatus: typeof $Enums.PetStatus

export type SizeCategory = $Enums.SizeCategory

export const SizeCategory: typeof $Enums.SizeCategory

export type QRStatus = $Enums.QRStatus

export const QRStatus: typeof $Enums.QRStatus

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type PaymentStatusNew = $Enums.PaymentStatusNew

export const PaymentStatusNew: typeof $Enums.PaymentStatusNew

export type VerificationMethod = $Enums.VerificationMethod

export const VerificationMethod: typeof $Enums.VerificationMethod

export type PaymentPurpose = $Enums.PaymentPurpose

export const PaymentPurpose: typeof $Enums.PaymentPurpose

export type RefundStatus = $Enums.RefundStatus

export const RefundStatus: typeof $Enums.RefundStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type Platform = $Enums.Platform

export const Platform: typeof $Enums.Platform

export type TicketCategory = $Enums.TicketCategory

export const TicketCategory: typeof $Enums.TicketCategory

export type TicketPriority = $Enums.TicketPriority

export const TicketPriority: typeof $Enums.TicketPriority

export type TicketStatus = $Enums.TicketStatus

export const TicketStatus: typeof $Enums.TicketStatus

export type SenderType = $Enums.SenderType

export const SenderType: typeof $Enums.SenderType

export type LocationType = $Enums.LocationType

export const LocationType: typeof $Enums.LocationType

export type DeviceType = $Enums.DeviceType

export const DeviceType: typeof $Enums.DeviceType

export type ScanResult = $Enums.ScanResult

export const ScanResult: typeof $Enums.ScanResult

export type PoolStatus = $Enums.PoolStatus

export const PoolStatus: typeof $Enums.PoolStatus

export type ApplicationType = $Enums.ApplicationType

export const ApplicationType: typeof $Enums.ApplicationType

export type IdentifierType = $Enums.IdentifierType

export const IdentifierType: typeof $Enums.IdentifierType

export type ApplicantType = $Enums.ApplicantType

export const ApplicantType: typeof $Enums.ApplicantType

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type OperationType = $Enums.OperationType

export const OperationType: typeof $Enums.OperationType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.oTPCode`: Exposes CRUD operations for the **OTPCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OTPCodes
    * const oTPCodes = await prisma.oTPCode.findMany()
    * ```
    */
  get oTPCode(): Prisma.OTPCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.executive`: Exposes CRUD operations for the **Executive** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Executives
    * const executives = await prisma.executive.findMany()
    * ```
    */
  get executive(): Prisma.ExecutiveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.petOwner`: Exposes CRUD operations for the **PetOwner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PetOwners
    * const petOwners = await prisma.petOwner.findMany()
    * ```
    */
  get petOwner(): Prisma.PetOwnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.petSpecies`: Exposes CRUD operations for the **PetSpecies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PetSpecies
    * const petSpecies = await prisma.petSpecies.findMany()
    * ```
    */
  get petSpecies(): Prisma.PetSpeciesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.petBreed`: Exposes CRUD operations for the **PetBreed** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PetBreeds
    * const petBreeds = await prisma.petBreed.findMany()
    * ```
    */
  get petBreed(): Prisma.PetBreedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pet`: Exposes CRUD operations for the **Pet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pets
    * const pets = await prisma.pet.findMany()
    * ```
    */
  get pet(): Prisma.PetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vaccineType`: Exposes CRUD operations for the **VaccineType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VaccineTypes
    * const vaccineTypes = await prisma.vaccineType.findMany()
    * ```
    */
  get vaccineType(): Prisma.VaccineTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vaccinationRecord`: Exposes CRUD operations for the **VaccinationRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VaccinationRecords
    * const vaccinationRecords = await prisma.vaccinationRecord.findMany()
    * ```
    */
  get vaccinationRecord(): Prisma.VaccinationRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicalRecord`: Exposes CRUD operations for the **MedicalRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalRecords
    * const medicalRecords = await prisma.medicalRecord.findMany()
    * ```
    */
  get medicalRecord(): Prisma.MedicalRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qRCodePool`: Exposes CRUD operations for the **QRCodePool** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QRCodePools
    * const qRCodePools = await prisma.qRCodePool.findMany()
    * ```
    */
  get qRCodePool(): Prisma.QRCodePoolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qRCode`: Exposes CRUD operations for the **QRCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QRCodes
    * const qRCodes = await prisma.qRCode.findMany()
    * ```
    */
  get qRCode(): Prisma.QRCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qRScanEvent`: Exposes CRUD operations for the **QRScanEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QRScanEvents
    * const qRScanEvents = await prisma.qRScanEvent.findMany()
    * ```
    */
  get qRScanEvent(): Prisma.QRScanEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.petLocationEvent`: Exposes CRUD operations for the **PetLocationEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PetLocationEvents
    * const petLocationEvents = await prisma.petLocationEvent.findMany()
    * ```
    */
  get petLocationEvent(): Prisma.PetLocationEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refund`: Exposes CRUD operations for the **Refund** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Refunds
    * const refunds = await prisma.refund.findMany()
    * ```
    */
  get refund(): Prisma.RefundDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webhookEvent`: Exposes CRUD operations for the **WebhookEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookEvents
    * const webhookEvents = await prisma.webhookEvent.findMany()
    * ```
    */
  get webhookEvent(): Prisma.WebhookEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentWebhook`: Exposes CRUD operations for the **PaymentWebhook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentWebhooks
    * const paymentWebhooks = await prisma.paymentWebhook.findMany()
    * ```
    */
  get paymentWebhook(): Prisma.PaymentWebhookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentEvent`: Exposes CRUD operations for the **PaymentEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentEvents
    * const paymentEvents = await prisma.paymentEvent.findMany()
    * ```
    */
  get paymentEvent(): Prisma.PaymentEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.locationTrack`: Exposes CRUD operations for the **LocationTrack** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocationTracks
    * const locationTracks = await prisma.locationTrack.findMany()
    * ```
    */
  get locationTrack(): Prisma.LocationTrackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationPreference`: Exposes CRUD operations for the **NotificationPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPreferences
    * const notificationPreferences = await prisma.notificationPreference.findMany()
    * ```
    */
  get notificationPreference(): Prisma.NotificationPreferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceToken`: Exposes CRUD operations for the **DeviceToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceTokens
    * const deviceTokens = await prisma.deviceToken.findMany()
    * ```
    */
  get deviceToken(): Prisma.DeviceTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supportTicket`: Exposes CRUD operations for the **SupportTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupportTickets
    * const supportTickets = await prisma.supportTicket.findMany()
    * ```
    */
  get supportTicket(): Prisma.SupportTicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supportMessage`: Exposes CRUD operations for the **SupportMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupportMessages
    * const supportMessages = await prisma.supportMessage.findMany()
    * ```
    */
  get supportMessage(): Prisma.SupportMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemAnalytics`: Exposes CRUD operations for the **SystemAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemAnalytics
    * const systemAnalytics = await prisma.systemAnalytics.findMany()
    * ```
    */
  get systemAnalytics(): Prisma.SystemAnalyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.petRegistrationApplication`: Exposes CRUD operations for the **PetRegistrationApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PetRegistrationApplications
    * const petRegistrationApplications = await prisma.petRegistrationApplication.findMany()
    * ```
    */
  get petRegistrationApplication(): Prisma.PetRegistrationApplicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.registeredPet`: Exposes CRUD operations for the **RegisteredPet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RegisteredPets
    * const registeredPets = await prisma.registeredPet.findMany()
    * ```
    */
  get registeredPet(): Prisma.RegisteredPetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.applicationDocument`: Exposes CRUD operations for the **ApplicationDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApplicationDocuments
    * const applicationDocuments = await prisma.applicationDocument.findMany()
    * ```
    */
  get applicationDocument(): Prisma.ApplicationDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.petDocument`: Exposes CRUD operations for the **PetDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PetDocuments
    * const petDocuments = await prisma.petDocument.findMany()
    * ```
    */
  get petDocument(): Prisma.PetDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.checkoutItem`: Exposes CRUD operations for the **CheckoutItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CheckoutItems
    * const checkoutItems = await prisma.checkoutItem.findMany()
    * ```
    */
  get checkoutItem(): Prisma.CheckoutItemDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    OTPCode: 'OTPCode',
    UserSession: 'UserSession',
    Executive: 'Executive',
    PetOwner: 'PetOwner',
    PetSpecies: 'PetSpecies',
    PetBreed: 'PetBreed',
    Pet: 'Pet',
    VaccineType: 'VaccineType',
    VaccinationRecord: 'VaccinationRecord',
    MedicalRecord: 'MedicalRecord',
    QRCodePool: 'QRCodePool',
    QRCode: 'QRCode',
    QRScanEvent: 'QRScanEvent',
    PetLocationEvent: 'PetLocationEvent',
    Order: 'Order',
    Payment: 'Payment',
    Refund: 'Refund',
    WebhookEvent: 'WebhookEvent',
    PaymentWebhook: 'PaymentWebhook',
    PaymentEvent: 'PaymentEvent',
    LocationTrack: 'LocationTrack',
    NotificationPreference: 'NotificationPreference',
    Notification: 'Notification',
    DeviceToken: 'DeviceToken',
    SupportTicket: 'SupportTicket',
    SupportMessage: 'SupportMessage',
    AuditLog: 'AuditLog',
    SystemAnalytics: 'SystemAnalytics',
    PetRegistrationApplication: 'PetRegistrationApplication',
    RegisteredPet: 'RegisteredPet',
    ApplicationDocument: 'ApplicationDocument',
    PetDocument: 'PetDocument',
    CheckoutItem: 'CheckoutItem'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "oTPCode" | "userSession" | "executive" | "petOwner" | "petSpecies" | "petBreed" | "pet" | "vaccineType" | "vaccinationRecord" | "medicalRecord" | "qRCodePool" | "qRCode" | "qRScanEvent" | "petLocationEvent" | "order" | "payment" | "refund" | "webhookEvent" | "paymentWebhook" | "paymentEvent" | "locationTrack" | "notificationPreference" | "notification" | "deviceToken" | "supportTicket" | "supportMessage" | "auditLog" | "systemAnalytics" | "petRegistrationApplication" | "registeredPet" | "applicationDocument" | "petDocument" | "checkoutItem"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      OTPCode: {
        payload: Prisma.$OTPCodePayload<ExtArgs>
        fields: Prisma.OTPCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OTPCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OTPCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPCodePayload>
          }
          findFirst: {
            args: Prisma.OTPCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OTPCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPCodePayload>
          }
          findMany: {
            args: Prisma.OTPCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPCodePayload>[]
          }
          create: {
            args: Prisma.OTPCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPCodePayload>
          }
          createMany: {
            args: Prisma.OTPCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OTPCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPCodePayload>[]
          }
          delete: {
            args: Prisma.OTPCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPCodePayload>
          }
          update: {
            args: Prisma.OTPCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPCodePayload>
          }
          deleteMany: {
            args: Prisma.OTPCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OTPCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OTPCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPCodePayload>[]
          }
          upsert: {
            args: Prisma.OTPCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPCodePayload>
          }
          aggregate: {
            args: Prisma.OTPCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOTPCode>
          }
          groupBy: {
            args: Prisma.OTPCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<OTPCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.OTPCodeCountArgs<ExtArgs>
            result: $Utils.Optional<OTPCodeCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      Executive: {
        payload: Prisma.$ExecutivePayload<ExtArgs>
        fields: Prisma.ExecutiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExecutiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExecutiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutivePayload>
          }
          findFirst: {
            args: Prisma.ExecutiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExecutiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutivePayload>
          }
          findMany: {
            args: Prisma.ExecutiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutivePayload>[]
          }
          create: {
            args: Prisma.ExecutiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutivePayload>
          }
          createMany: {
            args: Prisma.ExecutiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExecutiveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutivePayload>[]
          }
          delete: {
            args: Prisma.ExecutiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutivePayload>
          }
          update: {
            args: Prisma.ExecutiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutivePayload>
          }
          deleteMany: {
            args: Prisma.ExecutiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExecutiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExecutiveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutivePayload>[]
          }
          upsert: {
            args: Prisma.ExecutiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutivePayload>
          }
          aggregate: {
            args: Prisma.ExecutiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExecutive>
          }
          groupBy: {
            args: Prisma.ExecutiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExecutiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExecutiveCountArgs<ExtArgs>
            result: $Utils.Optional<ExecutiveCountAggregateOutputType> | number
          }
        }
      }
      PetOwner: {
        payload: Prisma.$PetOwnerPayload<ExtArgs>
        fields: Prisma.PetOwnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PetOwnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetOwnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PetOwnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetOwnerPayload>
          }
          findFirst: {
            args: Prisma.PetOwnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetOwnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PetOwnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetOwnerPayload>
          }
          findMany: {
            args: Prisma.PetOwnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetOwnerPayload>[]
          }
          create: {
            args: Prisma.PetOwnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetOwnerPayload>
          }
          createMany: {
            args: Prisma.PetOwnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PetOwnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetOwnerPayload>[]
          }
          delete: {
            args: Prisma.PetOwnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetOwnerPayload>
          }
          update: {
            args: Prisma.PetOwnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetOwnerPayload>
          }
          deleteMany: {
            args: Prisma.PetOwnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PetOwnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PetOwnerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetOwnerPayload>[]
          }
          upsert: {
            args: Prisma.PetOwnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetOwnerPayload>
          }
          aggregate: {
            args: Prisma.PetOwnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePetOwner>
          }
          groupBy: {
            args: Prisma.PetOwnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PetOwnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PetOwnerCountArgs<ExtArgs>
            result: $Utils.Optional<PetOwnerCountAggregateOutputType> | number
          }
        }
      }
      PetSpecies: {
        payload: Prisma.$PetSpeciesPayload<ExtArgs>
        fields: Prisma.PetSpeciesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PetSpeciesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetSpeciesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PetSpeciesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetSpeciesPayload>
          }
          findFirst: {
            args: Prisma.PetSpeciesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetSpeciesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PetSpeciesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetSpeciesPayload>
          }
          findMany: {
            args: Prisma.PetSpeciesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetSpeciesPayload>[]
          }
          create: {
            args: Prisma.PetSpeciesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetSpeciesPayload>
          }
          createMany: {
            args: Prisma.PetSpeciesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PetSpeciesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetSpeciesPayload>[]
          }
          delete: {
            args: Prisma.PetSpeciesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetSpeciesPayload>
          }
          update: {
            args: Prisma.PetSpeciesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetSpeciesPayload>
          }
          deleteMany: {
            args: Prisma.PetSpeciesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PetSpeciesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PetSpeciesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetSpeciesPayload>[]
          }
          upsert: {
            args: Prisma.PetSpeciesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetSpeciesPayload>
          }
          aggregate: {
            args: Prisma.PetSpeciesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePetSpecies>
          }
          groupBy: {
            args: Prisma.PetSpeciesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PetSpeciesGroupByOutputType>[]
          }
          count: {
            args: Prisma.PetSpeciesCountArgs<ExtArgs>
            result: $Utils.Optional<PetSpeciesCountAggregateOutputType> | number
          }
        }
      }
      PetBreed: {
        payload: Prisma.$PetBreedPayload<ExtArgs>
        fields: Prisma.PetBreedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PetBreedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetBreedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PetBreedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetBreedPayload>
          }
          findFirst: {
            args: Prisma.PetBreedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetBreedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PetBreedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetBreedPayload>
          }
          findMany: {
            args: Prisma.PetBreedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetBreedPayload>[]
          }
          create: {
            args: Prisma.PetBreedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetBreedPayload>
          }
          createMany: {
            args: Prisma.PetBreedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PetBreedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetBreedPayload>[]
          }
          delete: {
            args: Prisma.PetBreedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetBreedPayload>
          }
          update: {
            args: Prisma.PetBreedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetBreedPayload>
          }
          deleteMany: {
            args: Prisma.PetBreedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PetBreedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PetBreedUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetBreedPayload>[]
          }
          upsert: {
            args: Prisma.PetBreedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetBreedPayload>
          }
          aggregate: {
            args: Prisma.PetBreedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePetBreed>
          }
          groupBy: {
            args: Prisma.PetBreedGroupByArgs<ExtArgs>
            result: $Utils.Optional<PetBreedGroupByOutputType>[]
          }
          count: {
            args: Prisma.PetBreedCountArgs<ExtArgs>
            result: $Utils.Optional<PetBreedCountAggregateOutputType> | number
          }
        }
      }
      Pet: {
        payload: Prisma.$PetPayload<ExtArgs>
        fields: Prisma.PetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPayload>
          }
          findFirst: {
            args: Prisma.PetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPayload>
          }
          findMany: {
            args: Prisma.PetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPayload>[]
          }
          create: {
            args: Prisma.PetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPayload>
          }
          createMany: {
            args: Prisma.PetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPayload>[]
          }
          delete: {
            args: Prisma.PetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPayload>
          }
          update: {
            args: Prisma.PetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPayload>
          }
          deleteMany: {
            args: Prisma.PetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPayload>[]
          }
          upsert: {
            args: Prisma.PetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPayload>
          }
          aggregate: {
            args: Prisma.PetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePet>
          }
          groupBy: {
            args: Prisma.PetGroupByArgs<ExtArgs>
            result: $Utils.Optional<PetGroupByOutputType>[]
          }
          count: {
            args: Prisma.PetCountArgs<ExtArgs>
            result: $Utils.Optional<PetCountAggregateOutputType> | number
          }
        }
      }
      VaccineType: {
        payload: Prisma.$VaccineTypePayload<ExtArgs>
        fields: Prisma.VaccineTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VaccineTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccineTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VaccineTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccineTypePayload>
          }
          findFirst: {
            args: Prisma.VaccineTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccineTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VaccineTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccineTypePayload>
          }
          findMany: {
            args: Prisma.VaccineTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccineTypePayload>[]
          }
          create: {
            args: Prisma.VaccineTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccineTypePayload>
          }
          createMany: {
            args: Prisma.VaccineTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VaccineTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccineTypePayload>[]
          }
          delete: {
            args: Prisma.VaccineTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccineTypePayload>
          }
          update: {
            args: Prisma.VaccineTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccineTypePayload>
          }
          deleteMany: {
            args: Prisma.VaccineTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VaccineTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VaccineTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccineTypePayload>[]
          }
          upsert: {
            args: Prisma.VaccineTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccineTypePayload>
          }
          aggregate: {
            args: Prisma.VaccineTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVaccineType>
          }
          groupBy: {
            args: Prisma.VaccineTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<VaccineTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.VaccineTypeCountArgs<ExtArgs>
            result: $Utils.Optional<VaccineTypeCountAggregateOutputType> | number
          }
        }
      }
      VaccinationRecord: {
        payload: Prisma.$VaccinationRecordPayload<ExtArgs>
        fields: Prisma.VaccinationRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VaccinationRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VaccinationRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationRecordPayload>
          }
          findFirst: {
            args: Prisma.VaccinationRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VaccinationRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationRecordPayload>
          }
          findMany: {
            args: Prisma.VaccinationRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationRecordPayload>[]
          }
          create: {
            args: Prisma.VaccinationRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationRecordPayload>
          }
          createMany: {
            args: Prisma.VaccinationRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VaccinationRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationRecordPayload>[]
          }
          delete: {
            args: Prisma.VaccinationRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationRecordPayload>
          }
          update: {
            args: Prisma.VaccinationRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationRecordPayload>
          }
          deleteMany: {
            args: Prisma.VaccinationRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VaccinationRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VaccinationRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationRecordPayload>[]
          }
          upsert: {
            args: Prisma.VaccinationRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationRecordPayload>
          }
          aggregate: {
            args: Prisma.VaccinationRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVaccinationRecord>
          }
          groupBy: {
            args: Prisma.VaccinationRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<VaccinationRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.VaccinationRecordCountArgs<ExtArgs>
            result: $Utils.Optional<VaccinationRecordCountAggregateOutputType> | number
          }
        }
      }
      MedicalRecord: {
        payload: Prisma.$MedicalRecordPayload<ExtArgs>
        fields: Prisma.MedicalRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>
          }
          findFirst: {
            args: Prisma.MedicalRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>
          }
          findMany: {
            args: Prisma.MedicalRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>[]
          }
          create: {
            args: Prisma.MedicalRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>
          }
          createMany: {
            args: Prisma.MedicalRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicalRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>[]
          }
          delete: {
            args: Prisma.MedicalRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>
          }
          update: {
            args: Prisma.MedicalRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>
          }
          deleteMany: {
            args: Prisma.MedicalRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicalRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>[]
          }
          upsert: {
            args: Prisma.MedicalRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>
          }
          aggregate: {
            args: Prisma.MedicalRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicalRecord>
          }
          groupBy: {
            args: Prisma.MedicalRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicalRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicalRecordCountArgs<ExtArgs>
            result: $Utils.Optional<MedicalRecordCountAggregateOutputType> | number
          }
        }
      }
      QRCodePool: {
        payload: Prisma.$QRCodePoolPayload<ExtArgs>
        fields: Prisma.QRCodePoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QRCodePoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QRCodePoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePoolPayload>
          }
          findFirst: {
            args: Prisma.QRCodePoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QRCodePoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePoolPayload>
          }
          findMany: {
            args: Prisma.QRCodePoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePoolPayload>[]
          }
          create: {
            args: Prisma.QRCodePoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePoolPayload>
          }
          createMany: {
            args: Prisma.QRCodePoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QRCodePoolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePoolPayload>[]
          }
          delete: {
            args: Prisma.QRCodePoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePoolPayload>
          }
          update: {
            args: Prisma.QRCodePoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePoolPayload>
          }
          deleteMany: {
            args: Prisma.QRCodePoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QRCodePoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QRCodePoolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePoolPayload>[]
          }
          upsert: {
            args: Prisma.QRCodePoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePoolPayload>
          }
          aggregate: {
            args: Prisma.QRCodePoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQRCodePool>
          }
          groupBy: {
            args: Prisma.QRCodePoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<QRCodePoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.QRCodePoolCountArgs<ExtArgs>
            result: $Utils.Optional<QRCodePoolCountAggregateOutputType> | number
          }
        }
      }
      QRCode: {
        payload: Prisma.$QRCodePayload<ExtArgs>
        fields: Prisma.QRCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QRCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QRCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePayload>
          }
          findFirst: {
            args: Prisma.QRCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QRCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePayload>
          }
          findMany: {
            args: Prisma.QRCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePayload>[]
          }
          create: {
            args: Prisma.QRCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePayload>
          }
          createMany: {
            args: Prisma.QRCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QRCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePayload>[]
          }
          delete: {
            args: Prisma.QRCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePayload>
          }
          update: {
            args: Prisma.QRCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePayload>
          }
          deleteMany: {
            args: Prisma.QRCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QRCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QRCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePayload>[]
          }
          upsert: {
            args: Prisma.QRCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePayload>
          }
          aggregate: {
            args: Prisma.QRCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQRCode>
          }
          groupBy: {
            args: Prisma.QRCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<QRCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.QRCodeCountArgs<ExtArgs>
            result: $Utils.Optional<QRCodeCountAggregateOutputType> | number
          }
        }
      }
      QRScanEvent: {
        payload: Prisma.$QRScanEventPayload<ExtArgs>
        fields: Prisma.QRScanEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QRScanEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRScanEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QRScanEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRScanEventPayload>
          }
          findFirst: {
            args: Prisma.QRScanEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRScanEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QRScanEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRScanEventPayload>
          }
          findMany: {
            args: Prisma.QRScanEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRScanEventPayload>[]
          }
          create: {
            args: Prisma.QRScanEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRScanEventPayload>
          }
          createMany: {
            args: Prisma.QRScanEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QRScanEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRScanEventPayload>[]
          }
          delete: {
            args: Prisma.QRScanEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRScanEventPayload>
          }
          update: {
            args: Prisma.QRScanEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRScanEventPayload>
          }
          deleteMany: {
            args: Prisma.QRScanEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QRScanEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QRScanEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRScanEventPayload>[]
          }
          upsert: {
            args: Prisma.QRScanEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRScanEventPayload>
          }
          aggregate: {
            args: Prisma.QRScanEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQRScanEvent>
          }
          groupBy: {
            args: Prisma.QRScanEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<QRScanEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.QRScanEventCountArgs<ExtArgs>
            result: $Utils.Optional<QRScanEventCountAggregateOutputType> | number
          }
        }
      }
      PetLocationEvent: {
        payload: Prisma.$PetLocationEventPayload<ExtArgs>
        fields: Prisma.PetLocationEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PetLocationEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetLocationEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PetLocationEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetLocationEventPayload>
          }
          findFirst: {
            args: Prisma.PetLocationEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetLocationEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PetLocationEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetLocationEventPayload>
          }
          findMany: {
            args: Prisma.PetLocationEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetLocationEventPayload>[]
          }
          create: {
            args: Prisma.PetLocationEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetLocationEventPayload>
          }
          createMany: {
            args: Prisma.PetLocationEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PetLocationEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetLocationEventPayload>[]
          }
          delete: {
            args: Prisma.PetLocationEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetLocationEventPayload>
          }
          update: {
            args: Prisma.PetLocationEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetLocationEventPayload>
          }
          deleteMany: {
            args: Prisma.PetLocationEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PetLocationEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PetLocationEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetLocationEventPayload>[]
          }
          upsert: {
            args: Prisma.PetLocationEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetLocationEventPayload>
          }
          aggregate: {
            args: Prisma.PetLocationEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePetLocationEvent>
          }
          groupBy: {
            args: Prisma.PetLocationEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<PetLocationEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.PetLocationEventCountArgs<ExtArgs>
            result: $Utils.Optional<PetLocationEventCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Refund: {
        payload: Prisma.$RefundPayload<ExtArgs>
        fields: Prisma.RefundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefundFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefundFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          findFirst: {
            args: Prisma.RefundFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefundFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          findMany: {
            args: Prisma.RefundFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>[]
          }
          create: {
            args: Prisma.RefundCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          createMany: {
            args: Prisma.RefundCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefundCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>[]
          }
          delete: {
            args: Prisma.RefundDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          update: {
            args: Prisma.RefundUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          deleteMany: {
            args: Prisma.RefundDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefundUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefundUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>[]
          }
          upsert: {
            args: Prisma.RefundUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          aggregate: {
            args: Prisma.RefundAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefund>
          }
          groupBy: {
            args: Prisma.RefundGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefundGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefundCountArgs<ExtArgs>
            result: $Utils.Optional<RefundCountAggregateOutputType> | number
          }
        }
      }
      WebhookEvent: {
        payload: Prisma.$WebhookEventPayload<ExtArgs>
        fields: Prisma.WebhookEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          findFirst: {
            args: Prisma.WebhookEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          findMany: {
            args: Prisma.WebhookEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
          }
          create: {
            args: Prisma.WebhookEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          createMany: {
            args: Prisma.WebhookEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
          }
          delete: {
            args: Prisma.WebhookEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          update: {
            args: Prisma.WebhookEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          deleteMany: {
            args: Prisma.WebhookEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebhookEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
          }
          upsert: {
            args: Prisma.WebhookEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          aggregate: {
            args: Prisma.WebhookEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookEvent>
          }
          groupBy: {
            args: Prisma.WebhookEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookEventCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookEventCountAggregateOutputType> | number
          }
        }
      }
      PaymentWebhook: {
        payload: Prisma.$PaymentWebhookPayload<ExtArgs>
        fields: Prisma.PaymentWebhookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentWebhookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentWebhookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentWebhookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentWebhookPayload>
          }
          findFirst: {
            args: Prisma.PaymentWebhookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentWebhookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentWebhookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentWebhookPayload>
          }
          findMany: {
            args: Prisma.PaymentWebhookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentWebhookPayload>[]
          }
          create: {
            args: Prisma.PaymentWebhookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentWebhookPayload>
          }
          createMany: {
            args: Prisma.PaymentWebhookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentWebhookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentWebhookPayload>[]
          }
          delete: {
            args: Prisma.PaymentWebhookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentWebhookPayload>
          }
          update: {
            args: Prisma.PaymentWebhookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentWebhookPayload>
          }
          deleteMany: {
            args: Prisma.PaymentWebhookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentWebhookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentWebhookUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentWebhookPayload>[]
          }
          upsert: {
            args: Prisma.PaymentWebhookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentWebhookPayload>
          }
          aggregate: {
            args: Prisma.PaymentWebhookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentWebhook>
          }
          groupBy: {
            args: Prisma.PaymentWebhookGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentWebhookGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentWebhookCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentWebhookCountAggregateOutputType> | number
          }
        }
      }
      PaymentEvent: {
        payload: Prisma.$PaymentEventPayload<ExtArgs>
        fields: Prisma.PaymentEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload>
          }
          findFirst: {
            args: Prisma.PaymentEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload>
          }
          findMany: {
            args: Prisma.PaymentEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload>[]
          }
          create: {
            args: Prisma.PaymentEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload>
          }
          createMany: {
            args: Prisma.PaymentEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload>[]
          }
          delete: {
            args: Prisma.PaymentEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload>
          }
          update: {
            args: Prisma.PaymentEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload>
          }
          deleteMany: {
            args: Prisma.PaymentEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload>[]
          }
          upsert: {
            args: Prisma.PaymentEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload>
          }
          aggregate: {
            args: Prisma.PaymentEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentEvent>
          }
          groupBy: {
            args: Prisma.PaymentEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentEventCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentEventCountAggregateOutputType> | number
          }
        }
      }
      LocationTrack: {
        payload: Prisma.$LocationTrackPayload<ExtArgs>
        fields: Prisma.LocationTrackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationTrackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationTrackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationTrackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationTrackPayload>
          }
          findFirst: {
            args: Prisma.LocationTrackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationTrackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationTrackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationTrackPayload>
          }
          findMany: {
            args: Prisma.LocationTrackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationTrackPayload>[]
          }
          create: {
            args: Prisma.LocationTrackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationTrackPayload>
          }
          createMany: {
            args: Prisma.LocationTrackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationTrackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationTrackPayload>[]
          }
          delete: {
            args: Prisma.LocationTrackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationTrackPayload>
          }
          update: {
            args: Prisma.LocationTrackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationTrackPayload>
          }
          deleteMany: {
            args: Prisma.LocationTrackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationTrackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationTrackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationTrackPayload>[]
          }
          upsert: {
            args: Prisma.LocationTrackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationTrackPayload>
          }
          aggregate: {
            args: Prisma.LocationTrackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocationTrack>
          }
          groupBy: {
            args: Prisma.LocationTrackGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationTrackGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationTrackCountArgs<ExtArgs>
            result: $Utils.Optional<LocationTrackCountAggregateOutputType> | number
          }
        }
      }
      NotificationPreference: {
        payload: Prisma.$NotificationPreferencePayload<ExtArgs>
        fields: Prisma.NotificationPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findFirst: {
            args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findMany: {
            args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          create: {
            args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          createMany: {
            args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          delete: {
            args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          update: {
            args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          deleteMany: {
            args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          upsert: {
            args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          aggregate: {
            args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPreference>
          }
          groupBy: {
            args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      DeviceToken: {
        payload: Prisma.$DeviceTokenPayload<ExtArgs>
        fields: Prisma.DeviceTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          findFirst: {
            args: Prisma.DeviceTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          findMany: {
            args: Prisma.DeviceTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>[]
          }
          create: {
            args: Prisma.DeviceTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          createMany: {
            args: Prisma.DeviceTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>[]
          }
          delete: {
            args: Prisma.DeviceTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          update: {
            args: Prisma.DeviceTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          deleteMany: {
            args: Prisma.DeviceTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>[]
          }
          upsert: {
            args: Prisma.DeviceTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          aggregate: {
            args: Prisma.DeviceTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceToken>
          }
          groupBy: {
            args: Prisma.DeviceTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceTokenCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceTokenCountAggregateOutputType> | number
          }
        }
      }
      SupportTicket: {
        payload: Prisma.$SupportTicketPayload<ExtArgs>
        fields: Prisma.SupportTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupportTicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupportTicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findFirst: {
            args: Prisma.SupportTicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupportTicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findMany: {
            args: Prisma.SupportTicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          create: {
            args: Prisma.SupportTicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          createMany: {
            args: Prisma.SupportTicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupportTicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          delete: {
            args: Prisma.SupportTicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          update: {
            args: Prisma.SupportTicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          deleteMany: {
            args: Prisma.SupportTicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupportTicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupportTicketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          upsert: {
            args: Prisma.SupportTicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          aggregate: {
            args: Prisma.SupportTicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupportTicket>
          }
          groupBy: {
            args: Prisma.SupportTicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupportTicketCountArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketCountAggregateOutputType> | number
          }
        }
      }
      SupportMessage: {
        payload: Prisma.$SupportMessagePayload<ExtArgs>
        fields: Prisma.SupportMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupportMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupportMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>
          }
          findFirst: {
            args: Prisma.SupportMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupportMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>
          }
          findMany: {
            args: Prisma.SupportMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>[]
          }
          create: {
            args: Prisma.SupportMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>
          }
          createMany: {
            args: Prisma.SupportMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupportMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>[]
          }
          delete: {
            args: Prisma.SupportMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>
          }
          update: {
            args: Prisma.SupportMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>
          }
          deleteMany: {
            args: Prisma.SupportMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupportMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupportMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>[]
          }
          upsert: {
            args: Prisma.SupportMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>
          }
          aggregate: {
            args: Prisma.SupportMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupportMessage>
          }
          groupBy: {
            args: Prisma.SupportMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupportMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupportMessageCountArgs<ExtArgs>
            result: $Utils.Optional<SupportMessageCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      SystemAnalytics: {
        payload: Prisma.$SystemAnalyticsPayload<ExtArgs>
        fields: Prisma.SystemAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.SystemAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>
          }
          findMany: {
            args: Prisma.SystemAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>[]
          }
          create: {
            args: Prisma.SystemAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>
          }
          createMany: {
            args: Prisma.SystemAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.SystemAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>
          }
          update: {
            args: Prisma.SystemAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.SystemAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemAnalyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>[]
          }
          upsert: {
            args: Prisma.SystemAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.SystemAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemAnalytics>
          }
          groupBy: {
            args: Prisma.SystemAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<SystemAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      PetRegistrationApplication: {
        payload: Prisma.$PetRegistrationApplicationPayload<ExtArgs>
        fields: Prisma.PetRegistrationApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PetRegistrationApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetRegistrationApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PetRegistrationApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetRegistrationApplicationPayload>
          }
          findFirst: {
            args: Prisma.PetRegistrationApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetRegistrationApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PetRegistrationApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetRegistrationApplicationPayload>
          }
          findMany: {
            args: Prisma.PetRegistrationApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetRegistrationApplicationPayload>[]
          }
          create: {
            args: Prisma.PetRegistrationApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetRegistrationApplicationPayload>
          }
          createMany: {
            args: Prisma.PetRegistrationApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PetRegistrationApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetRegistrationApplicationPayload>[]
          }
          delete: {
            args: Prisma.PetRegistrationApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetRegistrationApplicationPayload>
          }
          update: {
            args: Prisma.PetRegistrationApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetRegistrationApplicationPayload>
          }
          deleteMany: {
            args: Prisma.PetRegistrationApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PetRegistrationApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PetRegistrationApplicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetRegistrationApplicationPayload>[]
          }
          upsert: {
            args: Prisma.PetRegistrationApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetRegistrationApplicationPayload>
          }
          aggregate: {
            args: Prisma.PetRegistrationApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePetRegistrationApplication>
          }
          groupBy: {
            args: Prisma.PetRegistrationApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PetRegistrationApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PetRegistrationApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<PetRegistrationApplicationCountAggregateOutputType> | number
          }
        }
      }
      RegisteredPet: {
        payload: Prisma.$RegisteredPetPayload<ExtArgs>
        fields: Prisma.RegisteredPetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegisteredPetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisteredPetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegisteredPetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisteredPetPayload>
          }
          findFirst: {
            args: Prisma.RegisteredPetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisteredPetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegisteredPetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisteredPetPayload>
          }
          findMany: {
            args: Prisma.RegisteredPetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisteredPetPayload>[]
          }
          create: {
            args: Prisma.RegisteredPetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisteredPetPayload>
          }
          createMany: {
            args: Prisma.RegisteredPetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RegisteredPetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisteredPetPayload>[]
          }
          delete: {
            args: Prisma.RegisteredPetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisteredPetPayload>
          }
          update: {
            args: Prisma.RegisteredPetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisteredPetPayload>
          }
          deleteMany: {
            args: Prisma.RegisteredPetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegisteredPetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RegisteredPetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisteredPetPayload>[]
          }
          upsert: {
            args: Prisma.RegisteredPetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisteredPetPayload>
          }
          aggregate: {
            args: Prisma.RegisteredPetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegisteredPet>
          }
          groupBy: {
            args: Prisma.RegisteredPetGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegisteredPetGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegisteredPetCountArgs<ExtArgs>
            result: $Utils.Optional<RegisteredPetCountAggregateOutputType> | number
          }
        }
      }
      ApplicationDocument: {
        payload: Prisma.$ApplicationDocumentPayload<ExtArgs>
        fields: Prisma.ApplicationDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApplicationDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApplicationDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>
          }
          findFirst: {
            args: Prisma.ApplicationDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApplicationDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>
          }
          findMany: {
            args: Prisma.ApplicationDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>[]
          }
          create: {
            args: Prisma.ApplicationDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>
          }
          createMany: {
            args: Prisma.ApplicationDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApplicationDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>[]
          }
          delete: {
            args: Prisma.ApplicationDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>
          }
          update: {
            args: Prisma.ApplicationDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>
          }
          deleteMany: {
            args: Prisma.ApplicationDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApplicationDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApplicationDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>[]
          }
          upsert: {
            args: Prisma.ApplicationDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>
          }
          aggregate: {
            args: Prisma.ApplicationDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplicationDocument>
          }
          groupBy: {
            args: Prisma.ApplicationDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApplicationDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationDocumentCountAggregateOutputType> | number
          }
        }
      }
      PetDocument: {
        payload: Prisma.$PetDocumentPayload<ExtArgs>
        fields: Prisma.PetDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PetDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PetDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetDocumentPayload>
          }
          findFirst: {
            args: Prisma.PetDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PetDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetDocumentPayload>
          }
          findMany: {
            args: Prisma.PetDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetDocumentPayload>[]
          }
          create: {
            args: Prisma.PetDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetDocumentPayload>
          }
          createMany: {
            args: Prisma.PetDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PetDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetDocumentPayload>[]
          }
          delete: {
            args: Prisma.PetDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetDocumentPayload>
          }
          update: {
            args: Prisma.PetDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetDocumentPayload>
          }
          deleteMany: {
            args: Prisma.PetDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PetDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PetDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetDocumentPayload>[]
          }
          upsert: {
            args: Prisma.PetDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetDocumentPayload>
          }
          aggregate: {
            args: Prisma.PetDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePetDocument>
          }
          groupBy: {
            args: Prisma.PetDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PetDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PetDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<PetDocumentCountAggregateOutputType> | number
          }
        }
      }
      CheckoutItem: {
        payload: Prisma.$CheckoutItemPayload<ExtArgs>
        fields: Prisma.CheckoutItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CheckoutItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckoutItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CheckoutItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckoutItemPayload>
          }
          findFirst: {
            args: Prisma.CheckoutItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckoutItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CheckoutItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckoutItemPayload>
          }
          findMany: {
            args: Prisma.CheckoutItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckoutItemPayload>[]
          }
          create: {
            args: Prisma.CheckoutItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckoutItemPayload>
          }
          createMany: {
            args: Prisma.CheckoutItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CheckoutItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckoutItemPayload>[]
          }
          delete: {
            args: Prisma.CheckoutItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckoutItemPayload>
          }
          update: {
            args: Prisma.CheckoutItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckoutItemPayload>
          }
          deleteMany: {
            args: Prisma.CheckoutItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CheckoutItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CheckoutItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckoutItemPayload>[]
          }
          upsert: {
            args: Prisma.CheckoutItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckoutItemPayload>
          }
          aggregate: {
            args: Prisma.CheckoutItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCheckoutItem>
          }
          groupBy: {
            args: Prisma.CheckoutItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CheckoutItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CheckoutItemCountArgs<ExtArgs>
            result: $Utils.Optional<CheckoutItemCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    oTPCode?: OTPCodeOmit
    userSession?: UserSessionOmit
    executive?: ExecutiveOmit
    petOwner?: PetOwnerOmit
    petSpecies?: PetSpeciesOmit
    petBreed?: PetBreedOmit
    pet?: PetOmit
    vaccineType?: VaccineTypeOmit
    vaccinationRecord?: VaccinationRecordOmit
    medicalRecord?: MedicalRecordOmit
    qRCodePool?: QRCodePoolOmit
    qRCode?: QRCodeOmit
    qRScanEvent?: QRScanEventOmit
    petLocationEvent?: PetLocationEventOmit
    order?: OrderOmit
    payment?: PaymentOmit
    refund?: RefundOmit
    webhookEvent?: WebhookEventOmit
    paymentWebhook?: PaymentWebhookOmit
    paymentEvent?: PaymentEventOmit
    locationTrack?: LocationTrackOmit
    notificationPreference?: NotificationPreferenceOmit
    notification?: NotificationOmit
    deviceToken?: DeviceTokenOmit
    supportTicket?: SupportTicketOmit
    supportMessage?: SupportMessageOmit
    auditLog?: AuditLogOmit
    systemAnalytics?: SystemAnalyticsOmit
    petRegistrationApplication?: PetRegistrationApplicationOmit
    registeredPet?: RegisteredPetOmit
    applicationDocument?: ApplicationDocumentOmit
    petDocument?: PetDocumentOmit
    checkoutItem?: CheckoutItemOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    auditLogs: number
    deviceTokens: number
    locationTracks: number
    notifications: number
    orders: number
    otpCodes: number
    paymentEvents: number
    registeredPets: number
    supportMessages: number
    assignedTickets: number
    supportTickets: number
    sessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    deviceTokens?: boolean | UserCountOutputTypeCountDeviceTokensArgs
    locationTracks?: boolean | UserCountOutputTypeCountLocationTracksArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    otpCodes?: boolean | UserCountOutputTypeCountOtpCodesArgs
    paymentEvents?: boolean | UserCountOutputTypeCountPaymentEventsArgs
    registeredPets?: boolean | UserCountOutputTypeCountRegisteredPetsArgs
    supportMessages?: boolean | UserCountOutputTypeCountSupportMessagesArgs
    assignedTickets?: boolean | UserCountOutputTypeCountAssignedTicketsArgs
    supportTickets?: boolean | UserCountOutputTypeCountSupportTicketsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeviceTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLocationTracksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationTrackWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOtpCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OTPCodeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRegisteredPetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSupportMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSupportTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }


  /**
   * Count Type PetOwnerCountOutputType
   */

  export type PetOwnerCountOutputType = {
    pets: number
  }

  export type PetOwnerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pets?: boolean | PetOwnerCountOutputTypeCountPetsArgs
  }

  // Custom InputTypes
  /**
   * PetOwnerCountOutputType without action
   */
  export type PetOwnerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetOwnerCountOutputType
     */
    select?: PetOwnerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PetOwnerCountOutputType without action
   */
  export type PetOwnerCountOutputTypeCountPetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PetWhereInput
  }


  /**
   * Count Type PetSpeciesCountOutputType
   */

  export type PetSpeciesCountOutputType = {
    breeds: number
    pets: number
  }

  export type PetSpeciesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    breeds?: boolean | PetSpeciesCountOutputTypeCountBreedsArgs
    pets?: boolean | PetSpeciesCountOutputTypeCountPetsArgs
  }

  // Custom InputTypes
  /**
   * PetSpeciesCountOutputType without action
   */
  export type PetSpeciesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetSpeciesCountOutputType
     */
    select?: PetSpeciesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PetSpeciesCountOutputType without action
   */
  export type PetSpeciesCountOutputTypeCountBreedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PetBreedWhereInput
  }

  /**
   * PetSpeciesCountOutputType without action
   */
  export type PetSpeciesCountOutputTypeCountPetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PetWhereInput
  }


  /**
   * Count Type PetBreedCountOutputType
   */

  export type PetBreedCountOutputType = {
    pets_pets_breed_idTopet_breeds: number
    pets_pets_secondary_breed_idTopet_breeds: number
  }

  export type PetBreedCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pets_pets_breed_idTopet_breeds?: boolean | PetBreedCountOutputTypeCountPets_pets_breed_idTopet_breedsArgs
    pets_pets_secondary_breed_idTopet_breeds?: boolean | PetBreedCountOutputTypeCountPets_pets_secondary_breed_idTopet_breedsArgs
  }

  // Custom InputTypes
  /**
   * PetBreedCountOutputType without action
   */
  export type PetBreedCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetBreedCountOutputType
     */
    select?: PetBreedCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PetBreedCountOutputType without action
   */
  export type PetBreedCountOutputTypeCountPets_pets_breed_idTopet_breedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PetWhereInput
  }

  /**
   * PetBreedCountOutputType without action
   */
  export type PetBreedCountOutputTypeCountPets_pets_secondary_breed_idTopet_breedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PetWhereInput
  }


  /**
   * Count Type PetCountOutputType
   */

  export type PetCountOutputType = {
    medicalRecords: number
    notifications: number
    paymentEvents: number
    locationEvents: number
    qrScanEvents: number
    qrCodes: number
    supportTickets: number
    vaccinationRecords: number
  }

  export type PetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalRecords?: boolean | PetCountOutputTypeCountMedicalRecordsArgs
    notifications?: boolean | PetCountOutputTypeCountNotificationsArgs
    paymentEvents?: boolean | PetCountOutputTypeCountPaymentEventsArgs
    locationEvents?: boolean | PetCountOutputTypeCountLocationEventsArgs
    qrScanEvents?: boolean | PetCountOutputTypeCountQrScanEventsArgs
    qrCodes?: boolean | PetCountOutputTypeCountQrCodesArgs
    supportTickets?: boolean | PetCountOutputTypeCountSupportTicketsArgs
    vaccinationRecords?: boolean | PetCountOutputTypeCountVaccinationRecordsArgs
  }

  // Custom InputTypes
  /**
   * PetCountOutputType without action
   */
  export type PetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetCountOutputType
     */
    select?: PetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PetCountOutputType without action
   */
  export type PetCountOutputTypeCountMedicalRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalRecordWhereInput
  }

  /**
   * PetCountOutputType without action
   */
  export type PetCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * PetCountOutputType without action
   */
  export type PetCountOutputTypeCountPaymentEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentEventWhereInput
  }

  /**
   * PetCountOutputType without action
   */
  export type PetCountOutputTypeCountLocationEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PetLocationEventWhereInput
  }

  /**
   * PetCountOutputType without action
   */
  export type PetCountOutputTypeCountQrScanEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QRScanEventWhereInput
  }

  /**
   * PetCountOutputType without action
   */
  export type PetCountOutputTypeCountQrCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QRCodeWhereInput
  }

  /**
   * PetCountOutputType without action
   */
  export type PetCountOutputTypeCountSupportTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }

  /**
   * PetCountOutputType without action
   */
  export type PetCountOutputTypeCountVaccinationRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VaccinationRecordWhereInput
  }


  /**
   * Count Type VaccineTypeCountOutputType
   */

  export type VaccineTypeCountOutputType = {
    vaccinationRecords: number
  }

  export type VaccineTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vaccinationRecords?: boolean | VaccineTypeCountOutputTypeCountVaccinationRecordsArgs
  }

  // Custom InputTypes
  /**
   * VaccineTypeCountOutputType without action
   */
  export type VaccineTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineTypeCountOutputType
     */
    select?: VaccineTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VaccineTypeCountOutputType without action
   */
  export type VaccineTypeCountOutputTypeCountVaccinationRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VaccinationRecordWhereInput
  }


  /**
   * Count Type QRCodePoolCountOutputType
   */

  export type QRCodePoolCountOutputType = {
    qrCodes: number
  }

  export type QRCodePoolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qrCodes?: boolean | QRCodePoolCountOutputTypeCountQrCodesArgs
  }

  // Custom InputTypes
  /**
   * QRCodePoolCountOutputType without action
   */
  export type QRCodePoolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCodePoolCountOutputType
     */
    select?: QRCodePoolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QRCodePoolCountOutputType without action
   */
  export type QRCodePoolCountOutputTypeCountQrCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QRCodeWhereInput
  }


  /**
   * Count Type QRCodeCountOutputType
   */

  export type QRCodeCountOutputType = {
    paymentEvents: number
    scanEvents: number
  }

  export type QRCodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentEvents?: boolean | QRCodeCountOutputTypeCountPaymentEventsArgs
    scanEvents?: boolean | QRCodeCountOutputTypeCountScanEventsArgs
  }

  // Custom InputTypes
  /**
   * QRCodeCountOutputType without action
   */
  export type QRCodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCodeCountOutputType
     */
    select?: QRCodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QRCodeCountOutputType without action
   */
  export type QRCodeCountOutputTypeCountPaymentEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentEventWhereInput
  }

  /**
   * QRCodeCountOutputType without action
   */
  export type QRCodeCountOutputTypeCountScanEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QRScanEventWhereInput
  }


  /**
   * Count Type QRScanEventCountOutputType
   */

  export type QRScanEventCountOutputType = {
    locationEvents: number
  }

  export type QRScanEventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locationEvents?: boolean | QRScanEventCountOutputTypeCountLocationEventsArgs
  }

  // Custom InputTypes
  /**
   * QRScanEventCountOutputType without action
   */
  export type QRScanEventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRScanEventCountOutputType
     */
    select?: QRScanEventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QRScanEventCountOutputType without action
   */
  export type QRScanEventCountOutputTypeCountLocationEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PetLocationEventWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    payments: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | OrderCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type PaymentCountOutputType
   */

  export type PaymentCountOutputType = {
    refunds: number
  }

  export type PaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refunds?: boolean | PaymentCountOutputTypeCountRefundsArgs
  }

  // Custom InputTypes
  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCountOutputType
     */
    select?: PaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountRefundsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundWhereInput
  }


  /**
   * Count Type PaymentEventCountOutputType
   */

  export type PaymentEventCountOutputType = {
    refunds: number
  }

  export type PaymentEventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refunds?: boolean | PaymentEventCountOutputTypeCountRefundsArgs
  }

  // Custom InputTypes
  /**
   * PaymentEventCountOutputType without action
   */
  export type PaymentEventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEventCountOutputType
     */
    select?: PaymentEventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentEventCountOutputType without action
   */
  export type PaymentEventCountOutputTypeCountRefundsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundWhereInput
  }


  /**
   * Count Type SupportTicketCountOutputType
   */

  export type SupportTicketCountOutputType = {
    messages: number
  }

  export type SupportTicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | SupportTicketCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * SupportTicketCountOutputType without action
   */
  export type SupportTicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicketCountOutputType
     */
    select?: SupportTicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupportTicketCountOutputType without action
   */
  export type SupportTicketCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportMessageWhereInput
  }


  /**
   * Count Type PetRegistrationApplicationCountOutputType
   */

  export type PetRegistrationApplicationCountOutputType = {
    documents: number
    checkoutItems: number
    pets: number
  }

  export type PetRegistrationApplicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | PetRegistrationApplicationCountOutputTypeCountDocumentsArgs
    checkoutItems?: boolean | PetRegistrationApplicationCountOutputTypeCountCheckoutItemsArgs
    pets?: boolean | PetRegistrationApplicationCountOutputTypeCountPetsArgs
  }

  // Custom InputTypes
  /**
   * PetRegistrationApplicationCountOutputType without action
   */
  export type PetRegistrationApplicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetRegistrationApplicationCountOutputType
     */
    select?: PetRegistrationApplicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PetRegistrationApplicationCountOutputType without action
   */
  export type PetRegistrationApplicationCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationDocumentWhereInput
  }

  /**
   * PetRegistrationApplicationCountOutputType without action
   */
  export type PetRegistrationApplicationCountOutputTypeCountCheckoutItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckoutItemWhereInput
  }

  /**
   * PetRegistrationApplicationCountOutputType without action
   */
  export type PetRegistrationApplicationCountOutputTypeCountPetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegisteredPetWhereInput
  }


  /**
   * Count Type RegisteredPetCountOutputType
   */

  export type RegisteredPetCountOutputType = {
    documents: number
  }

  export type RegisteredPetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | RegisteredPetCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * RegisteredPetCountOutputType without action
   */
  export type RegisteredPetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredPetCountOutputType
     */
    select?: RegisteredPetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RegisteredPetCountOutputType without action
   */
  export type RegisteredPetCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PetDocumentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    phone: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    emailVerified: boolean | null
    phoneVerified: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    googleId: string | null
    appleId: string | null
    profilePicture: string | null
    authProvider: $Enums.AuthProvider | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    phone: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    emailVerified: boolean | null
    phoneVerified: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    googleId: string | null
    appleId: string | null
    profilePicture: string | null
    authProvider: $Enums.AuthProvider | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    phone: number
    firstName: number
    lastName: number
    role: number
    isActive: number
    emailVerified: number
    phoneVerified: number
    lastLogin: number
    createdAt: number
    updatedAt: number
    googleId: number
    appleId: number
    profilePicture: number
    authProvider: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    firstName?: true
    lastName?: true
    role?: true
    isActive?: true
    emailVerified?: true
    phoneVerified?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    googleId?: true
    appleId?: true
    profilePicture?: true
    authProvider?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    firstName?: true
    lastName?: true
    role?: true
    isActive?: true
    emailVerified?: true
    phoneVerified?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    googleId?: true
    appleId?: true
    profilePicture?: true
    authProvider?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    firstName?: true
    lastName?: true
    role?: true
    isActive?: true
    emailVerified?: true
    phoneVerified?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    googleId?: true
    appleId?: true
    profilePicture?: true
    authProvider?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string | null
    phone: string | null
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive: boolean
    emailVerified: boolean
    phoneVerified: boolean
    lastLogin: Date | null
    createdAt: Date
    updatedAt: Date
    googleId: string | null
    appleId: string | null
    profilePicture: string | null
    authProvider: $Enums.AuthProvider | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    googleId?: boolean
    appleId?: boolean
    profilePicture?: boolean
    authProvider?: boolean
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    deviceTokens?: boolean | User$deviceTokensArgs<ExtArgs>
    executive?: boolean | User$executiveArgs<ExtArgs>
    locationTracks?: boolean | User$locationTracksArgs<ExtArgs>
    notificationPrefs?: boolean | User$notificationPrefsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    otpCodes?: boolean | User$otpCodesArgs<ExtArgs>
    paymentEvents?: boolean | User$paymentEventsArgs<ExtArgs>
    petOwner?: boolean | User$petOwnerArgs<ExtArgs>
    registeredPets?: boolean | User$registeredPetsArgs<ExtArgs>
    supportMessages?: boolean | User$supportMessagesArgs<ExtArgs>
    assignedTickets?: boolean | User$assignedTicketsArgs<ExtArgs>
    supportTickets?: boolean | User$supportTicketsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    googleId?: boolean
    appleId?: boolean
    profilePicture?: boolean
    authProvider?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    googleId?: boolean
    appleId?: boolean
    profilePicture?: boolean
    authProvider?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    googleId?: boolean
    appleId?: boolean
    profilePicture?: boolean
    authProvider?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "phone" | "firstName" | "lastName" | "role" | "isActive" | "emailVerified" | "phoneVerified" | "lastLogin" | "createdAt" | "updatedAt" | "googleId" | "appleId" | "profilePicture" | "authProvider", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    deviceTokens?: boolean | User$deviceTokensArgs<ExtArgs>
    executive?: boolean | User$executiveArgs<ExtArgs>
    locationTracks?: boolean | User$locationTracksArgs<ExtArgs>
    notificationPrefs?: boolean | User$notificationPrefsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    otpCodes?: boolean | User$otpCodesArgs<ExtArgs>
    paymentEvents?: boolean | User$paymentEventsArgs<ExtArgs>
    petOwner?: boolean | User$petOwnerArgs<ExtArgs>
    registeredPets?: boolean | User$registeredPetsArgs<ExtArgs>
    supportMessages?: boolean | User$supportMessagesArgs<ExtArgs>
    assignedTickets?: boolean | User$assignedTicketsArgs<ExtArgs>
    supportTickets?: boolean | User$supportTicketsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      deviceTokens: Prisma.$DeviceTokenPayload<ExtArgs>[]
      executive: Prisma.$ExecutivePayload<ExtArgs> | null
      locationTracks: Prisma.$LocationTrackPayload<ExtArgs>[]
      notificationPrefs: Prisma.$NotificationPreferencePayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      otpCodes: Prisma.$OTPCodePayload<ExtArgs>[]
      paymentEvents: Prisma.$PaymentEventPayload<ExtArgs>[]
      petOwner: Prisma.$PetOwnerPayload<ExtArgs> | null
      registeredPets: Prisma.$PetPayload<ExtArgs>[]
      supportMessages: Prisma.$SupportMessagePayload<ExtArgs>[]
      assignedTickets: Prisma.$SupportTicketPayload<ExtArgs>[]
      supportTickets: Prisma.$SupportTicketPayload<ExtArgs>[]
      sessions: Prisma.$UserSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string | null
      phone: string | null
      firstName: string
      lastName: string
      role: $Enums.UserRole
      isActive: boolean
      emailVerified: boolean
      phoneVerified: boolean
      lastLogin: Date | null
      createdAt: Date
      updatedAt: Date
      googleId: string | null
      appleId: string | null
      profilePicture: string | null
      authProvider: $Enums.AuthProvider | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deviceTokens<T extends User$deviceTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$deviceTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    executive<T extends User$executiveArgs<ExtArgs> = {}>(args?: Subset<T, User$executiveArgs<ExtArgs>>): Prisma__ExecutiveClient<$Result.GetResult<Prisma.$ExecutivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    locationTracks<T extends User$locationTracksArgs<ExtArgs> = {}>(args?: Subset<T, User$locationTracksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationTrackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationPrefs<T extends User$notificationPrefsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationPrefsArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    otpCodes<T extends User$otpCodesArgs<ExtArgs> = {}>(args?: Subset<T, User$otpCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentEvents<T extends User$paymentEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    petOwner<T extends User$petOwnerArgs<ExtArgs> = {}>(args?: Subset<T, User$petOwnerArgs<ExtArgs>>): Prisma__PetOwnerClient<$Result.GetResult<Prisma.$PetOwnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    registeredPets<T extends User$registeredPetsArgs<ExtArgs> = {}>(args?: Subset<T, User$registeredPetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    supportMessages<T extends User$supportMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$supportMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedTickets<T extends User$assignedTicketsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    supportTickets<T extends User$supportTicketsArgs<ExtArgs> = {}>(args?: Subset<T, User$supportTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly phoneVerified: FieldRef<"User", 'Boolean'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly googleId: FieldRef<"User", 'String'>
    readonly appleId: FieldRef<"User", 'String'>
    readonly profilePicture: FieldRef<"User", 'String'>
    readonly authProvider: FieldRef<"User", 'AuthProvider'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.deviceTokens
   */
  export type User$deviceTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    where?: DeviceTokenWhereInput
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    cursor?: DeviceTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceTokenScalarFieldEnum | DeviceTokenScalarFieldEnum[]
  }

  /**
   * User.executive
   */
  export type User$executiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Executive
     */
    select?: ExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Executive
     */
    omit?: ExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutiveInclude<ExtArgs> | null
    where?: ExecutiveWhereInput
  }

  /**
   * User.locationTracks
   */
  export type User$locationTracksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationTrack
     */
    select?: LocationTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationTrack
     */
    omit?: LocationTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationTrackInclude<ExtArgs> | null
    where?: LocationTrackWhereInput
    orderBy?: LocationTrackOrderByWithRelationInput | LocationTrackOrderByWithRelationInput[]
    cursor?: LocationTrackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationTrackScalarFieldEnum | LocationTrackScalarFieldEnum[]
  }

  /**
   * User.notificationPrefs
   */
  export type User$notificationPrefsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    where?: NotificationPreferenceWhereInput
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.otpCodes
   */
  export type User$otpCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPCode
     */
    select?: OTPCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTPCode
     */
    omit?: OTPCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPCodeInclude<ExtArgs> | null
    where?: OTPCodeWhereInput
    orderBy?: OTPCodeOrderByWithRelationInput | OTPCodeOrderByWithRelationInput[]
    cursor?: OTPCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OTPCodeScalarFieldEnum | OTPCodeScalarFieldEnum[]
  }

  /**
   * User.paymentEvents
   */
  export type User$paymentEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentEvent
     */
    omit?: PaymentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
    where?: PaymentEventWhereInput
    orderBy?: PaymentEventOrderByWithRelationInput | PaymentEventOrderByWithRelationInput[]
    cursor?: PaymentEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentEventScalarFieldEnum | PaymentEventScalarFieldEnum[]
  }

  /**
   * User.petOwner
   */
  export type User$petOwnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetOwner
     */
    select?: PetOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetOwner
     */
    omit?: PetOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetOwnerInclude<ExtArgs> | null
    where?: PetOwnerWhereInput
  }

  /**
   * User.registeredPets
   */
  export type User$registeredPetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    where?: PetWhereInput
    orderBy?: PetOrderByWithRelationInput | PetOrderByWithRelationInput[]
    cursor?: PetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PetScalarFieldEnum | PetScalarFieldEnum[]
  }

  /**
   * User.supportMessages
   */
  export type User$supportMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    where?: SupportMessageWhereInput
    orderBy?: SupportMessageOrderByWithRelationInput | SupportMessageOrderByWithRelationInput[]
    cursor?: SupportMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportMessageScalarFieldEnum | SupportMessageScalarFieldEnum[]
  }

  /**
   * User.assignedTickets
   */
  export type User$assignedTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * User.supportTickets
   */
  export type User$supportTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model OTPCode
   */

  export type AggregateOTPCode = {
    _count: OTPCodeCountAggregateOutputType | null
    _avg: OTPCodeAvgAggregateOutputType | null
    _sum: OTPCodeSumAggregateOutputType | null
    _min: OTPCodeMinAggregateOutputType | null
    _max: OTPCodeMaxAggregateOutputType | null
  }

  export type OTPCodeAvgAggregateOutputType = {
    attemptsCount: number | null
    maxAttempts: number | null
  }

  export type OTPCodeSumAggregateOutputType = {
    attemptsCount: number | null
    maxAttempts: number | null
  }

  export type OTPCodeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    codeHash: string | null
    purpose: $Enums.OTPPurpose | null
    deliveryMethod: string | null
    expiresAt: Date | null
    isUsed: boolean | null
    attemptsCount: number | null
    maxAttempts: number | null
    createdAt: Date | null
  }

  export type OTPCodeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    codeHash: string | null
    purpose: $Enums.OTPPurpose | null
    deliveryMethod: string | null
    expiresAt: Date | null
    isUsed: boolean | null
    attemptsCount: number | null
    maxAttempts: number | null
    createdAt: Date | null
  }

  export type OTPCodeCountAggregateOutputType = {
    id: number
    userId: number
    codeHash: number
    purpose: number
    deliveryMethod: number
    expiresAt: number
    isUsed: number
    attemptsCount: number
    maxAttempts: number
    createdAt: number
    _all: number
  }


  export type OTPCodeAvgAggregateInputType = {
    attemptsCount?: true
    maxAttempts?: true
  }

  export type OTPCodeSumAggregateInputType = {
    attemptsCount?: true
    maxAttempts?: true
  }

  export type OTPCodeMinAggregateInputType = {
    id?: true
    userId?: true
    codeHash?: true
    purpose?: true
    deliveryMethod?: true
    expiresAt?: true
    isUsed?: true
    attemptsCount?: true
    maxAttempts?: true
    createdAt?: true
  }

  export type OTPCodeMaxAggregateInputType = {
    id?: true
    userId?: true
    codeHash?: true
    purpose?: true
    deliveryMethod?: true
    expiresAt?: true
    isUsed?: true
    attemptsCount?: true
    maxAttempts?: true
    createdAt?: true
  }

  export type OTPCodeCountAggregateInputType = {
    id?: true
    userId?: true
    codeHash?: true
    purpose?: true
    deliveryMethod?: true
    expiresAt?: true
    isUsed?: true
    attemptsCount?: true
    maxAttempts?: true
    createdAt?: true
    _all?: true
  }

  export type OTPCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OTPCode to aggregate.
     */
    where?: OTPCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPCodes to fetch.
     */
    orderBy?: OTPCodeOrderByWithRelationInput | OTPCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OTPCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OTPCodes
    **/
    _count?: true | OTPCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OTPCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OTPCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OTPCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OTPCodeMaxAggregateInputType
  }

  export type GetOTPCodeAggregateType<T extends OTPCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateOTPCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOTPCode[P]>
      : GetScalarType<T[P], AggregateOTPCode[P]>
  }




  export type OTPCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OTPCodeWhereInput
    orderBy?: OTPCodeOrderByWithAggregationInput | OTPCodeOrderByWithAggregationInput[]
    by: OTPCodeScalarFieldEnum[] | OTPCodeScalarFieldEnum
    having?: OTPCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OTPCodeCountAggregateInputType | true
    _avg?: OTPCodeAvgAggregateInputType
    _sum?: OTPCodeSumAggregateInputType
    _min?: OTPCodeMinAggregateInputType
    _max?: OTPCodeMaxAggregateInputType
  }

  export type OTPCodeGroupByOutputType = {
    id: string
    userId: string
    codeHash: string
    purpose: $Enums.OTPPurpose
    deliveryMethod: string | null
    expiresAt: Date
    isUsed: boolean
    attemptsCount: number
    maxAttempts: number
    createdAt: Date
    _count: OTPCodeCountAggregateOutputType | null
    _avg: OTPCodeAvgAggregateOutputType | null
    _sum: OTPCodeSumAggregateOutputType | null
    _min: OTPCodeMinAggregateOutputType | null
    _max: OTPCodeMaxAggregateOutputType | null
  }

  type GetOTPCodeGroupByPayload<T extends OTPCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OTPCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OTPCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OTPCodeGroupByOutputType[P]>
            : GetScalarType<T[P], OTPCodeGroupByOutputType[P]>
        }
      >
    >


  export type OTPCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    codeHash?: boolean
    purpose?: boolean
    deliveryMethod?: boolean
    expiresAt?: boolean
    isUsed?: boolean
    attemptsCount?: boolean
    maxAttempts?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oTPCode"]>

  export type OTPCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    codeHash?: boolean
    purpose?: boolean
    deliveryMethod?: boolean
    expiresAt?: boolean
    isUsed?: boolean
    attemptsCount?: boolean
    maxAttempts?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oTPCode"]>

  export type OTPCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    codeHash?: boolean
    purpose?: boolean
    deliveryMethod?: boolean
    expiresAt?: boolean
    isUsed?: boolean
    attemptsCount?: boolean
    maxAttempts?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oTPCode"]>

  export type OTPCodeSelectScalar = {
    id?: boolean
    userId?: boolean
    codeHash?: boolean
    purpose?: boolean
    deliveryMethod?: boolean
    expiresAt?: boolean
    isUsed?: boolean
    attemptsCount?: boolean
    maxAttempts?: boolean
    createdAt?: boolean
  }

  export type OTPCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "codeHash" | "purpose" | "deliveryMethod" | "expiresAt" | "isUsed" | "attemptsCount" | "maxAttempts" | "createdAt", ExtArgs["result"]["oTPCode"]>
  export type OTPCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OTPCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OTPCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OTPCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OTPCode"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      codeHash: string
      purpose: $Enums.OTPPurpose
      deliveryMethod: string | null
      expiresAt: Date
      isUsed: boolean
      attemptsCount: number
      maxAttempts: number
      createdAt: Date
    }, ExtArgs["result"]["oTPCode"]>
    composites: {}
  }

  type OTPCodeGetPayload<S extends boolean | null | undefined | OTPCodeDefaultArgs> = $Result.GetResult<Prisma.$OTPCodePayload, S>

  type OTPCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OTPCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OTPCodeCountAggregateInputType | true
    }

  export interface OTPCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OTPCode'], meta: { name: 'OTPCode' } }
    /**
     * Find zero or one OTPCode that matches the filter.
     * @param {OTPCodeFindUniqueArgs} args - Arguments to find a OTPCode
     * @example
     * // Get one OTPCode
     * const oTPCode = await prisma.oTPCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OTPCodeFindUniqueArgs>(args: SelectSubset<T, OTPCodeFindUniqueArgs<ExtArgs>>): Prisma__OTPCodeClient<$Result.GetResult<Prisma.$OTPCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OTPCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OTPCodeFindUniqueOrThrowArgs} args - Arguments to find a OTPCode
     * @example
     * // Get one OTPCode
     * const oTPCode = await prisma.oTPCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OTPCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, OTPCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OTPCodeClient<$Result.GetResult<Prisma.$OTPCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OTPCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPCodeFindFirstArgs} args - Arguments to find a OTPCode
     * @example
     * // Get one OTPCode
     * const oTPCode = await prisma.oTPCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OTPCodeFindFirstArgs>(args?: SelectSubset<T, OTPCodeFindFirstArgs<ExtArgs>>): Prisma__OTPCodeClient<$Result.GetResult<Prisma.$OTPCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OTPCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPCodeFindFirstOrThrowArgs} args - Arguments to find a OTPCode
     * @example
     * // Get one OTPCode
     * const oTPCode = await prisma.oTPCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OTPCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, OTPCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__OTPCodeClient<$Result.GetResult<Prisma.$OTPCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OTPCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OTPCodes
     * const oTPCodes = await prisma.oTPCode.findMany()
     * 
     * // Get first 10 OTPCodes
     * const oTPCodes = await prisma.oTPCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oTPCodeWithIdOnly = await prisma.oTPCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OTPCodeFindManyArgs>(args?: SelectSubset<T, OTPCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OTPCode.
     * @param {OTPCodeCreateArgs} args - Arguments to create a OTPCode.
     * @example
     * // Create one OTPCode
     * const OTPCode = await prisma.oTPCode.create({
     *   data: {
     *     // ... data to create a OTPCode
     *   }
     * })
     * 
     */
    create<T extends OTPCodeCreateArgs>(args: SelectSubset<T, OTPCodeCreateArgs<ExtArgs>>): Prisma__OTPCodeClient<$Result.GetResult<Prisma.$OTPCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OTPCodes.
     * @param {OTPCodeCreateManyArgs} args - Arguments to create many OTPCodes.
     * @example
     * // Create many OTPCodes
     * const oTPCode = await prisma.oTPCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OTPCodeCreateManyArgs>(args?: SelectSubset<T, OTPCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OTPCodes and returns the data saved in the database.
     * @param {OTPCodeCreateManyAndReturnArgs} args - Arguments to create many OTPCodes.
     * @example
     * // Create many OTPCodes
     * const oTPCode = await prisma.oTPCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OTPCodes and only return the `id`
     * const oTPCodeWithIdOnly = await prisma.oTPCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OTPCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, OTPCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OTPCode.
     * @param {OTPCodeDeleteArgs} args - Arguments to delete one OTPCode.
     * @example
     * // Delete one OTPCode
     * const OTPCode = await prisma.oTPCode.delete({
     *   where: {
     *     // ... filter to delete one OTPCode
     *   }
     * })
     * 
     */
    delete<T extends OTPCodeDeleteArgs>(args: SelectSubset<T, OTPCodeDeleteArgs<ExtArgs>>): Prisma__OTPCodeClient<$Result.GetResult<Prisma.$OTPCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OTPCode.
     * @param {OTPCodeUpdateArgs} args - Arguments to update one OTPCode.
     * @example
     * // Update one OTPCode
     * const oTPCode = await prisma.oTPCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OTPCodeUpdateArgs>(args: SelectSubset<T, OTPCodeUpdateArgs<ExtArgs>>): Prisma__OTPCodeClient<$Result.GetResult<Prisma.$OTPCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OTPCodes.
     * @param {OTPCodeDeleteManyArgs} args - Arguments to filter OTPCodes to delete.
     * @example
     * // Delete a few OTPCodes
     * const { count } = await prisma.oTPCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OTPCodeDeleteManyArgs>(args?: SelectSubset<T, OTPCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OTPCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OTPCodes
     * const oTPCode = await prisma.oTPCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OTPCodeUpdateManyArgs>(args: SelectSubset<T, OTPCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OTPCodes and returns the data updated in the database.
     * @param {OTPCodeUpdateManyAndReturnArgs} args - Arguments to update many OTPCodes.
     * @example
     * // Update many OTPCodes
     * const oTPCode = await prisma.oTPCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OTPCodes and only return the `id`
     * const oTPCodeWithIdOnly = await prisma.oTPCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OTPCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, OTPCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OTPCode.
     * @param {OTPCodeUpsertArgs} args - Arguments to update or create a OTPCode.
     * @example
     * // Update or create a OTPCode
     * const oTPCode = await prisma.oTPCode.upsert({
     *   create: {
     *     // ... data to create a OTPCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OTPCode we want to update
     *   }
     * })
     */
    upsert<T extends OTPCodeUpsertArgs>(args: SelectSubset<T, OTPCodeUpsertArgs<ExtArgs>>): Prisma__OTPCodeClient<$Result.GetResult<Prisma.$OTPCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OTPCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPCodeCountArgs} args - Arguments to filter OTPCodes to count.
     * @example
     * // Count the number of OTPCodes
     * const count = await prisma.oTPCode.count({
     *   where: {
     *     // ... the filter for the OTPCodes we want to count
     *   }
     * })
    **/
    count<T extends OTPCodeCountArgs>(
      args?: Subset<T, OTPCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OTPCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OTPCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OTPCodeAggregateArgs>(args: Subset<T, OTPCodeAggregateArgs>): Prisma.PrismaPromise<GetOTPCodeAggregateType<T>>

    /**
     * Group by OTPCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OTPCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OTPCodeGroupByArgs['orderBy'] }
        : { orderBy?: OTPCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OTPCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOTPCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OTPCode model
   */
  readonly fields: OTPCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OTPCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OTPCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OTPCode model
   */
  interface OTPCodeFieldRefs {
    readonly id: FieldRef<"OTPCode", 'String'>
    readonly userId: FieldRef<"OTPCode", 'String'>
    readonly codeHash: FieldRef<"OTPCode", 'String'>
    readonly purpose: FieldRef<"OTPCode", 'OTPPurpose'>
    readonly deliveryMethod: FieldRef<"OTPCode", 'String'>
    readonly expiresAt: FieldRef<"OTPCode", 'DateTime'>
    readonly isUsed: FieldRef<"OTPCode", 'Boolean'>
    readonly attemptsCount: FieldRef<"OTPCode", 'Int'>
    readonly maxAttempts: FieldRef<"OTPCode", 'Int'>
    readonly createdAt: FieldRef<"OTPCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OTPCode findUnique
   */
  export type OTPCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPCode
     */
    select?: OTPCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTPCode
     */
    omit?: OTPCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPCodeInclude<ExtArgs> | null
    /**
     * Filter, which OTPCode to fetch.
     */
    where: OTPCodeWhereUniqueInput
  }

  /**
   * OTPCode findUniqueOrThrow
   */
  export type OTPCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPCode
     */
    select?: OTPCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTPCode
     */
    omit?: OTPCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPCodeInclude<ExtArgs> | null
    /**
     * Filter, which OTPCode to fetch.
     */
    where: OTPCodeWhereUniqueInput
  }

  /**
   * OTPCode findFirst
   */
  export type OTPCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPCode
     */
    select?: OTPCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTPCode
     */
    omit?: OTPCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPCodeInclude<ExtArgs> | null
    /**
     * Filter, which OTPCode to fetch.
     */
    where?: OTPCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPCodes to fetch.
     */
    orderBy?: OTPCodeOrderByWithRelationInput | OTPCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OTPCodes.
     */
    cursor?: OTPCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OTPCodes.
     */
    distinct?: OTPCodeScalarFieldEnum | OTPCodeScalarFieldEnum[]
  }

  /**
   * OTPCode findFirstOrThrow
   */
  export type OTPCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPCode
     */
    select?: OTPCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTPCode
     */
    omit?: OTPCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPCodeInclude<ExtArgs> | null
    /**
     * Filter, which OTPCode to fetch.
     */
    where?: OTPCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPCodes to fetch.
     */
    orderBy?: OTPCodeOrderByWithRelationInput | OTPCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OTPCodes.
     */
    cursor?: OTPCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OTPCodes.
     */
    distinct?: OTPCodeScalarFieldEnum | OTPCodeScalarFieldEnum[]
  }

  /**
   * OTPCode findMany
   */
  export type OTPCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPCode
     */
    select?: OTPCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTPCode
     */
    omit?: OTPCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPCodeInclude<ExtArgs> | null
    /**
     * Filter, which OTPCodes to fetch.
     */
    where?: OTPCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPCodes to fetch.
     */
    orderBy?: OTPCodeOrderByWithRelationInput | OTPCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OTPCodes.
     */
    cursor?: OTPCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPCodes.
     */
    skip?: number
    distinct?: OTPCodeScalarFieldEnum | OTPCodeScalarFieldEnum[]
  }

  /**
   * OTPCode create
   */
  export type OTPCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPCode
     */
    select?: OTPCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTPCode
     */
    omit?: OTPCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a OTPCode.
     */
    data: XOR<OTPCodeCreateInput, OTPCodeUncheckedCreateInput>
  }

  /**
   * OTPCode createMany
   */
  export type OTPCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OTPCodes.
     */
    data: OTPCodeCreateManyInput | OTPCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OTPCode createManyAndReturn
   */
  export type OTPCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPCode
     */
    select?: OTPCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OTPCode
     */
    omit?: OTPCodeOmit<ExtArgs> | null
    /**
     * The data used to create many OTPCodes.
     */
    data: OTPCodeCreateManyInput | OTPCodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPCodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OTPCode update
   */
  export type OTPCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPCode
     */
    select?: OTPCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTPCode
     */
    omit?: OTPCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a OTPCode.
     */
    data: XOR<OTPCodeUpdateInput, OTPCodeUncheckedUpdateInput>
    /**
     * Choose, which OTPCode to update.
     */
    where: OTPCodeWhereUniqueInput
  }

  /**
   * OTPCode updateMany
   */
  export type OTPCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OTPCodes.
     */
    data: XOR<OTPCodeUpdateManyMutationInput, OTPCodeUncheckedUpdateManyInput>
    /**
     * Filter which OTPCodes to update
     */
    where?: OTPCodeWhereInput
    /**
     * Limit how many OTPCodes to update.
     */
    limit?: number
  }

  /**
   * OTPCode updateManyAndReturn
   */
  export type OTPCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPCode
     */
    select?: OTPCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OTPCode
     */
    omit?: OTPCodeOmit<ExtArgs> | null
    /**
     * The data used to update OTPCodes.
     */
    data: XOR<OTPCodeUpdateManyMutationInput, OTPCodeUncheckedUpdateManyInput>
    /**
     * Filter which OTPCodes to update
     */
    where?: OTPCodeWhereInput
    /**
     * Limit how many OTPCodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPCodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OTPCode upsert
   */
  export type OTPCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPCode
     */
    select?: OTPCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTPCode
     */
    omit?: OTPCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the OTPCode to update in case it exists.
     */
    where: OTPCodeWhereUniqueInput
    /**
     * In case the OTPCode found by the `where` argument doesn't exist, create a new OTPCode with this data.
     */
    create: XOR<OTPCodeCreateInput, OTPCodeUncheckedCreateInput>
    /**
     * In case the OTPCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OTPCodeUpdateInput, OTPCodeUncheckedUpdateInput>
  }

  /**
   * OTPCode delete
   */
  export type OTPCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPCode
     */
    select?: OTPCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTPCode
     */
    omit?: OTPCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPCodeInclude<ExtArgs> | null
    /**
     * Filter which OTPCode to delete.
     */
    where: OTPCodeWhereUniqueInput
  }

  /**
   * OTPCode deleteMany
   */
  export type OTPCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OTPCodes to delete
     */
    where?: OTPCodeWhereInput
    /**
     * Limit how many OTPCodes to delete.
     */
    limit?: number
  }

  /**
   * OTPCode without action
   */
  export type OTPCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPCode
     */
    select?: OTPCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTPCode
     */
    omit?: OTPCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPCodeInclude<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    refreshTokenHash: string | null
    ipAddress: string | null
    expiresAt: Date | null
    createdAt: Date | null
    lastUsedAt: Date | null
  }

  export type UserSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    refreshTokenHash: string | null
    ipAddress: string | null
    expiresAt: Date | null
    createdAt: Date | null
    lastUsedAt: Date | null
  }

  export type UserSessionCountAggregateOutputType = {
    id: number
    userId: number
    refreshTokenHash: number
    deviceInfo: number
    ipAddress: number
    expiresAt: number
    createdAt: number
    lastUsedAt: number
    _all: number
  }


  export type UserSessionMinAggregateInputType = {
    id?: true
    userId?: true
    refreshTokenHash?: true
    ipAddress?: true
    expiresAt?: true
    createdAt?: true
    lastUsedAt?: true
  }

  export type UserSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    refreshTokenHash?: true
    ipAddress?: true
    expiresAt?: true
    createdAt?: true
    lastUsedAt?: true
  }

  export type UserSessionCountAggregateInputType = {
    id?: true
    userId?: true
    refreshTokenHash?: true
    deviceInfo?: true
    ipAddress?: true
    expiresAt?: true
    createdAt?: true
    lastUsedAt?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    id: string
    userId: string
    refreshTokenHash: string
    deviceInfo: JsonValue | null
    ipAddress: string | null
    expiresAt: Date
    createdAt: Date
    lastUsedAt: Date
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshTokenHash?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshTokenHash?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshTokenHash?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    refreshTokenHash?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
  }

  export type UserSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "refreshTokenHash" | "deviceInfo" | "ipAddress" | "expiresAt" | "createdAt" | "lastUsedAt", ExtArgs["result"]["userSession"]>
  export type UserSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      refreshTokenHash: string
      deviceInfo: Prisma.JsonValue | null
      ipAddress: string | null
      expiresAt: Date
      createdAt: Date
      lastUsedAt: Date
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSessionWithIdOnly = await prisma.userSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSessions and returns the data saved in the database.
     * @param {UserSessionCreateManyAndReturnArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions and returns the data updated in the database.
     * @param {UserSessionUpdateManyAndReturnArgs} args - Arguments to update many UserSessions.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */
  interface UserSessionFieldRefs {
    readonly id: FieldRef<"UserSession", 'String'>
    readonly userId: FieldRef<"UserSession", 'String'>
    readonly refreshTokenHash: FieldRef<"UserSession", 'String'>
    readonly deviceInfo: FieldRef<"UserSession", 'Json'>
    readonly ipAddress: FieldRef<"UserSession", 'String'>
    readonly expiresAt: FieldRef<"UserSession", 'DateTime'>
    readonly createdAt: FieldRef<"UserSession", 'DateTime'>
    readonly lastUsedAt: FieldRef<"UserSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSession createManyAndReturn
   */
  export type UserSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
  }

  /**
   * UserSession updateManyAndReturn
   */
  export type UserSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to delete.
     */
    limit?: number
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
  }


  /**
   * Model Executive
   */

  export type AggregateExecutive = {
    _count: ExecutiveCountAggregateOutputType | null
    _min: ExecutiveMinAggregateOutputType | null
    _max: ExecutiveMaxAggregateOutputType | null
  }

  export type ExecutiveMinAggregateOutputType = {
    id: string | null
    userId: string | null
    employeeId: string | null
    territory: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ExecutiveMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    employeeId: string | null
    territory: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ExecutiveCountAggregateOutputType = {
    id: number
    userId: number
    employeeId: number
    territory: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type ExecutiveMinAggregateInputType = {
    id?: true
    userId?: true
    employeeId?: true
    territory?: true
    isActive?: true
    createdAt?: true
  }

  export type ExecutiveMaxAggregateInputType = {
    id?: true
    userId?: true
    employeeId?: true
    territory?: true
    isActive?: true
    createdAt?: true
  }

  export type ExecutiveCountAggregateInputType = {
    id?: true
    userId?: true
    employeeId?: true
    territory?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type ExecutiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Executive to aggregate.
     */
    where?: ExecutiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Executives to fetch.
     */
    orderBy?: ExecutiveOrderByWithRelationInput | ExecutiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExecutiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Executives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Executives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Executives
    **/
    _count?: true | ExecutiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExecutiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExecutiveMaxAggregateInputType
  }

  export type GetExecutiveAggregateType<T extends ExecutiveAggregateArgs> = {
        [P in keyof T & keyof AggregateExecutive]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExecutive[P]>
      : GetScalarType<T[P], AggregateExecutive[P]>
  }




  export type ExecutiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExecutiveWhereInput
    orderBy?: ExecutiveOrderByWithAggregationInput | ExecutiveOrderByWithAggregationInput[]
    by: ExecutiveScalarFieldEnum[] | ExecutiveScalarFieldEnum
    having?: ExecutiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExecutiveCountAggregateInputType | true
    _min?: ExecutiveMinAggregateInputType
    _max?: ExecutiveMaxAggregateInputType
  }

  export type ExecutiveGroupByOutputType = {
    id: string
    userId: string
    employeeId: string
    territory: string | null
    isActive: boolean
    createdAt: Date
    _count: ExecutiveCountAggregateOutputType | null
    _min: ExecutiveMinAggregateOutputType | null
    _max: ExecutiveMaxAggregateOutputType | null
  }

  type GetExecutiveGroupByPayload<T extends ExecutiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExecutiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExecutiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExecutiveGroupByOutputType[P]>
            : GetScalarType<T[P], ExecutiveGroupByOutputType[P]>
        }
      >
    >


  export type ExecutiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    employeeId?: boolean
    territory?: boolean
    isActive?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["executive"]>

  export type ExecutiveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    employeeId?: boolean
    territory?: boolean
    isActive?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["executive"]>

  export type ExecutiveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    employeeId?: boolean
    territory?: boolean
    isActive?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["executive"]>

  export type ExecutiveSelectScalar = {
    id?: boolean
    userId?: boolean
    employeeId?: boolean
    territory?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type ExecutiveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "employeeId" | "territory" | "isActive" | "createdAt", ExtArgs["result"]["executive"]>
  export type ExecutiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ExecutiveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ExecutiveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ExecutivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Executive"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      employeeId: string
      territory: string | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["executive"]>
    composites: {}
  }

  type ExecutiveGetPayload<S extends boolean | null | undefined | ExecutiveDefaultArgs> = $Result.GetResult<Prisma.$ExecutivePayload, S>

  type ExecutiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExecutiveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExecutiveCountAggregateInputType | true
    }

  export interface ExecutiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Executive'], meta: { name: 'Executive' } }
    /**
     * Find zero or one Executive that matches the filter.
     * @param {ExecutiveFindUniqueArgs} args - Arguments to find a Executive
     * @example
     * // Get one Executive
     * const executive = await prisma.executive.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExecutiveFindUniqueArgs>(args: SelectSubset<T, ExecutiveFindUniqueArgs<ExtArgs>>): Prisma__ExecutiveClient<$Result.GetResult<Prisma.$ExecutivePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Executive that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExecutiveFindUniqueOrThrowArgs} args - Arguments to find a Executive
     * @example
     * // Get one Executive
     * const executive = await prisma.executive.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExecutiveFindUniqueOrThrowArgs>(args: SelectSubset<T, ExecutiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExecutiveClient<$Result.GetResult<Prisma.$ExecutivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Executive that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutiveFindFirstArgs} args - Arguments to find a Executive
     * @example
     * // Get one Executive
     * const executive = await prisma.executive.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExecutiveFindFirstArgs>(args?: SelectSubset<T, ExecutiveFindFirstArgs<ExtArgs>>): Prisma__ExecutiveClient<$Result.GetResult<Prisma.$ExecutivePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Executive that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutiveFindFirstOrThrowArgs} args - Arguments to find a Executive
     * @example
     * // Get one Executive
     * const executive = await prisma.executive.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExecutiveFindFirstOrThrowArgs>(args?: SelectSubset<T, ExecutiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExecutiveClient<$Result.GetResult<Prisma.$ExecutivePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Executives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Executives
     * const executives = await prisma.executive.findMany()
     * 
     * // Get first 10 Executives
     * const executives = await prisma.executive.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const executiveWithIdOnly = await prisma.executive.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExecutiveFindManyArgs>(args?: SelectSubset<T, ExecutiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Executive.
     * @param {ExecutiveCreateArgs} args - Arguments to create a Executive.
     * @example
     * // Create one Executive
     * const Executive = await prisma.executive.create({
     *   data: {
     *     // ... data to create a Executive
     *   }
     * })
     * 
     */
    create<T extends ExecutiveCreateArgs>(args: SelectSubset<T, ExecutiveCreateArgs<ExtArgs>>): Prisma__ExecutiveClient<$Result.GetResult<Prisma.$ExecutivePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Executives.
     * @param {ExecutiveCreateManyArgs} args - Arguments to create many Executives.
     * @example
     * // Create many Executives
     * const executive = await prisma.executive.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExecutiveCreateManyArgs>(args?: SelectSubset<T, ExecutiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Executives and returns the data saved in the database.
     * @param {ExecutiveCreateManyAndReturnArgs} args - Arguments to create many Executives.
     * @example
     * // Create many Executives
     * const executive = await prisma.executive.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Executives and only return the `id`
     * const executiveWithIdOnly = await prisma.executive.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExecutiveCreateManyAndReturnArgs>(args?: SelectSubset<T, ExecutiveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutivePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Executive.
     * @param {ExecutiveDeleteArgs} args - Arguments to delete one Executive.
     * @example
     * // Delete one Executive
     * const Executive = await prisma.executive.delete({
     *   where: {
     *     // ... filter to delete one Executive
     *   }
     * })
     * 
     */
    delete<T extends ExecutiveDeleteArgs>(args: SelectSubset<T, ExecutiveDeleteArgs<ExtArgs>>): Prisma__ExecutiveClient<$Result.GetResult<Prisma.$ExecutivePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Executive.
     * @param {ExecutiveUpdateArgs} args - Arguments to update one Executive.
     * @example
     * // Update one Executive
     * const executive = await prisma.executive.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExecutiveUpdateArgs>(args: SelectSubset<T, ExecutiveUpdateArgs<ExtArgs>>): Prisma__ExecutiveClient<$Result.GetResult<Prisma.$ExecutivePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Executives.
     * @param {ExecutiveDeleteManyArgs} args - Arguments to filter Executives to delete.
     * @example
     * // Delete a few Executives
     * const { count } = await prisma.executive.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExecutiveDeleteManyArgs>(args?: SelectSubset<T, ExecutiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Executives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Executives
     * const executive = await prisma.executive.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExecutiveUpdateManyArgs>(args: SelectSubset<T, ExecutiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Executives and returns the data updated in the database.
     * @param {ExecutiveUpdateManyAndReturnArgs} args - Arguments to update many Executives.
     * @example
     * // Update many Executives
     * const executive = await prisma.executive.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Executives and only return the `id`
     * const executiveWithIdOnly = await prisma.executive.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExecutiveUpdateManyAndReturnArgs>(args: SelectSubset<T, ExecutiveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutivePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Executive.
     * @param {ExecutiveUpsertArgs} args - Arguments to update or create a Executive.
     * @example
     * // Update or create a Executive
     * const executive = await prisma.executive.upsert({
     *   create: {
     *     // ... data to create a Executive
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Executive we want to update
     *   }
     * })
     */
    upsert<T extends ExecutiveUpsertArgs>(args: SelectSubset<T, ExecutiveUpsertArgs<ExtArgs>>): Prisma__ExecutiveClient<$Result.GetResult<Prisma.$ExecutivePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Executives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutiveCountArgs} args - Arguments to filter Executives to count.
     * @example
     * // Count the number of Executives
     * const count = await prisma.executive.count({
     *   where: {
     *     // ... the filter for the Executives we want to count
     *   }
     * })
    **/
    count<T extends ExecutiveCountArgs>(
      args?: Subset<T, ExecutiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExecutiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Executive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExecutiveAggregateArgs>(args: Subset<T, ExecutiveAggregateArgs>): Prisma.PrismaPromise<GetExecutiveAggregateType<T>>

    /**
     * Group by Executive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExecutiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExecutiveGroupByArgs['orderBy'] }
        : { orderBy?: ExecutiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExecutiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExecutiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Executive model
   */
  readonly fields: ExecutiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Executive.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExecutiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Executive model
   */
  interface ExecutiveFieldRefs {
    readonly id: FieldRef<"Executive", 'String'>
    readonly userId: FieldRef<"Executive", 'String'>
    readonly employeeId: FieldRef<"Executive", 'String'>
    readonly territory: FieldRef<"Executive", 'String'>
    readonly isActive: FieldRef<"Executive", 'Boolean'>
    readonly createdAt: FieldRef<"Executive", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Executive findUnique
   */
  export type ExecutiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Executive
     */
    select?: ExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Executive
     */
    omit?: ExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutiveInclude<ExtArgs> | null
    /**
     * Filter, which Executive to fetch.
     */
    where: ExecutiveWhereUniqueInput
  }

  /**
   * Executive findUniqueOrThrow
   */
  export type ExecutiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Executive
     */
    select?: ExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Executive
     */
    omit?: ExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutiveInclude<ExtArgs> | null
    /**
     * Filter, which Executive to fetch.
     */
    where: ExecutiveWhereUniqueInput
  }

  /**
   * Executive findFirst
   */
  export type ExecutiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Executive
     */
    select?: ExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Executive
     */
    omit?: ExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutiveInclude<ExtArgs> | null
    /**
     * Filter, which Executive to fetch.
     */
    where?: ExecutiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Executives to fetch.
     */
    orderBy?: ExecutiveOrderByWithRelationInput | ExecutiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Executives.
     */
    cursor?: ExecutiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Executives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Executives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Executives.
     */
    distinct?: ExecutiveScalarFieldEnum | ExecutiveScalarFieldEnum[]
  }

  /**
   * Executive findFirstOrThrow
   */
  export type ExecutiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Executive
     */
    select?: ExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Executive
     */
    omit?: ExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutiveInclude<ExtArgs> | null
    /**
     * Filter, which Executive to fetch.
     */
    where?: ExecutiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Executives to fetch.
     */
    orderBy?: ExecutiveOrderByWithRelationInput | ExecutiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Executives.
     */
    cursor?: ExecutiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Executives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Executives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Executives.
     */
    distinct?: ExecutiveScalarFieldEnum | ExecutiveScalarFieldEnum[]
  }

  /**
   * Executive findMany
   */
  export type ExecutiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Executive
     */
    select?: ExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Executive
     */
    omit?: ExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutiveInclude<ExtArgs> | null
    /**
     * Filter, which Executives to fetch.
     */
    where?: ExecutiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Executives to fetch.
     */
    orderBy?: ExecutiveOrderByWithRelationInput | ExecutiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Executives.
     */
    cursor?: ExecutiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Executives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Executives.
     */
    skip?: number
    distinct?: ExecutiveScalarFieldEnum | ExecutiveScalarFieldEnum[]
  }

  /**
   * Executive create
   */
  export type ExecutiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Executive
     */
    select?: ExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Executive
     */
    omit?: ExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutiveInclude<ExtArgs> | null
    /**
     * The data needed to create a Executive.
     */
    data: XOR<ExecutiveCreateInput, ExecutiveUncheckedCreateInput>
  }

  /**
   * Executive createMany
   */
  export type ExecutiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Executives.
     */
    data: ExecutiveCreateManyInput | ExecutiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Executive createManyAndReturn
   */
  export type ExecutiveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Executive
     */
    select?: ExecutiveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Executive
     */
    omit?: ExecutiveOmit<ExtArgs> | null
    /**
     * The data used to create many Executives.
     */
    data: ExecutiveCreateManyInput | ExecutiveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutiveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Executive update
   */
  export type ExecutiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Executive
     */
    select?: ExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Executive
     */
    omit?: ExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutiveInclude<ExtArgs> | null
    /**
     * The data needed to update a Executive.
     */
    data: XOR<ExecutiveUpdateInput, ExecutiveUncheckedUpdateInput>
    /**
     * Choose, which Executive to update.
     */
    where: ExecutiveWhereUniqueInput
  }

  /**
   * Executive updateMany
   */
  export type ExecutiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Executives.
     */
    data: XOR<ExecutiveUpdateManyMutationInput, ExecutiveUncheckedUpdateManyInput>
    /**
     * Filter which Executives to update
     */
    where?: ExecutiveWhereInput
    /**
     * Limit how many Executives to update.
     */
    limit?: number
  }

  /**
   * Executive updateManyAndReturn
   */
  export type ExecutiveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Executive
     */
    select?: ExecutiveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Executive
     */
    omit?: ExecutiveOmit<ExtArgs> | null
    /**
     * The data used to update Executives.
     */
    data: XOR<ExecutiveUpdateManyMutationInput, ExecutiveUncheckedUpdateManyInput>
    /**
     * Filter which Executives to update
     */
    where?: ExecutiveWhereInput
    /**
     * Limit how many Executives to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutiveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Executive upsert
   */
  export type ExecutiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Executive
     */
    select?: ExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Executive
     */
    omit?: ExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutiveInclude<ExtArgs> | null
    /**
     * The filter to search for the Executive to update in case it exists.
     */
    where: ExecutiveWhereUniqueInput
    /**
     * In case the Executive found by the `where` argument doesn't exist, create a new Executive with this data.
     */
    create: XOR<ExecutiveCreateInput, ExecutiveUncheckedCreateInput>
    /**
     * In case the Executive was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExecutiveUpdateInput, ExecutiveUncheckedUpdateInput>
  }

  /**
   * Executive delete
   */
  export type ExecutiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Executive
     */
    select?: ExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Executive
     */
    omit?: ExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutiveInclude<ExtArgs> | null
    /**
     * Filter which Executive to delete.
     */
    where: ExecutiveWhereUniqueInput
  }

  /**
   * Executive deleteMany
   */
  export type ExecutiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Executives to delete
     */
    where?: ExecutiveWhereInput
    /**
     * Limit how many Executives to delete.
     */
    limit?: number
  }

  /**
   * Executive without action
   */
  export type ExecutiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Executive
     */
    select?: ExecutiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Executive
     */
    omit?: ExecutiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutiveInclude<ExtArgs> | null
  }


  /**
   * Model PetOwner
   */

  export type AggregatePetOwner = {
    _count: PetOwnerCountAggregateOutputType | null
    _min: PetOwnerMinAggregateOutputType | null
    _max: PetOwnerMaxAggregateOutputType | null
  }

  export type PetOwnerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    countryCode: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PetOwnerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    countryCode: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PetOwnerCountAggregateOutputType = {
    id: number
    userId: number
    addressLine1: number
    addressLine2: number
    city: number
    state: number
    postalCode: number
    countryCode: number
    emergencyContactName: number
    emergencyContactPhone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PetOwnerMinAggregateInputType = {
    id?: true
    userId?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    countryCode?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PetOwnerMaxAggregateInputType = {
    id?: true
    userId?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    countryCode?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PetOwnerCountAggregateInputType = {
    id?: true
    userId?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    countryCode?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PetOwnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PetOwner to aggregate.
     */
    where?: PetOwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetOwners to fetch.
     */
    orderBy?: PetOwnerOrderByWithRelationInput | PetOwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PetOwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetOwners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetOwners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PetOwners
    **/
    _count?: true | PetOwnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PetOwnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PetOwnerMaxAggregateInputType
  }

  export type GetPetOwnerAggregateType<T extends PetOwnerAggregateArgs> = {
        [P in keyof T & keyof AggregatePetOwner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePetOwner[P]>
      : GetScalarType<T[P], AggregatePetOwner[P]>
  }




  export type PetOwnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PetOwnerWhereInput
    orderBy?: PetOwnerOrderByWithAggregationInput | PetOwnerOrderByWithAggregationInput[]
    by: PetOwnerScalarFieldEnum[] | PetOwnerScalarFieldEnum
    having?: PetOwnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PetOwnerCountAggregateInputType | true
    _min?: PetOwnerMinAggregateInputType
    _max?: PetOwnerMaxAggregateInputType
  }

  export type PetOwnerGroupByOutputType = {
    id: string
    userId: string
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    countryCode: string
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    createdAt: Date
    updatedAt: Date
    _count: PetOwnerCountAggregateOutputType | null
    _min: PetOwnerMinAggregateOutputType | null
    _max: PetOwnerMaxAggregateOutputType | null
  }

  type GetPetOwnerGroupByPayload<T extends PetOwnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PetOwnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PetOwnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PetOwnerGroupByOutputType[P]>
            : GetScalarType<T[P], PetOwnerGroupByOutputType[P]>
        }
      >
    >


  export type PetOwnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    countryCode?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    pets?: boolean | PetOwner$petsArgs<ExtArgs>
    _count?: boolean | PetOwnerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["petOwner"]>

  export type PetOwnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    countryCode?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["petOwner"]>

  export type PetOwnerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    countryCode?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["petOwner"]>

  export type PetOwnerSelectScalar = {
    id?: boolean
    userId?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    countryCode?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PetOwnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "addressLine1" | "addressLine2" | "city" | "state" | "postalCode" | "countryCode" | "emergencyContactName" | "emergencyContactPhone" | "createdAt" | "updatedAt", ExtArgs["result"]["petOwner"]>
  export type PetOwnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    pets?: boolean | PetOwner$petsArgs<ExtArgs>
    _count?: boolean | PetOwnerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PetOwnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PetOwnerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PetOwnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PetOwner"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      pets: Prisma.$PetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      addressLine1: string | null
      addressLine2: string | null
      city: string | null
      state: string | null
      postalCode: string | null
      countryCode: string
      emergencyContactName: string | null
      emergencyContactPhone: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["petOwner"]>
    composites: {}
  }

  type PetOwnerGetPayload<S extends boolean | null | undefined | PetOwnerDefaultArgs> = $Result.GetResult<Prisma.$PetOwnerPayload, S>

  type PetOwnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PetOwnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PetOwnerCountAggregateInputType | true
    }

  export interface PetOwnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PetOwner'], meta: { name: 'PetOwner' } }
    /**
     * Find zero or one PetOwner that matches the filter.
     * @param {PetOwnerFindUniqueArgs} args - Arguments to find a PetOwner
     * @example
     * // Get one PetOwner
     * const petOwner = await prisma.petOwner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PetOwnerFindUniqueArgs>(args: SelectSubset<T, PetOwnerFindUniqueArgs<ExtArgs>>): Prisma__PetOwnerClient<$Result.GetResult<Prisma.$PetOwnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PetOwner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PetOwnerFindUniqueOrThrowArgs} args - Arguments to find a PetOwner
     * @example
     * // Get one PetOwner
     * const petOwner = await prisma.petOwner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PetOwnerFindUniqueOrThrowArgs>(args: SelectSubset<T, PetOwnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PetOwnerClient<$Result.GetResult<Prisma.$PetOwnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PetOwner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetOwnerFindFirstArgs} args - Arguments to find a PetOwner
     * @example
     * // Get one PetOwner
     * const petOwner = await prisma.petOwner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PetOwnerFindFirstArgs>(args?: SelectSubset<T, PetOwnerFindFirstArgs<ExtArgs>>): Prisma__PetOwnerClient<$Result.GetResult<Prisma.$PetOwnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PetOwner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetOwnerFindFirstOrThrowArgs} args - Arguments to find a PetOwner
     * @example
     * // Get one PetOwner
     * const petOwner = await prisma.petOwner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PetOwnerFindFirstOrThrowArgs>(args?: SelectSubset<T, PetOwnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PetOwnerClient<$Result.GetResult<Prisma.$PetOwnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PetOwners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetOwnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PetOwners
     * const petOwners = await prisma.petOwner.findMany()
     * 
     * // Get first 10 PetOwners
     * const petOwners = await prisma.petOwner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const petOwnerWithIdOnly = await prisma.petOwner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PetOwnerFindManyArgs>(args?: SelectSubset<T, PetOwnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetOwnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PetOwner.
     * @param {PetOwnerCreateArgs} args - Arguments to create a PetOwner.
     * @example
     * // Create one PetOwner
     * const PetOwner = await prisma.petOwner.create({
     *   data: {
     *     // ... data to create a PetOwner
     *   }
     * })
     * 
     */
    create<T extends PetOwnerCreateArgs>(args: SelectSubset<T, PetOwnerCreateArgs<ExtArgs>>): Prisma__PetOwnerClient<$Result.GetResult<Prisma.$PetOwnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PetOwners.
     * @param {PetOwnerCreateManyArgs} args - Arguments to create many PetOwners.
     * @example
     * // Create many PetOwners
     * const petOwner = await prisma.petOwner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PetOwnerCreateManyArgs>(args?: SelectSubset<T, PetOwnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PetOwners and returns the data saved in the database.
     * @param {PetOwnerCreateManyAndReturnArgs} args - Arguments to create many PetOwners.
     * @example
     * // Create many PetOwners
     * const petOwner = await prisma.petOwner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PetOwners and only return the `id`
     * const petOwnerWithIdOnly = await prisma.petOwner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PetOwnerCreateManyAndReturnArgs>(args?: SelectSubset<T, PetOwnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetOwnerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PetOwner.
     * @param {PetOwnerDeleteArgs} args - Arguments to delete one PetOwner.
     * @example
     * // Delete one PetOwner
     * const PetOwner = await prisma.petOwner.delete({
     *   where: {
     *     // ... filter to delete one PetOwner
     *   }
     * })
     * 
     */
    delete<T extends PetOwnerDeleteArgs>(args: SelectSubset<T, PetOwnerDeleteArgs<ExtArgs>>): Prisma__PetOwnerClient<$Result.GetResult<Prisma.$PetOwnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PetOwner.
     * @param {PetOwnerUpdateArgs} args - Arguments to update one PetOwner.
     * @example
     * // Update one PetOwner
     * const petOwner = await prisma.petOwner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PetOwnerUpdateArgs>(args: SelectSubset<T, PetOwnerUpdateArgs<ExtArgs>>): Prisma__PetOwnerClient<$Result.GetResult<Prisma.$PetOwnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PetOwners.
     * @param {PetOwnerDeleteManyArgs} args - Arguments to filter PetOwners to delete.
     * @example
     * // Delete a few PetOwners
     * const { count } = await prisma.petOwner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PetOwnerDeleteManyArgs>(args?: SelectSubset<T, PetOwnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PetOwners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetOwnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PetOwners
     * const petOwner = await prisma.petOwner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PetOwnerUpdateManyArgs>(args: SelectSubset<T, PetOwnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PetOwners and returns the data updated in the database.
     * @param {PetOwnerUpdateManyAndReturnArgs} args - Arguments to update many PetOwners.
     * @example
     * // Update many PetOwners
     * const petOwner = await prisma.petOwner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PetOwners and only return the `id`
     * const petOwnerWithIdOnly = await prisma.petOwner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PetOwnerUpdateManyAndReturnArgs>(args: SelectSubset<T, PetOwnerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetOwnerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PetOwner.
     * @param {PetOwnerUpsertArgs} args - Arguments to update or create a PetOwner.
     * @example
     * // Update or create a PetOwner
     * const petOwner = await prisma.petOwner.upsert({
     *   create: {
     *     // ... data to create a PetOwner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PetOwner we want to update
     *   }
     * })
     */
    upsert<T extends PetOwnerUpsertArgs>(args: SelectSubset<T, PetOwnerUpsertArgs<ExtArgs>>): Prisma__PetOwnerClient<$Result.GetResult<Prisma.$PetOwnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PetOwners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetOwnerCountArgs} args - Arguments to filter PetOwners to count.
     * @example
     * // Count the number of PetOwners
     * const count = await prisma.petOwner.count({
     *   where: {
     *     // ... the filter for the PetOwners we want to count
     *   }
     * })
    **/
    count<T extends PetOwnerCountArgs>(
      args?: Subset<T, PetOwnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PetOwnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PetOwner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetOwnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PetOwnerAggregateArgs>(args: Subset<T, PetOwnerAggregateArgs>): Prisma.PrismaPromise<GetPetOwnerAggregateType<T>>

    /**
     * Group by PetOwner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetOwnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PetOwnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PetOwnerGroupByArgs['orderBy'] }
        : { orderBy?: PetOwnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PetOwnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPetOwnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PetOwner model
   */
  readonly fields: PetOwnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PetOwner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PetOwnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pets<T extends PetOwner$petsArgs<ExtArgs> = {}>(args?: Subset<T, PetOwner$petsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PetOwner model
   */
  interface PetOwnerFieldRefs {
    readonly id: FieldRef<"PetOwner", 'String'>
    readonly userId: FieldRef<"PetOwner", 'String'>
    readonly addressLine1: FieldRef<"PetOwner", 'String'>
    readonly addressLine2: FieldRef<"PetOwner", 'String'>
    readonly city: FieldRef<"PetOwner", 'String'>
    readonly state: FieldRef<"PetOwner", 'String'>
    readonly postalCode: FieldRef<"PetOwner", 'String'>
    readonly countryCode: FieldRef<"PetOwner", 'String'>
    readonly emergencyContactName: FieldRef<"PetOwner", 'String'>
    readonly emergencyContactPhone: FieldRef<"PetOwner", 'String'>
    readonly createdAt: FieldRef<"PetOwner", 'DateTime'>
    readonly updatedAt: FieldRef<"PetOwner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PetOwner findUnique
   */
  export type PetOwnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetOwner
     */
    select?: PetOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetOwner
     */
    omit?: PetOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetOwnerInclude<ExtArgs> | null
    /**
     * Filter, which PetOwner to fetch.
     */
    where: PetOwnerWhereUniqueInput
  }

  /**
   * PetOwner findUniqueOrThrow
   */
  export type PetOwnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetOwner
     */
    select?: PetOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetOwner
     */
    omit?: PetOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetOwnerInclude<ExtArgs> | null
    /**
     * Filter, which PetOwner to fetch.
     */
    where: PetOwnerWhereUniqueInput
  }

  /**
   * PetOwner findFirst
   */
  export type PetOwnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetOwner
     */
    select?: PetOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetOwner
     */
    omit?: PetOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetOwnerInclude<ExtArgs> | null
    /**
     * Filter, which PetOwner to fetch.
     */
    where?: PetOwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetOwners to fetch.
     */
    orderBy?: PetOwnerOrderByWithRelationInput | PetOwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PetOwners.
     */
    cursor?: PetOwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetOwners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetOwners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PetOwners.
     */
    distinct?: PetOwnerScalarFieldEnum | PetOwnerScalarFieldEnum[]
  }

  /**
   * PetOwner findFirstOrThrow
   */
  export type PetOwnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetOwner
     */
    select?: PetOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetOwner
     */
    omit?: PetOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetOwnerInclude<ExtArgs> | null
    /**
     * Filter, which PetOwner to fetch.
     */
    where?: PetOwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetOwners to fetch.
     */
    orderBy?: PetOwnerOrderByWithRelationInput | PetOwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PetOwners.
     */
    cursor?: PetOwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetOwners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetOwners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PetOwners.
     */
    distinct?: PetOwnerScalarFieldEnum | PetOwnerScalarFieldEnum[]
  }

  /**
   * PetOwner findMany
   */
  export type PetOwnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetOwner
     */
    select?: PetOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetOwner
     */
    omit?: PetOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetOwnerInclude<ExtArgs> | null
    /**
     * Filter, which PetOwners to fetch.
     */
    where?: PetOwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetOwners to fetch.
     */
    orderBy?: PetOwnerOrderByWithRelationInput | PetOwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PetOwners.
     */
    cursor?: PetOwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetOwners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetOwners.
     */
    skip?: number
    distinct?: PetOwnerScalarFieldEnum | PetOwnerScalarFieldEnum[]
  }

  /**
   * PetOwner create
   */
  export type PetOwnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetOwner
     */
    select?: PetOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetOwner
     */
    omit?: PetOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetOwnerInclude<ExtArgs> | null
    /**
     * The data needed to create a PetOwner.
     */
    data: XOR<PetOwnerCreateInput, PetOwnerUncheckedCreateInput>
  }

  /**
   * PetOwner createMany
   */
  export type PetOwnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PetOwners.
     */
    data: PetOwnerCreateManyInput | PetOwnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PetOwner createManyAndReturn
   */
  export type PetOwnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetOwner
     */
    select?: PetOwnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PetOwner
     */
    omit?: PetOwnerOmit<ExtArgs> | null
    /**
     * The data used to create many PetOwners.
     */
    data: PetOwnerCreateManyInput | PetOwnerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetOwnerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PetOwner update
   */
  export type PetOwnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetOwner
     */
    select?: PetOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetOwner
     */
    omit?: PetOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetOwnerInclude<ExtArgs> | null
    /**
     * The data needed to update a PetOwner.
     */
    data: XOR<PetOwnerUpdateInput, PetOwnerUncheckedUpdateInput>
    /**
     * Choose, which PetOwner to update.
     */
    where: PetOwnerWhereUniqueInput
  }

  /**
   * PetOwner updateMany
   */
  export type PetOwnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PetOwners.
     */
    data: XOR<PetOwnerUpdateManyMutationInput, PetOwnerUncheckedUpdateManyInput>
    /**
     * Filter which PetOwners to update
     */
    where?: PetOwnerWhereInput
    /**
     * Limit how many PetOwners to update.
     */
    limit?: number
  }

  /**
   * PetOwner updateManyAndReturn
   */
  export type PetOwnerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetOwner
     */
    select?: PetOwnerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PetOwner
     */
    omit?: PetOwnerOmit<ExtArgs> | null
    /**
     * The data used to update PetOwners.
     */
    data: XOR<PetOwnerUpdateManyMutationInput, PetOwnerUncheckedUpdateManyInput>
    /**
     * Filter which PetOwners to update
     */
    where?: PetOwnerWhereInput
    /**
     * Limit how many PetOwners to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetOwnerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PetOwner upsert
   */
  export type PetOwnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetOwner
     */
    select?: PetOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetOwner
     */
    omit?: PetOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetOwnerInclude<ExtArgs> | null
    /**
     * The filter to search for the PetOwner to update in case it exists.
     */
    where: PetOwnerWhereUniqueInput
    /**
     * In case the PetOwner found by the `where` argument doesn't exist, create a new PetOwner with this data.
     */
    create: XOR<PetOwnerCreateInput, PetOwnerUncheckedCreateInput>
    /**
     * In case the PetOwner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PetOwnerUpdateInput, PetOwnerUncheckedUpdateInput>
  }

  /**
   * PetOwner delete
   */
  export type PetOwnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetOwner
     */
    select?: PetOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetOwner
     */
    omit?: PetOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetOwnerInclude<ExtArgs> | null
    /**
     * Filter which PetOwner to delete.
     */
    where: PetOwnerWhereUniqueInput
  }

  /**
   * PetOwner deleteMany
   */
  export type PetOwnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PetOwners to delete
     */
    where?: PetOwnerWhereInput
    /**
     * Limit how many PetOwners to delete.
     */
    limit?: number
  }

  /**
   * PetOwner.pets
   */
  export type PetOwner$petsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    where?: PetWhereInput
    orderBy?: PetOrderByWithRelationInput | PetOrderByWithRelationInput[]
    cursor?: PetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PetScalarFieldEnum | PetScalarFieldEnum[]
  }

  /**
   * PetOwner without action
   */
  export type PetOwnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetOwner
     */
    select?: PetOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetOwner
     */
    omit?: PetOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetOwnerInclude<ExtArgs> | null
  }


  /**
   * Model PetSpecies
   */

  export type AggregatePetSpecies = {
    _count: PetSpeciesCountAggregateOutputType | null
    _avg: PetSpeciesAvgAggregateOutputType | null
    _sum: PetSpeciesSumAggregateOutputType | null
    _min: PetSpeciesMinAggregateOutputType | null
    _max: PetSpeciesMaxAggregateOutputType | null
  }

  export type PetSpeciesAvgAggregateOutputType = {
    id: number | null
  }

  export type PetSpeciesSumAggregateOutputType = {
    id: number | null
  }

  export type PetSpeciesMinAggregateOutputType = {
    id: number | null
    speciesName: string | null
    category: string | null
  }

  export type PetSpeciesMaxAggregateOutputType = {
    id: number | null
    speciesName: string | null
    category: string | null
  }

  export type PetSpeciesCountAggregateOutputType = {
    id: number
    speciesName: number
    category: number
    _all: number
  }


  export type PetSpeciesAvgAggregateInputType = {
    id?: true
  }

  export type PetSpeciesSumAggregateInputType = {
    id?: true
  }

  export type PetSpeciesMinAggregateInputType = {
    id?: true
    speciesName?: true
    category?: true
  }

  export type PetSpeciesMaxAggregateInputType = {
    id?: true
    speciesName?: true
    category?: true
  }

  export type PetSpeciesCountAggregateInputType = {
    id?: true
    speciesName?: true
    category?: true
    _all?: true
  }

  export type PetSpeciesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PetSpecies to aggregate.
     */
    where?: PetSpeciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetSpecies to fetch.
     */
    orderBy?: PetSpeciesOrderByWithRelationInput | PetSpeciesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PetSpeciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetSpecies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetSpecies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PetSpecies
    **/
    _count?: true | PetSpeciesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PetSpeciesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PetSpeciesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PetSpeciesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PetSpeciesMaxAggregateInputType
  }

  export type GetPetSpeciesAggregateType<T extends PetSpeciesAggregateArgs> = {
        [P in keyof T & keyof AggregatePetSpecies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePetSpecies[P]>
      : GetScalarType<T[P], AggregatePetSpecies[P]>
  }




  export type PetSpeciesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PetSpeciesWhereInput
    orderBy?: PetSpeciesOrderByWithAggregationInput | PetSpeciesOrderByWithAggregationInput[]
    by: PetSpeciesScalarFieldEnum[] | PetSpeciesScalarFieldEnum
    having?: PetSpeciesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PetSpeciesCountAggregateInputType | true
    _avg?: PetSpeciesAvgAggregateInputType
    _sum?: PetSpeciesSumAggregateInputType
    _min?: PetSpeciesMinAggregateInputType
    _max?: PetSpeciesMaxAggregateInputType
  }

  export type PetSpeciesGroupByOutputType = {
    id: number
    speciesName: string
    category: string
    _count: PetSpeciesCountAggregateOutputType | null
    _avg: PetSpeciesAvgAggregateOutputType | null
    _sum: PetSpeciesSumAggregateOutputType | null
    _min: PetSpeciesMinAggregateOutputType | null
    _max: PetSpeciesMaxAggregateOutputType | null
  }

  type GetPetSpeciesGroupByPayload<T extends PetSpeciesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PetSpeciesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PetSpeciesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PetSpeciesGroupByOutputType[P]>
            : GetScalarType<T[P], PetSpeciesGroupByOutputType[P]>
        }
      >
    >


  export type PetSpeciesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    speciesName?: boolean
    category?: boolean
    breeds?: boolean | PetSpecies$breedsArgs<ExtArgs>
    pets?: boolean | PetSpecies$petsArgs<ExtArgs>
    _count?: boolean | PetSpeciesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["petSpecies"]>

  export type PetSpeciesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    speciesName?: boolean
    category?: boolean
  }, ExtArgs["result"]["petSpecies"]>

  export type PetSpeciesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    speciesName?: boolean
    category?: boolean
  }, ExtArgs["result"]["petSpecies"]>

  export type PetSpeciesSelectScalar = {
    id?: boolean
    speciesName?: boolean
    category?: boolean
  }

  export type PetSpeciesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "speciesName" | "category", ExtArgs["result"]["petSpecies"]>
  export type PetSpeciesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    breeds?: boolean | PetSpecies$breedsArgs<ExtArgs>
    pets?: boolean | PetSpecies$petsArgs<ExtArgs>
    _count?: boolean | PetSpeciesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PetSpeciesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PetSpeciesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PetSpeciesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PetSpecies"
    objects: {
      breeds: Prisma.$PetBreedPayload<ExtArgs>[]
      pets: Prisma.$PetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      speciesName: string
      category: string
    }, ExtArgs["result"]["petSpecies"]>
    composites: {}
  }

  type PetSpeciesGetPayload<S extends boolean | null | undefined | PetSpeciesDefaultArgs> = $Result.GetResult<Prisma.$PetSpeciesPayload, S>

  type PetSpeciesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PetSpeciesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PetSpeciesCountAggregateInputType | true
    }

  export interface PetSpeciesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PetSpecies'], meta: { name: 'PetSpecies' } }
    /**
     * Find zero or one PetSpecies that matches the filter.
     * @param {PetSpeciesFindUniqueArgs} args - Arguments to find a PetSpecies
     * @example
     * // Get one PetSpecies
     * const petSpecies = await prisma.petSpecies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PetSpeciesFindUniqueArgs>(args: SelectSubset<T, PetSpeciesFindUniqueArgs<ExtArgs>>): Prisma__PetSpeciesClient<$Result.GetResult<Prisma.$PetSpeciesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PetSpecies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PetSpeciesFindUniqueOrThrowArgs} args - Arguments to find a PetSpecies
     * @example
     * // Get one PetSpecies
     * const petSpecies = await prisma.petSpecies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PetSpeciesFindUniqueOrThrowArgs>(args: SelectSubset<T, PetSpeciesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PetSpeciesClient<$Result.GetResult<Prisma.$PetSpeciesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PetSpecies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetSpeciesFindFirstArgs} args - Arguments to find a PetSpecies
     * @example
     * // Get one PetSpecies
     * const petSpecies = await prisma.petSpecies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PetSpeciesFindFirstArgs>(args?: SelectSubset<T, PetSpeciesFindFirstArgs<ExtArgs>>): Prisma__PetSpeciesClient<$Result.GetResult<Prisma.$PetSpeciesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PetSpecies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetSpeciesFindFirstOrThrowArgs} args - Arguments to find a PetSpecies
     * @example
     * // Get one PetSpecies
     * const petSpecies = await prisma.petSpecies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PetSpeciesFindFirstOrThrowArgs>(args?: SelectSubset<T, PetSpeciesFindFirstOrThrowArgs<ExtArgs>>): Prisma__PetSpeciesClient<$Result.GetResult<Prisma.$PetSpeciesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PetSpecies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetSpeciesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PetSpecies
     * const petSpecies = await prisma.petSpecies.findMany()
     * 
     * // Get first 10 PetSpecies
     * const petSpecies = await prisma.petSpecies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const petSpeciesWithIdOnly = await prisma.petSpecies.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PetSpeciesFindManyArgs>(args?: SelectSubset<T, PetSpeciesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetSpeciesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PetSpecies.
     * @param {PetSpeciesCreateArgs} args - Arguments to create a PetSpecies.
     * @example
     * // Create one PetSpecies
     * const PetSpecies = await prisma.petSpecies.create({
     *   data: {
     *     // ... data to create a PetSpecies
     *   }
     * })
     * 
     */
    create<T extends PetSpeciesCreateArgs>(args: SelectSubset<T, PetSpeciesCreateArgs<ExtArgs>>): Prisma__PetSpeciesClient<$Result.GetResult<Prisma.$PetSpeciesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PetSpecies.
     * @param {PetSpeciesCreateManyArgs} args - Arguments to create many PetSpecies.
     * @example
     * // Create many PetSpecies
     * const petSpecies = await prisma.petSpecies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PetSpeciesCreateManyArgs>(args?: SelectSubset<T, PetSpeciesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PetSpecies and returns the data saved in the database.
     * @param {PetSpeciesCreateManyAndReturnArgs} args - Arguments to create many PetSpecies.
     * @example
     * // Create many PetSpecies
     * const petSpecies = await prisma.petSpecies.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PetSpecies and only return the `id`
     * const petSpeciesWithIdOnly = await prisma.petSpecies.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PetSpeciesCreateManyAndReturnArgs>(args?: SelectSubset<T, PetSpeciesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetSpeciesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PetSpecies.
     * @param {PetSpeciesDeleteArgs} args - Arguments to delete one PetSpecies.
     * @example
     * // Delete one PetSpecies
     * const PetSpecies = await prisma.petSpecies.delete({
     *   where: {
     *     // ... filter to delete one PetSpecies
     *   }
     * })
     * 
     */
    delete<T extends PetSpeciesDeleteArgs>(args: SelectSubset<T, PetSpeciesDeleteArgs<ExtArgs>>): Prisma__PetSpeciesClient<$Result.GetResult<Prisma.$PetSpeciesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PetSpecies.
     * @param {PetSpeciesUpdateArgs} args - Arguments to update one PetSpecies.
     * @example
     * // Update one PetSpecies
     * const petSpecies = await prisma.petSpecies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PetSpeciesUpdateArgs>(args: SelectSubset<T, PetSpeciesUpdateArgs<ExtArgs>>): Prisma__PetSpeciesClient<$Result.GetResult<Prisma.$PetSpeciesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PetSpecies.
     * @param {PetSpeciesDeleteManyArgs} args - Arguments to filter PetSpecies to delete.
     * @example
     * // Delete a few PetSpecies
     * const { count } = await prisma.petSpecies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PetSpeciesDeleteManyArgs>(args?: SelectSubset<T, PetSpeciesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PetSpecies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetSpeciesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PetSpecies
     * const petSpecies = await prisma.petSpecies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PetSpeciesUpdateManyArgs>(args: SelectSubset<T, PetSpeciesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PetSpecies and returns the data updated in the database.
     * @param {PetSpeciesUpdateManyAndReturnArgs} args - Arguments to update many PetSpecies.
     * @example
     * // Update many PetSpecies
     * const petSpecies = await prisma.petSpecies.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PetSpecies and only return the `id`
     * const petSpeciesWithIdOnly = await prisma.petSpecies.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PetSpeciesUpdateManyAndReturnArgs>(args: SelectSubset<T, PetSpeciesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetSpeciesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PetSpecies.
     * @param {PetSpeciesUpsertArgs} args - Arguments to update or create a PetSpecies.
     * @example
     * // Update or create a PetSpecies
     * const petSpecies = await prisma.petSpecies.upsert({
     *   create: {
     *     // ... data to create a PetSpecies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PetSpecies we want to update
     *   }
     * })
     */
    upsert<T extends PetSpeciesUpsertArgs>(args: SelectSubset<T, PetSpeciesUpsertArgs<ExtArgs>>): Prisma__PetSpeciesClient<$Result.GetResult<Prisma.$PetSpeciesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PetSpecies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetSpeciesCountArgs} args - Arguments to filter PetSpecies to count.
     * @example
     * // Count the number of PetSpecies
     * const count = await prisma.petSpecies.count({
     *   where: {
     *     // ... the filter for the PetSpecies we want to count
     *   }
     * })
    **/
    count<T extends PetSpeciesCountArgs>(
      args?: Subset<T, PetSpeciesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PetSpeciesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PetSpecies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetSpeciesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PetSpeciesAggregateArgs>(args: Subset<T, PetSpeciesAggregateArgs>): Prisma.PrismaPromise<GetPetSpeciesAggregateType<T>>

    /**
     * Group by PetSpecies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetSpeciesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PetSpeciesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PetSpeciesGroupByArgs['orderBy'] }
        : { orderBy?: PetSpeciesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PetSpeciesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPetSpeciesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PetSpecies model
   */
  readonly fields: PetSpeciesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PetSpecies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PetSpeciesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    breeds<T extends PetSpecies$breedsArgs<ExtArgs> = {}>(args?: Subset<T, PetSpecies$breedsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetBreedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pets<T extends PetSpecies$petsArgs<ExtArgs> = {}>(args?: Subset<T, PetSpecies$petsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PetSpecies model
   */
  interface PetSpeciesFieldRefs {
    readonly id: FieldRef<"PetSpecies", 'Int'>
    readonly speciesName: FieldRef<"PetSpecies", 'String'>
    readonly category: FieldRef<"PetSpecies", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PetSpecies findUnique
   */
  export type PetSpeciesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetSpecies
     */
    select?: PetSpeciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetSpecies
     */
    omit?: PetSpeciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetSpeciesInclude<ExtArgs> | null
    /**
     * Filter, which PetSpecies to fetch.
     */
    where: PetSpeciesWhereUniqueInput
  }

  /**
   * PetSpecies findUniqueOrThrow
   */
  export type PetSpeciesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetSpecies
     */
    select?: PetSpeciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetSpecies
     */
    omit?: PetSpeciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetSpeciesInclude<ExtArgs> | null
    /**
     * Filter, which PetSpecies to fetch.
     */
    where: PetSpeciesWhereUniqueInput
  }

  /**
   * PetSpecies findFirst
   */
  export type PetSpeciesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetSpecies
     */
    select?: PetSpeciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetSpecies
     */
    omit?: PetSpeciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetSpeciesInclude<ExtArgs> | null
    /**
     * Filter, which PetSpecies to fetch.
     */
    where?: PetSpeciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetSpecies to fetch.
     */
    orderBy?: PetSpeciesOrderByWithRelationInput | PetSpeciesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PetSpecies.
     */
    cursor?: PetSpeciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetSpecies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetSpecies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PetSpecies.
     */
    distinct?: PetSpeciesScalarFieldEnum | PetSpeciesScalarFieldEnum[]
  }

  /**
   * PetSpecies findFirstOrThrow
   */
  export type PetSpeciesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetSpecies
     */
    select?: PetSpeciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetSpecies
     */
    omit?: PetSpeciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetSpeciesInclude<ExtArgs> | null
    /**
     * Filter, which PetSpecies to fetch.
     */
    where?: PetSpeciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetSpecies to fetch.
     */
    orderBy?: PetSpeciesOrderByWithRelationInput | PetSpeciesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PetSpecies.
     */
    cursor?: PetSpeciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetSpecies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetSpecies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PetSpecies.
     */
    distinct?: PetSpeciesScalarFieldEnum | PetSpeciesScalarFieldEnum[]
  }

  /**
   * PetSpecies findMany
   */
  export type PetSpeciesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetSpecies
     */
    select?: PetSpeciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetSpecies
     */
    omit?: PetSpeciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetSpeciesInclude<ExtArgs> | null
    /**
     * Filter, which PetSpecies to fetch.
     */
    where?: PetSpeciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetSpecies to fetch.
     */
    orderBy?: PetSpeciesOrderByWithRelationInput | PetSpeciesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PetSpecies.
     */
    cursor?: PetSpeciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetSpecies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetSpecies.
     */
    skip?: number
    distinct?: PetSpeciesScalarFieldEnum | PetSpeciesScalarFieldEnum[]
  }

  /**
   * PetSpecies create
   */
  export type PetSpeciesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetSpecies
     */
    select?: PetSpeciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetSpecies
     */
    omit?: PetSpeciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetSpeciesInclude<ExtArgs> | null
    /**
     * The data needed to create a PetSpecies.
     */
    data: XOR<PetSpeciesCreateInput, PetSpeciesUncheckedCreateInput>
  }

  /**
   * PetSpecies createMany
   */
  export type PetSpeciesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PetSpecies.
     */
    data: PetSpeciesCreateManyInput | PetSpeciesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PetSpecies createManyAndReturn
   */
  export type PetSpeciesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetSpecies
     */
    select?: PetSpeciesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PetSpecies
     */
    omit?: PetSpeciesOmit<ExtArgs> | null
    /**
     * The data used to create many PetSpecies.
     */
    data: PetSpeciesCreateManyInput | PetSpeciesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PetSpecies update
   */
  export type PetSpeciesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetSpecies
     */
    select?: PetSpeciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetSpecies
     */
    omit?: PetSpeciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetSpeciesInclude<ExtArgs> | null
    /**
     * The data needed to update a PetSpecies.
     */
    data: XOR<PetSpeciesUpdateInput, PetSpeciesUncheckedUpdateInput>
    /**
     * Choose, which PetSpecies to update.
     */
    where: PetSpeciesWhereUniqueInput
  }

  /**
   * PetSpecies updateMany
   */
  export type PetSpeciesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PetSpecies.
     */
    data: XOR<PetSpeciesUpdateManyMutationInput, PetSpeciesUncheckedUpdateManyInput>
    /**
     * Filter which PetSpecies to update
     */
    where?: PetSpeciesWhereInput
    /**
     * Limit how many PetSpecies to update.
     */
    limit?: number
  }

  /**
   * PetSpecies updateManyAndReturn
   */
  export type PetSpeciesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetSpecies
     */
    select?: PetSpeciesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PetSpecies
     */
    omit?: PetSpeciesOmit<ExtArgs> | null
    /**
     * The data used to update PetSpecies.
     */
    data: XOR<PetSpeciesUpdateManyMutationInput, PetSpeciesUncheckedUpdateManyInput>
    /**
     * Filter which PetSpecies to update
     */
    where?: PetSpeciesWhereInput
    /**
     * Limit how many PetSpecies to update.
     */
    limit?: number
  }

  /**
   * PetSpecies upsert
   */
  export type PetSpeciesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetSpecies
     */
    select?: PetSpeciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetSpecies
     */
    omit?: PetSpeciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetSpeciesInclude<ExtArgs> | null
    /**
     * The filter to search for the PetSpecies to update in case it exists.
     */
    where: PetSpeciesWhereUniqueInput
    /**
     * In case the PetSpecies found by the `where` argument doesn't exist, create a new PetSpecies with this data.
     */
    create: XOR<PetSpeciesCreateInput, PetSpeciesUncheckedCreateInput>
    /**
     * In case the PetSpecies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PetSpeciesUpdateInput, PetSpeciesUncheckedUpdateInput>
  }

  /**
   * PetSpecies delete
   */
  export type PetSpeciesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetSpecies
     */
    select?: PetSpeciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetSpecies
     */
    omit?: PetSpeciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetSpeciesInclude<ExtArgs> | null
    /**
     * Filter which PetSpecies to delete.
     */
    where: PetSpeciesWhereUniqueInput
  }

  /**
   * PetSpecies deleteMany
   */
  export type PetSpeciesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PetSpecies to delete
     */
    where?: PetSpeciesWhereInput
    /**
     * Limit how many PetSpecies to delete.
     */
    limit?: number
  }

  /**
   * PetSpecies.breeds
   */
  export type PetSpecies$breedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetBreed
     */
    select?: PetBreedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetBreed
     */
    omit?: PetBreedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetBreedInclude<ExtArgs> | null
    where?: PetBreedWhereInput
    orderBy?: PetBreedOrderByWithRelationInput | PetBreedOrderByWithRelationInput[]
    cursor?: PetBreedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PetBreedScalarFieldEnum | PetBreedScalarFieldEnum[]
  }

  /**
   * PetSpecies.pets
   */
  export type PetSpecies$petsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    where?: PetWhereInput
    orderBy?: PetOrderByWithRelationInput | PetOrderByWithRelationInput[]
    cursor?: PetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PetScalarFieldEnum | PetScalarFieldEnum[]
  }

  /**
   * PetSpecies without action
   */
  export type PetSpeciesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetSpecies
     */
    select?: PetSpeciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetSpecies
     */
    omit?: PetSpeciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetSpeciesInclude<ExtArgs> | null
  }


  /**
   * Model PetBreed
   */

  export type AggregatePetBreed = {
    _count: PetBreedCountAggregateOutputType | null
    _avg: PetBreedAvgAggregateOutputType | null
    _sum: PetBreedSumAggregateOutputType | null
    _min: PetBreedMinAggregateOutputType | null
    _max: PetBreedMaxAggregateOutputType | null
  }

  export type PetBreedAvgAggregateOutputType = {
    id: number | null
    speciesId: number | null
    typicalLifespanYears: number | null
  }

  export type PetBreedSumAggregateOutputType = {
    id: number | null
    speciesId: number | null
    typicalLifespanYears: number | null
  }

  export type PetBreedMinAggregateOutputType = {
    id: number | null
    breedName: string | null
    speciesId: number | null
    sizeCategory: $Enums.SizeCategory | null
    typicalLifespanYears: number | null
  }

  export type PetBreedMaxAggregateOutputType = {
    id: number | null
    breedName: string | null
    speciesId: number | null
    sizeCategory: $Enums.SizeCategory | null
    typicalLifespanYears: number | null
  }

  export type PetBreedCountAggregateOutputType = {
    id: number
    breedName: number
    speciesId: number
    sizeCategory: number
    typicalLifespanYears: number
    _all: number
  }


  export type PetBreedAvgAggregateInputType = {
    id?: true
    speciesId?: true
    typicalLifespanYears?: true
  }

  export type PetBreedSumAggregateInputType = {
    id?: true
    speciesId?: true
    typicalLifespanYears?: true
  }

  export type PetBreedMinAggregateInputType = {
    id?: true
    breedName?: true
    speciesId?: true
    sizeCategory?: true
    typicalLifespanYears?: true
  }

  export type PetBreedMaxAggregateInputType = {
    id?: true
    breedName?: true
    speciesId?: true
    sizeCategory?: true
    typicalLifespanYears?: true
  }

  export type PetBreedCountAggregateInputType = {
    id?: true
    breedName?: true
    speciesId?: true
    sizeCategory?: true
    typicalLifespanYears?: true
    _all?: true
  }

  export type PetBreedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PetBreed to aggregate.
     */
    where?: PetBreedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetBreeds to fetch.
     */
    orderBy?: PetBreedOrderByWithRelationInput | PetBreedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PetBreedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetBreeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetBreeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PetBreeds
    **/
    _count?: true | PetBreedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PetBreedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PetBreedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PetBreedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PetBreedMaxAggregateInputType
  }

  export type GetPetBreedAggregateType<T extends PetBreedAggregateArgs> = {
        [P in keyof T & keyof AggregatePetBreed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePetBreed[P]>
      : GetScalarType<T[P], AggregatePetBreed[P]>
  }




  export type PetBreedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PetBreedWhereInput
    orderBy?: PetBreedOrderByWithAggregationInput | PetBreedOrderByWithAggregationInput[]
    by: PetBreedScalarFieldEnum[] | PetBreedScalarFieldEnum
    having?: PetBreedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PetBreedCountAggregateInputType | true
    _avg?: PetBreedAvgAggregateInputType
    _sum?: PetBreedSumAggregateInputType
    _min?: PetBreedMinAggregateInputType
    _max?: PetBreedMaxAggregateInputType
  }

  export type PetBreedGroupByOutputType = {
    id: number
    breedName: string
    speciesId: number
    sizeCategory: $Enums.SizeCategory | null
    typicalLifespanYears: number | null
    _count: PetBreedCountAggregateOutputType | null
    _avg: PetBreedAvgAggregateOutputType | null
    _sum: PetBreedSumAggregateOutputType | null
    _min: PetBreedMinAggregateOutputType | null
    _max: PetBreedMaxAggregateOutputType | null
  }

  type GetPetBreedGroupByPayload<T extends PetBreedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PetBreedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PetBreedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PetBreedGroupByOutputType[P]>
            : GetScalarType<T[P], PetBreedGroupByOutputType[P]>
        }
      >
    >


  export type PetBreedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    breedName?: boolean
    speciesId?: boolean
    sizeCategory?: boolean
    typicalLifespanYears?: boolean
    species?: boolean | PetSpeciesDefaultArgs<ExtArgs>
    pets_pets_breed_idTopet_breeds?: boolean | PetBreed$pets_pets_breed_idTopet_breedsArgs<ExtArgs>
    pets_pets_secondary_breed_idTopet_breeds?: boolean | PetBreed$pets_pets_secondary_breed_idTopet_breedsArgs<ExtArgs>
    _count?: boolean | PetBreedCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["petBreed"]>

  export type PetBreedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    breedName?: boolean
    speciesId?: boolean
    sizeCategory?: boolean
    typicalLifespanYears?: boolean
    species?: boolean | PetSpeciesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["petBreed"]>

  export type PetBreedSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    breedName?: boolean
    speciesId?: boolean
    sizeCategory?: boolean
    typicalLifespanYears?: boolean
    species?: boolean | PetSpeciesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["petBreed"]>

  export type PetBreedSelectScalar = {
    id?: boolean
    breedName?: boolean
    speciesId?: boolean
    sizeCategory?: boolean
    typicalLifespanYears?: boolean
  }

  export type PetBreedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "breedName" | "speciesId" | "sizeCategory" | "typicalLifespanYears", ExtArgs["result"]["petBreed"]>
  export type PetBreedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    species?: boolean | PetSpeciesDefaultArgs<ExtArgs>
    pets_pets_breed_idTopet_breeds?: boolean | PetBreed$pets_pets_breed_idTopet_breedsArgs<ExtArgs>
    pets_pets_secondary_breed_idTopet_breeds?: boolean | PetBreed$pets_pets_secondary_breed_idTopet_breedsArgs<ExtArgs>
    _count?: boolean | PetBreedCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PetBreedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    species?: boolean | PetSpeciesDefaultArgs<ExtArgs>
  }
  export type PetBreedIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    species?: boolean | PetSpeciesDefaultArgs<ExtArgs>
  }

  export type $PetBreedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PetBreed"
    objects: {
      species: Prisma.$PetSpeciesPayload<ExtArgs>
      pets_pets_breed_idTopet_breeds: Prisma.$PetPayload<ExtArgs>[]
      pets_pets_secondary_breed_idTopet_breeds: Prisma.$PetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      breedName: string
      speciesId: number
      sizeCategory: $Enums.SizeCategory | null
      typicalLifespanYears: number | null
    }, ExtArgs["result"]["petBreed"]>
    composites: {}
  }

  type PetBreedGetPayload<S extends boolean | null | undefined | PetBreedDefaultArgs> = $Result.GetResult<Prisma.$PetBreedPayload, S>

  type PetBreedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PetBreedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PetBreedCountAggregateInputType | true
    }

  export interface PetBreedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PetBreed'], meta: { name: 'PetBreed' } }
    /**
     * Find zero or one PetBreed that matches the filter.
     * @param {PetBreedFindUniqueArgs} args - Arguments to find a PetBreed
     * @example
     * // Get one PetBreed
     * const petBreed = await prisma.petBreed.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PetBreedFindUniqueArgs>(args: SelectSubset<T, PetBreedFindUniqueArgs<ExtArgs>>): Prisma__PetBreedClient<$Result.GetResult<Prisma.$PetBreedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PetBreed that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PetBreedFindUniqueOrThrowArgs} args - Arguments to find a PetBreed
     * @example
     * // Get one PetBreed
     * const petBreed = await prisma.petBreed.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PetBreedFindUniqueOrThrowArgs>(args: SelectSubset<T, PetBreedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PetBreedClient<$Result.GetResult<Prisma.$PetBreedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PetBreed that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetBreedFindFirstArgs} args - Arguments to find a PetBreed
     * @example
     * // Get one PetBreed
     * const petBreed = await prisma.petBreed.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PetBreedFindFirstArgs>(args?: SelectSubset<T, PetBreedFindFirstArgs<ExtArgs>>): Prisma__PetBreedClient<$Result.GetResult<Prisma.$PetBreedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PetBreed that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetBreedFindFirstOrThrowArgs} args - Arguments to find a PetBreed
     * @example
     * // Get one PetBreed
     * const petBreed = await prisma.petBreed.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PetBreedFindFirstOrThrowArgs>(args?: SelectSubset<T, PetBreedFindFirstOrThrowArgs<ExtArgs>>): Prisma__PetBreedClient<$Result.GetResult<Prisma.$PetBreedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PetBreeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetBreedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PetBreeds
     * const petBreeds = await prisma.petBreed.findMany()
     * 
     * // Get first 10 PetBreeds
     * const petBreeds = await prisma.petBreed.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const petBreedWithIdOnly = await prisma.petBreed.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PetBreedFindManyArgs>(args?: SelectSubset<T, PetBreedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetBreedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PetBreed.
     * @param {PetBreedCreateArgs} args - Arguments to create a PetBreed.
     * @example
     * // Create one PetBreed
     * const PetBreed = await prisma.petBreed.create({
     *   data: {
     *     // ... data to create a PetBreed
     *   }
     * })
     * 
     */
    create<T extends PetBreedCreateArgs>(args: SelectSubset<T, PetBreedCreateArgs<ExtArgs>>): Prisma__PetBreedClient<$Result.GetResult<Prisma.$PetBreedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PetBreeds.
     * @param {PetBreedCreateManyArgs} args - Arguments to create many PetBreeds.
     * @example
     * // Create many PetBreeds
     * const petBreed = await prisma.petBreed.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PetBreedCreateManyArgs>(args?: SelectSubset<T, PetBreedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PetBreeds and returns the data saved in the database.
     * @param {PetBreedCreateManyAndReturnArgs} args - Arguments to create many PetBreeds.
     * @example
     * // Create many PetBreeds
     * const petBreed = await prisma.petBreed.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PetBreeds and only return the `id`
     * const petBreedWithIdOnly = await prisma.petBreed.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PetBreedCreateManyAndReturnArgs>(args?: SelectSubset<T, PetBreedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetBreedPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PetBreed.
     * @param {PetBreedDeleteArgs} args - Arguments to delete one PetBreed.
     * @example
     * // Delete one PetBreed
     * const PetBreed = await prisma.petBreed.delete({
     *   where: {
     *     // ... filter to delete one PetBreed
     *   }
     * })
     * 
     */
    delete<T extends PetBreedDeleteArgs>(args: SelectSubset<T, PetBreedDeleteArgs<ExtArgs>>): Prisma__PetBreedClient<$Result.GetResult<Prisma.$PetBreedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PetBreed.
     * @param {PetBreedUpdateArgs} args - Arguments to update one PetBreed.
     * @example
     * // Update one PetBreed
     * const petBreed = await prisma.petBreed.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PetBreedUpdateArgs>(args: SelectSubset<T, PetBreedUpdateArgs<ExtArgs>>): Prisma__PetBreedClient<$Result.GetResult<Prisma.$PetBreedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PetBreeds.
     * @param {PetBreedDeleteManyArgs} args - Arguments to filter PetBreeds to delete.
     * @example
     * // Delete a few PetBreeds
     * const { count } = await prisma.petBreed.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PetBreedDeleteManyArgs>(args?: SelectSubset<T, PetBreedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PetBreeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetBreedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PetBreeds
     * const petBreed = await prisma.petBreed.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PetBreedUpdateManyArgs>(args: SelectSubset<T, PetBreedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PetBreeds and returns the data updated in the database.
     * @param {PetBreedUpdateManyAndReturnArgs} args - Arguments to update many PetBreeds.
     * @example
     * // Update many PetBreeds
     * const petBreed = await prisma.petBreed.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PetBreeds and only return the `id`
     * const petBreedWithIdOnly = await prisma.petBreed.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PetBreedUpdateManyAndReturnArgs>(args: SelectSubset<T, PetBreedUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetBreedPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PetBreed.
     * @param {PetBreedUpsertArgs} args - Arguments to update or create a PetBreed.
     * @example
     * // Update or create a PetBreed
     * const petBreed = await prisma.petBreed.upsert({
     *   create: {
     *     // ... data to create a PetBreed
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PetBreed we want to update
     *   }
     * })
     */
    upsert<T extends PetBreedUpsertArgs>(args: SelectSubset<T, PetBreedUpsertArgs<ExtArgs>>): Prisma__PetBreedClient<$Result.GetResult<Prisma.$PetBreedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PetBreeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetBreedCountArgs} args - Arguments to filter PetBreeds to count.
     * @example
     * // Count the number of PetBreeds
     * const count = await prisma.petBreed.count({
     *   where: {
     *     // ... the filter for the PetBreeds we want to count
     *   }
     * })
    **/
    count<T extends PetBreedCountArgs>(
      args?: Subset<T, PetBreedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PetBreedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PetBreed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetBreedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PetBreedAggregateArgs>(args: Subset<T, PetBreedAggregateArgs>): Prisma.PrismaPromise<GetPetBreedAggregateType<T>>

    /**
     * Group by PetBreed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetBreedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PetBreedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PetBreedGroupByArgs['orderBy'] }
        : { orderBy?: PetBreedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PetBreedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPetBreedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PetBreed model
   */
  readonly fields: PetBreedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PetBreed.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PetBreedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    species<T extends PetSpeciesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PetSpeciesDefaultArgs<ExtArgs>>): Prisma__PetSpeciesClient<$Result.GetResult<Prisma.$PetSpeciesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pets_pets_breed_idTopet_breeds<T extends PetBreed$pets_pets_breed_idTopet_breedsArgs<ExtArgs> = {}>(args?: Subset<T, PetBreed$pets_pets_breed_idTopet_breedsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pets_pets_secondary_breed_idTopet_breeds<T extends PetBreed$pets_pets_secondary_breed_idTopet_breedsArgs<ExtArgs> = {}>(args?: Subset<T, PetBreed$pets_pets_secondary_breed_idTopet_breedsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PetBreed model
   */
  interface PetBreedFieldRefs {
    readonly id: FieldRef<"PetBreed", 'Int'>
    readonly breedName: FieldRef<"PetBreed", 'String'>
    readonly speciesId: FieldRef<"PetBreed", 'Int'>
    readonly sizeCategory: FieldRef<"PetBreed", 'SizeCategory'>
    readonly typicalLifespanYears: FieldRef<"PetBreed", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PetBreed findUnique
   */
  export type PetBreedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetBreed
     */
    select?: PetBreedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetBreed
     */
    omit?: PetBreedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetBreedInclude<ExtArgs> | null
    /**
     * Filter, which PetBreed to fetch.
     */
    where: PetBreedWhereUniqueInput
  }

  /**
   * PetBreed findUniqueOrThrow
   */
  export type PetBreedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetBreed
     */
    select?: PetBreedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetBreed
     */
    omit?: PetBreedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetBreedInclude<ExtArgs> | null
    /**
     * Filter, which PetBreed to fetch.
     */
    where: PetBreedWhereUniqueInput
  }

  /**
   * PetBreed findFirst
   */
  export type PetBreedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetBreed
     */
    select?: PetBreedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetBreed
     */
    omit?: PetBreedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetBreedInclude<ExtArgs> | null
    /**
     * Filter, which PetBreed to fetch.
     */
    where?: PetBreedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetBreeds to fetch.
     */
    orderBy?: PetBreedOrderByWithRelationInput | PetBreedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PetBreeds.
     */
    cursor?: PetBreedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetBreeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetBreeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PetBreeds.
     */
    distinct?: PetBreedScalarFieldEnum | PetBreedScalarFieldEnum[]
  }

  /**
   * PetBreed findFirstOrThrow
   */
  export type PetBreedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetBreed
     */
    select?: PetBreedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetBreed
     */
    omit?: PetBreedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetBreedInclude<ExtArgs> | null
    /**
     * Filter, which PetBreed to fetch.
     */
    where?: PetBreedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetBreeds to fetch.
     */
    orderBy?: PetBreedOrderByWithRelationInput | PetBreedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PetBreeds.
     */
    cursor?: PetBreedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetBreeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetBreeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PetBreeds.
     */
    distinct?: PetBreedScalarFieldEnum | PetBreedScalarFieldEnum[]
  }

  /**
   * PetBreed findMany
   */
  export type PetBreedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetBreed
     */
    select?: PetBreedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetBreed
     */
    omit?: PetBreedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetBreedInclude<ExtArgs> | null
    /**
     * Filter, which PetBreeds to fetch.
     */
    where?: PetBreedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetBreeds to fetch.
     */
    orderBy?: PetBreedOrderByWithRelationInput | PetBreedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PetBreeds.
     */
    cursor?: PetBreedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetBreeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetBreeds.
     */
    skip?: number
    distinct?: PetBreedScalarFieldEnum | PetBreedScalarFieldEnum[]
  }

  /**
   * PetBreed create
   */
  export type PetBreedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetBreed
     */
    select?: PetBreedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetBreed
     */
    omit?: PetBreedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetBreedInclude<ExtArgs> | null
    /**
     * The data needed to create a PetBreed.
     */
    data: XOR<PetBreedCreateInput, PetBreedUncheckedCreateInput>
  }

  /**
   * PetBreed createMany
   */
  export type PetBreedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PetBreeds.
     */
    data: PetBreedCreateManyInput | PetBreedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PetBreed createManyAndReturn
   */
  export type PetBreedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetBreed
     */
    select?: PetBreedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PetBreed
     */
    omit?: PetBreedOmit<ExtArgs> | null
    /**
     * The data used to create many PetBreeds.
     */
    data: PetBreedCreateManyInput | PetBreedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetBreedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PetBreed update
   */
  export type PetBreedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetBreed
     */
    select?: PetBreedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetBreed
     */
    omit?: PetBreedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetBreedInclude<ExtArgs> | null
    /**
     * The data needed to update a PetBreed.
     */
    data: XOR<PetBreedUpdateInput, PetBreedUncheckedUpdateInput>
    /**
     * Choose, which PetBreed to update.
     */
    where: PetBreedWhereUniqueInput
  }

  /**
   * PetBreed updateMany
   */
  export type PetBreedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PetBreeds.
     */
    data: XOR<PetBreedUpdateManyMutationInput, PetBreedUncheckedUpdateManyInput>
    /**
     * Filter which PetBreeds to update
     */
    where?: PetBreedWhereInput
    /**
     * Limit how many PetBreeds to update.
     */
    limit?: number
  }

  /**
   * PetBreed updateManyAndReturn
   */
  export type PetBreedUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetBreed
     */
    select?: PetBreedSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PetBreed
     */
    omit?: PetBreedOmit<ExtArgs> | null
    /**
     * The data used to update PetBreeds.
     */
    data: XOR<PetBreedUpdateManyMutationInput, PetBreedUncheckedUpdateManyInput>
    /**
     * Filter which PetBreeds to update
     */
    where?: PetBreedWhereInput
    /**
     * Limit how many PetBreeds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetBreedIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PetBreed upsert
   */
  export type PetBreedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetBreed
     */
    select?: PetBreedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetBreed
     */
    omit?: PetBreedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetBreedInclude<ExtArgs> | null
    /**
     * The filter to search for the PetBreed to update in case it exists.
     */
    where: PetBreedWhereUniqueInput
    /**
     * In case the PetBreed found by the `where` argument doesn't exist, create a new PetBreed with this data.
     */
    create: XOR<PetBreedCreateInput, PetBreedUncheckedCreateInput>
    /**
     * In case the PetBreed was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PetBreedUpdateInput, PetBreedUncheckedUpdateInput>
  }

  /**
   * PetBreed delete
   */
  export type PetBreedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetBreed
     */
    select?: PetBreedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetBreed
     */
    omit?: PetBreedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetBreedInclude<ExtArgs> | null
    /**
     * Filter which PetBreed to delete.
     */
    where: PetBreedWhereUniqueInput
  }

  /**
   * PetBreed deleteMany
   */
  export type PetBreedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PetBreeds to delete
     */
    where?: PetBreedWhereInput
    /**
     * Limit how many PetBreeds to delete.
     */
    limit?: number
  }

  /**
   * PetBreed.pets_pets_breed_idTopet_breeds
   */
  export type PetBreed$pets_pets_breed_idTopet_breedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    where?: PetWhereInput
    orderBy?: PetOrderByWithRelationInput | PetOrderByWithRelationInput[]
    cursor?: PetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PetScalarFieldEnum | PetScalarFieldEnum[]
  }

  /**
   * PetBreed.pets_pets_secondary_breed_idTopet_breeds
   */
  export type PetBreed$pets_pets_secondary_breed_idTopet_breedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    where?: PetWhereInput
    orderBy?: PetOrderByWithRelationInput | PetOrderByWithRelationInput[]
    cursor?: PetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PetScalarFieldEnum | PetScalarFieldEnum[]
  }

  /**
   * PetBreed without action
   */
  export type PetBreedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetBreed
     */
    select?: PetBreedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetBreed
     */
    omit?: PetBreedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetBreedInclude<ExtArgs> | null
  }


  /**
   * Model Pet
   */

  export type AggregatePet = {
    _count: PetCountAggregateOutputType | null
    _avg: PetAvgAggregateOutputType | null
    _sum: PetSumAggregateOutputType | null
    _min: PetMinAggregateOutputType | null
    _max: PetMaxAggregateOutputType | null
  }

  export type PetAvgAggregateOutputType = {
    speciesId: number | null
    breed_id: number | null
    secondary_breed_id: number | null
    weightKg: Decimal | null
    heightCm: Decimal | null
  }

  export type PetSumAggregateOutputType = {
    speciesId: number | null
    breed_id: number | null
    secondary_breed_id: number | null
    weightKg: Decimal | null
    heightCm: Decimal | null
  }

  export type PetMinAggregateOutputType = {
    id: string | null
    ownerId: string | null
    registeredBy: string | null
    name: string | null
    speciesId: number | null
    breed_id: number | null
    secondary_breed_id: number | null
    gender: $Enums.Gender | null
    birthDate: Date | null
    color: string | null
    weightKg: Decimal | null
    heightCm: Decimal | null
    distinctiveMarks: string | null
    isSpayedNeutered: boolean | null
    microchip_id: string | null
    registrationNumber: string | null
    status: $Enums.PetStatus | null
    specialNeeds: string | null
    behavioralNotes: string | null
    profileImageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PetMaxAggregateOutputType = {
    id: string | null
    ownerId: string | null
    registeredBy: string | null
    name: string | null
    speciesId: number | null
    breed_id: number | null
    secondary_breed_id: number | null
    gender: $Enums.Gender | null
    birthDate: Date | null
    color: string | null
    weightKg: Decimal | null
    heightCm: Decimal | null
    distinctiveMarks: string | null
    isSpayedNeutered: boolean | null
    microchip_id: string | null
    registrationNumber: string | null
    status: $Enums.PetStatus | null
    specialNeeds: string | null
    behavioralNotes: string | null
    profileImageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PetCountAggregateOutputType = {
    id: number
    ownerId: number
    registeredBy: number
    name: number
    speciesId: number
    breed_id: number
    secondary_breed_id: number
    gender: number
    birthDate: number
    color: number
    weightKg: number
    heightCm: number
    distinctiveMarks: number
    isSpayedNeutered: number
    microchip_id: number
    registrationNumber: number
    status: number
    specialNeeds: number
    behavioralNotes: number
    profileImageUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PetAvgAggregateInputType = {
    speciesId?: true
    breed_id?: true
    secondary_breed_id?: true
    weightKg?: true
    heightCm?: true
  }

  export type PetSumAggregateInputType = {
    speciesId?: true
    breed_id?: true
    secondary_breed_id?: true
    weightKg?: true
    heightCm?: true
  }

  export type PetMinAggregateInputType = {
    id?: true
    ownerId?: true
    registeredBy?: true
    name?: true
    speciesId?: true
    breed_id?: true
    secondary_breed_id?: true
    gender?: true
    birthDate?: true
    color?: true
    weightKg?: true
    heightCm?: true
    distinctiveMarks?: true
    isSpayedNeutered?: true
    microchip_id?: true
    registrationNumber?: true
    status?: true
    specialNeeds?: true
    behavioralNotes?: true
    profileImageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PetMaxAggregateInputType = {
    id?: true
    ownerId?: true
    registeredBy?: true
    name?: true
    speciesId?: true
    breed_id?: true
    secondary_breed_id?: true
    gender?: true
    birthDate?: true
    color?: true
    weightKg?: true
    heightCm?: true
    distinctiveMarks?: true
    isSpayedNeutered?: true
    microchip_id?: true
    registrationNumber?: true
    status?: true
    specialNeeds?: true
    behavioralNotes?: true
    profileImageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PetCountAggregateInputType = {
    id?: true
    ownerId?: true
    registeredBy?: true
    name?: true
    speciesId?: true
    breed_id?: true
    secondary_breed_id?: true
    gender?: true
    birthDate?: true
    color?: true
    weightKg?: true
    heightCm?: true
    distinctiveMarks?: true
    isSpayedNeutered?: true
    microchip_id?: true
    registrationNumber?: true
    status?: true
    specialNeeds?: true
    behavioralNotes?: true
    profileImageUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pet to aggregate.
     */
    where?: PetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pets to fetch.
     */
    orderBy?: PetOrderByWithRelationInput | PetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pets
    **/
    _count?: true | PetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PetMaxAggregateInputType
  }

  export type GetPetAggregateType<T extends PetAggregateArgs> = {
        [P in keyof T & keyof AggregatePet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePet[P]>
      : GetScalarType<T[P], AggregatePet[P]>
  }




  export type PetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PetWhereInput
    orderBy?: PetOrderByWithAggregationInput | PetOrderByWithAggregationInput[]
    by: PetScalarFieldEnum[] | PetScalarFieldEnum
    having?: PetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PetCountAggregateInputType | true
    _avg?: PetAvgAggregateInputType
    _sum?: PetSumAggregateInputType
    _min?: PetMinAggregateInputType
    _max?: PetMaxAggregateInputType
  }

  export type PetGroupByOutputType = {
    id: string
    ownerId: string
    registeredBy: string | null
    name: string
    speciesId: number | null
    breed_id: number | null
    secondary_breed_id: number | null
    gender: $Enums.Gender
    birthDate: Date | null
    color: string | null
    weightKg: Decimal | null
    heightCm: Decimal | null
    distinctiveMarks: string | null
    isSpayedNeutered: boolean | null
    microchip_id: string | null
    registrationNumber: string | null
    status: $Enums.PetStatus
    specialNeeds: string | null
    behavioralNotes: string | null
    profileImageUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: PetCountAggregateOutputType | null
    _avg: PetAvgAggregateOutputType | null
    _sum: PetSumAggregateOutputType | null
    _min: PetMinAggregateOutputType | null
    _max: PetMaxAggregateOutputType | null
  }

  type GetPetGroupByPayload<T extends PetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PetGroupByOutputType[P]>
            : GetScalarType<T[P], PetGroupByOutputType[P]>
        }
      >
    >


  export type PetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    registeredBy?: boolean
    name?: boolean
    speciesId?: boolean
    breed_id?: boolean
    secondary_breed_id?: boolean
    gender?: boolean
    birthDate?: boolean
    color?: boolean
    weightKg?: boolean
    heightCm?: boolean
    distinctiveMarks?: boolean
    isSpayedNeutered?: boolean
    microchip_id?: boolean
    registrationNumber?: boolean
    status?: boolean
    specialNeeds?: boolean
    behavioralNotes?: boolean
    profileImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicalRecords?: boolean | Pet$medicalRecordsArgs<ExtArgs>
    notifications?: boolean | Pet$notificationsArgs<ExtArgs>
    paymentEvents?: boolean | Pet$paymentEventsArgs<ExtArgs>
    locationEvents?: boolean | Pet$locationEventsArgs<ExtArgs>
    qrScanEvents?: boolean | Pet$qrScanEventsArgs<ExtArgs>
    pet_breeds_pets_breed_idTopet_breeds?: boolean | Pet$pet_breeds_pets_breed_idTopet_breedsArgs<ExtArgs>
    owner?: boolean | PetOwnerDefaultArgs<ExtArgs>
    registeredByUser?: boolean | Pet$registeredByUserArgs<ExtArgs>
    pet_breeds_pets_secondary_breed_idTopet_breeds?: boolean | Pet$pet_breeds_pets_secondary_breed_idTopet_breedsArgs<ExtArgs>
    species?: boolean | Pet$speciesArgs<ExtArgs>
    qrCodes?: boolean | Pet$qrCodesArgs<ExtArgs>
    supportTickets?: boolean | Pet$supportTicketsArgs<ExtArgs>
    vaccinationRecords?: boolean | Pet$vaccinationRecordsArgs<ExtArgs>
    _count?: boolean | PetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pet"]>

  export type PetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    registeredBy?: boolean
    name?: boolean
    speciesId?: boolean
    breed_id?: boolean
    secondary_breed_id?: boolean
    gender?: boolean
    birthDate?: boolean
    color?: boolean
    weightKg?: boolean
    heightCm?: boolean
    distinctiveMarks?: boolean
    isSpayedNeutered?: boolean
    microchip_id?: boolean
    registrationNumber?: boolean
    status?: boolean
    specialNeeds?: boolean
    behavioralNotes?: boolean
    profileImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pet_breeds_pets_breed_idTopet_breeds?: boolean | Pet$pet_breeds_pets_breed_idTopet_breedsArgs<ExtArgs>
    owner?: boolean | PetOwnerDefaultArgs<ExtArgs>
    registeredByUser?: boolean | Pet$registeredByUserArgs<ExtArgs>
    pet_breeds_pets_secondary_breed_idTopet_breeds?: boolean | Pet$pet_breeds_pets_secondary_breed_idTopet_breedsArgs<ExtArgs>
    species?: boolean | Pet$speciesArgs<ExtArgs>
  }, ExtArgs["result"]["pet"]>

  export type PetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    registeredBy?: boolean
    name?: boolean
    speciesId?: boolean
    breed_id?: boolean
    secondary_breed_id?: boolean
    gender?: boolean
    birthDate?: boolean
    color?: boolean
    weightKg?: boolean
    heightCm?: boolean
    distinctiveMarks?: boolean
    isSpayedNeutered?: boolean
    microchip_id?: boolean
    registrationNumber?: boolean
    status?: boolean
    specialNeeds?: boolean
    behavioralNotes?: boolean
    profileImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pet_breeds_pets_breed_idTopet_breeds?: boolean | Pet$pet_breeds_pets_breed_idTopet_breedsArgs<ExtArgs>
    owner?: boolean | PetOwnerDefaultArgs<ExtArgs>
    registeredByUser?: boolean | Pet$registeredByUserArgs<ExtArgs>
    pet_breeds_pets_secondary_breed_idTopet_breeds?: boolean | Pet$pet_breeds_pets_secondary_breed_idTopet_breedsArgs<ExtArgs>
    species?: boolean | Pet$speciesArgs<ExtArgs>
  }, ExtArgs["result"]["pet"]>

  export type PetSelectScalar = {
    id?: boolean
    ownerId?: boolean
    registeredBy?: boolean
    name?: boolean
    speciesId?: boolean
    breed_id?: boolean
    secondary_breed_id?: boolean
    gender?: boolean
    birthDate?: boolean
    color?: boolean
    weightKg?: boolean
    heightCm?: boolean
    distinctiveMarks?: boolean
    isSpayedNeutered?: boolean
    microchip_id?: boolean
    registrationNumber?: boolean
    status?: boolean
    specialNeeds?: boolean
    behavioralNotes?: boolean
    profileImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ownerId" | "registeredBy" | "name" | "speciesId" | "breed_id" | "secondary_breed_id" | "gender" | "birthDate" | "color" | "weightKg" | "heightCm" | "distinctiveMarks" | "isSpayedNeutered" | "microchip_id" | "registrationNumber" | "status" | "specialNeeds" | "behavioralNotes" | "profileImageUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["pet"]>
  export type PetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalRecords?: boolean | Pet$medicalRecordsArgs<ExtArgs>
    notifications?: boolean | Pet$notificationsArgs<ExtArgs>
    paymentEvents?: boolean | Pet$paymentEventsArgs<ExtArgs>
    locationEvents?: boolean | Pet$locationEventsArgs<ExtArgs>
    qrScanEvents?: boolean | Pet$qrScanEventsArgs<ExtArgs>
    pet_breeds_pets_breed_idTopet_breeds?: boolean | Pet$pet_breeds_pets_breed_idTopet_breedsArgs<ExtArgs>
    owner?: boolean | PetOwnerDefaultArgs<ExtArgs>
    registeredByUser?: boolean | Pet$registeredByUserArgs<ExtArgs>
    pet_breeds_pets_secondary_breed_idTopet_breeds?: boolean | Pet$pet_breeds_pets_secondary_breed_idTopet_breedsArgs<ExtArgs>
    species?: boolean | Pet$speciesArgs<ExtArgs>
    qrCodes?: boolean | Pet$qrCodesArgs<ExtArgs>
    supportTickets?: boolean | Pet$supportTicketsArgs<ExtArgs>
    vaccinationRecords?: boolean | Pet$vaccinationRecordsArgs<ExtArgs>
    _count?: boolean | PetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet_breeds_pets_breed_idTopet_breeds?: boolean | Pet$pet_breeds_pets_breed_idTopet_breedsArgs<ExtArgs>
    owner?: boolean | PetOwnerDefaultArgs<ExtArgs>
    registeredByUser?: boolean | Pet$registeredByUserArgs<ExtArgs>
    pet_breeds_pets_secondary_breed_idTopet_breeds?: boolean | Pet$pet_breeds_pets_secondary_breed_idTopet_breedsArgs<ExtArgs>
    species?: boolean | Pet$speciesArgs<ExtArgs>
  }
  export type PetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet_breeds_pets_breed_idTopet_breeds?: boolean | Pet$pet_breeds_pets_breed_idTopet_breedsArgs<ExtArgs>
    owner?: boolean | PetOwnerDefaultArgs<ExtArgs>
    registeredByUser?: boolean | Pet$registeredByUserArgs<ExtArgs>
    pet_breeds_pets_secondary_breed_idTopet_breeds?: boolean | Pet$pet_breeds_pets_secondary_breed_idTopet_breedsArgs<ExtArgs>
    species?: boolean | Pet$speciesArgs<ExtArgs>
  }

  export type $PetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pet"
    objects: {
      medicalRecords: Prisma.$MedicalRecordPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      paymentEvents: Prisma.$PaymentEventPayload<ExtArgs>[]
      locationEvents: Prisma.$PetLocationEventPayload<ExtArgs>[]
      qrScanEvents: Prisma.$QRScanEventPayload<ExtArgs>[]
      pet_breeds_pets_breed_idTopet_breeds: Prisma.$PetBreedPayload<ExtArgs> | null
      owner: Prisma.$PetOwnerPayload<ExtArgs>
      registeredByUser: Prisma.$UserPayload<ExtArgs> | null
      pet_breeds_pets_secondary_breed_idTopet_breeds: Prisma.$PetBreedPayload<ExtArgs> | null
      species: Prisma.$PetSpeciesPayload<ExtArgs> | null
      qrCodes: Prisma.$QRCodePayload<ExtArgs>[]
      supportTickets: Prisma.$SupportTicketPayload<ExtArgs>[]
      vaccinationRecords: Prisma.$VaccinationRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerId: string
      registeredBy: string | null
      name: string
      speciesId: number | null
      breed_id: number | null
      secondary_breed_id: number | null
      gender: $Enums.Gender
      birthDate: Date | null
      color: string | null
      weightKg: Prisma.Decimal | null
      heightCm: Prisma.Decimal | null
      distinctiveMarks: string | null
      isSpayedNeutered: boolean | null
      microchip_id: string | null
      registrationNumber: string | null
      status: $Enums.PetStatus
      specialNeeds: string | null
      behavioralNotes: string | null
      profileImageUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pet"]>
    composites: {}
  }

  type PetGetPayload<S extends boolean | null | undefined | PetDefaultArgs> = $Result.GetResult<Prisma.$PetPayload, S>

  type PetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PetCountAggregateInputType | true
    }

  export interface PetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pet'], meta: { name: 'Pet' } }
    /**
     * Find zero or one Pet that matches the filter.
     * @param {PetFindUniqueArgs} args - Arguments to find a Pet
     * @example
     * // Get one Pet
     * const pet = await prisma.pet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PetFindUniqueArgs>(args: SelectSubset<T, PetFindUniqueArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PetFindUniqueOrThrowArgs} args - Arguments to find a Pet
     * @example
     * // Get one Pet
     * const pet = await prisma.pet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PetFindUniqueOrThrowArgs>(args: SelectSubset<T, PetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetFindFirstArgs} args - Arguments to find a Pet
     * @example
     * // Get one Pet
     * const pet = await prisma.pet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PetFindFirstArgs>(args?: SelectSubset<T, PetFindFirstArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetFindFirstOrThrowArgs} args - Arguments to find a Pet
     * @example
     * // Get one Pet
     * const pet = await prisma.pet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PetFindFirstOrThrowArgs>(args?: SelectSubset<T, PetFindFirstOrThrowArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pets
     * const pets = await prisma.pet.findMany()
     * 
     * // Get first 10 Pets
     * const pets = await prisma.pet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const petWithIdOnly = await prisma.pet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PetFindManyArgs>(args?: SelectSubset<T, PetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pet.
     * @param {PetCreateArgs} args - Arguments to create a Pet.
     * @example
     * // Create one Pet
     * const Pet = await prisma.pet.create({
     *   data: {
     *     // ... data to create a Pet
     *   }
     * })
     * 
     */
    create<T extends PetCreateArgs>(args: SelectSubset<T, PetCreateArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pets.
     * @param {PetCreateManyArgs} args - Arguments to create many Pets.
     * @example
     * // Create many Pets
     * const pet = await prisma.pet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PetCreateManyArgs>(args?: SelectSubset<T, PetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pets and returns the data saved in the database.
     * @param {PetCreateManyAndReturnArgs} args - Arguments to create many Pets.
     * @example
     * // Create many Pets
     * const pet = await prisma.pet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pets and only return the `id`
     * const petWithIdOnly = await prisma.pet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PetCreateManyAndReturnArgs>(args?: SelectSubset<T, PetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pet.
     * @param {PetDeleteArgs} args - Arguments to delete one Pet.
     * @example
     * // Delete one Pet
     * const Pet = await prisma.pet.delete({
     *   where: {
     *     // ... filter to delete one Pet
     *   }
     * })
     * 
     */
    delete<T extends PetDeleteArgs>(args: SelectSubset<T, PetDeleteArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pet.
     * @param {PetUpdateArgs} args - Arguments to update one Pet.
     * @example
     * // Update one Pet
     * const pet = await prisma.pet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PetUpdateArgs>(args: SelectSubset<T, PetUpdateArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pets.
     * @param {PetDeleteManyArgs} args - Arguments to filter Pets to delete.
     * @example
     * // Delete a few Pets
     * const { count } = await prisma.pet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PetDeleteManyArgs>(args?: SelectSubset<T, PetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pets
     * const pet = await prisma.pet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PetUpdateManyArgs>(args: SelectSubset<T, PetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pets and returns the data updated in the database.
     * @param {PetUpdateManyAndReturnArgs} args - Arguments to update many Pets.
     * @example
     * // Update many Pets
     * const pet = await prisma.pet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pets and only return the `id`
     * const petWithIdOnly = await prisma.pet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PetUpdateManyAndReturnArgs>(args: SelectSubset<T, PetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pet.
     * @param {PetUpsertArgs} args - Arguments to update or create a Pet.
     * @example
     * // Update or create a Pet
     * const pet = await prisma.pet.upsert({
     *   create: {
     *     // ... data to create a Pet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pet we want to update
     *   }
     * })
     */
    upsert<T extends PetUpsertArgs>(args: SelectSubset<T, PetUpsertArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetCountArgs} args - Arguments to filter Pets to count.
     * @example
     * // Count the number of Pets
     * const count = await prisma.pet.count({
     *   where: {
     *     // ... the filter for the Pets we want to count
     *   }
     * })
    **/
    count<T extends PetCountArgs>(
      args?: Subset<T, PetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PetAggregateArgs>(args: Subset<T, PetAggregateArgs>): Prisma.PrismaPromise<GetPetAggregateType<T>>

    /**
     * Group by Pet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PetGroupByArgs['orderBy'] }
        : { orderBy?: PetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pet model
   */
  readonly fields: PetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicalRecords<T extends Pet$medicalRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Pet$medicalRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Pet$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Pet$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentEvents<T extends Pet$paymentEventsArgs<ExtArgs> = {}>(args?: Subset<T, Pet$paymentEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    locationEvents<T extends Pet$locationEventsArgs<ExtArgs> = {}>(args?: Subset<T, Pet$locationEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetLocationEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    qrScanEvents<T extends Pet$qrScanEventsArgs<ExtArgs> = {}>(args?: Subset<T, Pet$qrScanEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRScanEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pet_breeds_pets_breed_idTopet_breeds<T extends Pet$pet_breeds_pets_breed_idTopet_breedsArgs<ExtArgs> = {}>(args?: Subset<T, Pet$pet_breeds_pets_breed_idTopet_breedsArgs<ExtArgs>>): Prisma__PetBreedClient<$Result.GetResult<Prisma.$PetBreedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    owner<T extends PetOwnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PetOwnerDefaultArgs<ExtArgs>>): Prisma__PetOwnerClient<$Result.GetResult<Prisma.$PetOwnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    registeredByUser<T extends Pet$registeredByUserArgs<ExtArgs> = {}>(args?: Subset<T, Pet$registeredByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pet_breeds_pets_secondary_breed_idTopet_breeds<T extends Pet$pet_breeds_pets_secondary_breed_idTopet_breedsArgs<ExtArgs> = {}>(args?: Subset<T, Pet$pet_breeds_pets_secondary_breed_idTopet_breedsArgs<ExtArgs>>): Prisma__PetBreedClient<$Result.GetResult<Prisma.$PetBreedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    species<T extends Pet$speciesArgs<ExtArgs> = {}>(args?: Subset<T, Pet$speciesArgs<ExtArgs>>): Prisma__PetSpeciesClient<$Result.GetResult<Prisma.$PetSpeciesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    qrCodes<T extends Pet$qrCodesArgs<ExtArgs> = {}>(args?: Subset<T, Pet$qrCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    supportTickets<T extends Pet$supportTicketsArgs<ExtArgs> = {}>(args?: Subset<T, Pet$supportTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vaccinationRecords<T extends Pet$vaccinationRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Pet$vaccinationRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinationRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pet model
   */
  interface PetFieldRefs {
    readonly id: FieldRef<"Pet", 'String'>
    readonly ownerId: FieldRef<"Pet", 'String'>
    readonly registeredBy: FieldRef<"Pet", 'String'>
    readonly name: FieldRef<"Pet", 'String'>
    readonly speciesId: FieldRef<"Pet", 'Int'>
    readonly breed_id: FieldRef<"Pet", 'Int'>
    readonly secondary_breed_id: FieldRef<"Pet", 'Int'>
    readonly gender: FieldRef<"Pet", 'Gender'>
    readonly birthDate: FieldRef<"Pet", 'DateTime'>
    readonly color: FieldRef<"Pet", 'String'>
    readonly weightKg: FieldRef<"Pet", 'Decimal'>
    readonly heightCm: FieldRef<"Pet", 'Decimal'>
    readonly distinctiveMarks: FieldRef<"Pet", 'String'>
    readonly isSpayedNeutered: FieldRef<"Pet", 'Boolean'>
    readonly microchip_id: FieldRef<"Pet", 'String'>
    readonly registrationNumber: FieldRef<"Pet", 'String'>
    readonly status: FieldRef<"Pet", 'PetStatus'>
    readonly specialNeeds: FieldRef<"Pet", 'String'>
    readonly behavioralNotes: FieldRef<"Pet", 'String'>
    readonly profileImageUrl: FieldRef<"Pet", 'String'>
    readonly createdAt: FieldRef<"Pet", 'DateTime'>
    readonly updatedAt: FieldRef<"Pet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pet findUnique
   */
  export type PetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * Filter, which Pet to fetch.
     */
    where: PetWhereUniqueInput
  }

  /**
   * Pet findUniqueOrThrow
   */
  export type PetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * Filter, which Pet to fetch.
     */
    where: PetWhereUniqueInput
  }

  /**
   * Pet findFirst
   */
  export type PetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * Filter, which Pet to fetch.
     */
    where?: PetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pets to fetch.
     */
    orderBy?: PetOrderByWithRelationInput | PetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pets.
     */
    cursor?: PetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pets.
     */
    distinct?: PetScalarFieldEnum | PetScalarFieldEnum[]
  }

  /**
   * Pet findFirstOrThrow
   */
  export type PetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * Filter, which Pet to fetch.
     */
    where?: PetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pets to fetch.
     */
    orderBy?: PetOrderByWithRelationInput | PetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pets.
     */
    cursor?: PetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pets.
     */
    distinct?: PetScalarFieldEnum | PetScalarFieldEnum[]
  }

  /**
   * Pet findMany
   */
  export type PetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * Filter, which Pets to fetch.
     */
    where?: PetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pets to fetch.
     */
    orderBy?: PetOrderByWithRelationInput | PetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pets.
     */
    cursor?: PetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pets.
     */
    skip?: number
    distinct?: PetScalarFieldEnum | PetScalarFieldEnum[]
  }

  /**
   * Pet create
   */
  export type PetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * The data needed to create a Pet.
     */
    data: XOR<PetCreateInput, PetUncheckedCreateInput>
  }

  /**
   * Pet createMany
   */
  export type PetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pets.
     */
    data: PetCreateManyInput | PetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pet createManyAndReturn
   */
  export type PetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * The data used to create many Pets.
     */
    data: PetCreateManyInput | PetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pet update
   */
  export type PetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * The data needed to update a Pet.
     */
    data: XOR<PetUpdateInput, PetUncheckedUpdateInput>
    /**
     * Choose, which Pet to update.
     */
    where: PetWhereUniqueInput
  }

  /**
   * Pet updateMany
   */
  export type PetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pets.
     */
    data: XOR<PetUpdateManyMutationInput, PetUncheckedUpdateManyInput>
    /**
     * Filter which Pets to update
     */
    where?: PetWhereInput
    /**
     * Limit how many Pets to update.
     */
    limit?: number
  }

  /**
   * Pet updateManyAndReturn
   */
  export type PetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * The data used to update Pets.
     */
    data: XOR<PetUpdateManyMutationInput, PetUncheckedUpdateManyInput>
    /**
     * Filter which Pets to update
     */
    where?: PetWhereInput
    /**
     * Limit how many Pets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pet upsert
   */
  export type PetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * The filter to search for the Pet to update in case it exists.
     */
    where: PetWhereUniqueInput
    /**
     * In case the Pet found by the `where` argument doesn't exist, create a new Pet with this data.
     */
    create: XOR<PetCreateInput, PetUncheckedCreateInput>
    /**
     * In case the Pet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PetUpdateInput, PetUncheckedUpdateInput>
  }

  /**
   * Pet delete
   */
  export type PetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * Filter which Pet to delete.
     */
    where: PetWhereUniqueInput
  }

  /**
   * Pet deleteMany
   */
  export type PetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pets to delete
     */
    where?: PetWhereInput
    /**
     * Limit how many Pets to delete.
     */
    limit?: number
  }

  /**
   * Pet.medicalRecords
   */
  export type Pet$medicalRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    where?: MedicalRecordWhereInput
    orderBy?: MedicalRecordOrderByWithRelationInput | MedicalRecordOrderByWithRelationInput[]
    cursor?: MedicalRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalRecordScalarFieldEnum | MedicalRecordScalarFieldEnum[]
  }

  /**
   * Pet.notifications
   */
  export type Pet$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Pet.paymentEvents
   */
  export type Pet$paymentEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentEvent
     */
    omit?: PaymentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
    where?: PaymentEventWhereInput
    orderBy?: PaymentEventOrderByWithRelationInput | PaymentEventOrderByWithRelationInput[]
    cursor?: PaymentEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentEventScalarFieldEnum | PaymentEventScalarFieldEnum[]
  }

  /**
   * Pet.locationEvents
   */
  export type Pet$locationEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetLocationEvent
     */
    select?: PetLocationEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetLocationEvent
     */
    omit?: PetLocationEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetLocationEventInclude<ExtArgs> | null
    where?: PetLocationEventWhereInput
    orderBy?: PetLocationEventOrderByWithRelationInput | PetLocationEventOrderByWithRelationInput[]
    cursor?: PetLocationEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PetLocationEventScalarFieldEnum | PetLocationEventScalarFieldEnum[]
  }

  /**
   * Pet.qrScanEvents
   */
  export type Pet$qrScanEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRScanEvent
     */
    select?: QRScanEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRScanEvent
     */
    omit?: QRScanEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRScanEventInclude<ExtArgs> | null
    where?: QRScanEventWhereInput
    orderBy?: QRScanEventOrderByWithRelationInput | QRScanEventOrderByWithRelationInput[]
    cursor?: QRScanEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QRScanEventScalarFieldEnum | QRScanEventScalarFieldEnum[]
  }

  /**
   * Pet.pet_breeds_pets_breed_idTopet_breeds
   */
  export type Pet$pet_breeds_pets_breed_idTopet_breedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetBreed
     */
    select?: PetBreedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetBreed
     */
    omit?: PetBreedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetBreedInclude<ExtArgs> | null
    where?: PetBreedWhereInput
  }

  /**
   * Pet.registeredByUser
   */
  export type Pet$registeredByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Pet.pet_breeds_pets_secondary_breed_idTopet_breeds
   */
  export type Pet$pet_breeds_pets_secondary_breed_idTopet_breedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetBreed
     */
    select?: PetBreedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetBreed
     */
    omit?: PetBreedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetBreedInclude<ExtArgs> | null
    where?: PetBreedWhereInput
  }

  /**
   * Pet.species
   */
  export type Pet$speciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetSpecies
     */
    select?: PetSpeciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetSpecies
     */
    omit?: PetSpeciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetSpeciesInclude<ExtArgs> | null
    where?: PetSpeciesWhereInput
  }

  /**
   * Pet.qrCodes
   */
  export type Pet$qrCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
    where?: QRCodeWhereInput
    orderBy?: QRCodeOrderByWithRelationInput | QRCodeOrderByWithRelationInput[]
    cursor?: QRCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QRCodeScalarFieldEnum | QRCodeScalarFieldEnum[]
  }

  /**
   * Pet.supportTickets
   */
  export type Pet$supportTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * Pet.vaccinationRecords
   */
  export type Pet$vaccinationRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationRecord
     */
    select?: VaccinationRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationRecord
     */
    omit?: VaccinationRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationRecordInclude<ExtArgs> | null
    where?: VaccinationRecordWhereInput
    orderBy?: VaccinationRecordOrderByWithRelationInput | VaccinationRecordOrderByWithRelationInput[]
    cursor?: VaccinationRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VaccinationRecordScalarFieldEnum | VaccinationRecordScalarFieldEnum[]
  }

  /**
   * Pet without action
   */
  export type PetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
  }


  /**
   * Model VaccineType
   */

  export type AggregateVaccineType = {
    _count: VaccineTypeCountAggregateOutputType | null
    _avg: VaccineTypeAvgAggregateOutputType | null
    _sum: VaccineTypeSumAggregateOutputType | null
    _min: VaccineTypeMinAggregateOutputType | null
    _max: VaccineTypeMaxAggregateOutputType | null
  }

  export type VaccineTypeAvgAggregateOutputType = {
    id: number | null
    speciesApplicability: number | null
    durationMonths: number | null
  }

  export type VaccineTypeSumAggregateOutputType = {
    id: number | null
    speciesApplicability: number[]
    durationMonths: number | null
  }

  export type VaccineTypeMinAggregateOutputType = {
    id: number | null
    vaccineName: string | null
    durationMonths: number | null
    isRequiredByLaw: boolean | null
  }

  export type VaccineTypeMaxAggregateOutputType = {
    id: number | null
    vaccineName: string | null
    durationMonths: number | null
    isRequiredByLaw: boolean | null
  }

  export type VaccineTypeCountAggregateOutputType = {
    id: number
    vaccineName: number
    speciesApplicability: number
    durationMonths: number
    isRequiredByLaw: number
    _all: number
  }


  export type VaccineTypeAvgAggregateInputType = {
    id?: true
    speciesApplicability?: true
    durationMonths?: true
  }

  export type VaccineTypeSumAggregateInputType = {
    id?: true
    speciesApplicability?: true
    durationMonths?: true
  }

  export type VaccineTypeMinAggregateInputType = {
    id?: true
    vaccineName?: true
    durationMonths?: true
    isRequiredByLaw?: true
  }

  export type VaccineTypeMaxAggregateInputType = {
    id?: true
    vaccineName?: true
    durationMonths?: true
    isRequiredByLaw?: true
  }

  export type VaccineTypeCountAggregateInputType = {
    id?: true
    vaccineName?: true
    speciesApplicability?: true
    durationMonths?: true
    isRequiredByLaw?: true
    _all?: true
  }

  export type VaccineTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VaccineType to aggregate.
     */
    where?: VaccineTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccineTypes to fetch.
     */
    orderBy?: VaccineTypeOrderByWithRelationInput | VaccineTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VaccineTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccineTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccineTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VaccineTypes
    **/
    _count?: true | VaccineTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VaccineTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VaccineTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VaccineTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VaccineTypeMaxAggregateInputType
  }

  export type GetVaccineTypeAggregateType<T extends VaccineTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateVaccineType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVaccineType[P]>
      : GetScalarType<T[P], AggregateVaccineType[P]>
  }




  export type VaccineTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VaccineTypeWhereInput
    orderBy?: VaccineTypeOrderByWithAggregationInput | VaccineTypeOrderByWithAggregationInput[]
    by: VaccineTypeScalarFieldEnum[] | VaccineTypeScalarFieldEnum
    having?: VaccineTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VaccineTypeCountAggregateInputType | true
    _avg?: VaccineTypeAvgAggregateInputType
    _sum?: VaccineTypeSumAggregateInputType
    _min?: VaccineTypeMinAggregateInputType
    _max?: VaccineTypeMaxAggregateInputType
  }

  export type VaccineTypeGroupByOutputType = {
    id: number
    vaccineName: string
    speciesApplicability: number[]
    durationMonths: number | null
    isRequiredByLaw: boolean
    _count: VaccineTypeCountAggregateOutputType | null
    _avg: VaccineTypeAvgAggregateOutputType | null
    _sum: VaccineTypeSumAggregateOutputType | null
    _min: VaccineTypeMinAggregateOutputType | null
    _max: VaccineTypeMaxAggregateOutputType | null
  }

  type GetVaccineTypeGroupByPayload<T extends VaccineTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VaccineTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VaccineTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VaccineTypeGroupByOutputType[P]>
            : GetScalarType<T[P], VaccineTypeGroupByOutputType[P]>
        }
      >
    >


  export type VaccineTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vaccineName?: boolean
    speciesApplicability?: boolean
    durationMonths?: boolean
    isRequiredByLaw?: boolean
    vaccinationRecords?: boolean | VaccineType$vaccinationRecordsArgs<ExtArgs>
    _count?: boolean | VaccineTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vaccineType"]>

  export type VaccineTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vaccineName?: boolean
    speciesApplicability?: boolean
    durationMonths?: boolean
    isRequiredByLaw?: boolean
  }, ExtArgs["result"]["vaccineType"]>

  export type VaccineTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vaccineName?: boolean
    speciesApplicability?: boolean
    durationMonths?: boolean
    isRequiredByLaw?: boolean
  }, ExtArgs["result"]["vaccineType"]>

  export type VaccineTypeSelectScalar = {
    id?: boolean
    vaccineName?: boolean
    speciesApplicability?: boolean
    durationMonths?: boolean
    isRequiredByLaw?: boolean
  }

  export type VaccineTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vaccineName" | "speciesApplicability" | "durationMonths" | "isRequiredByLaw", ExtArgs["result"]["vaccineType"]>
  export type VaccineTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vaccinationRecords?: boolean | VaccineType$vaccinationRecordsArgs<ExtArgs>
    _count?: boolean | VaccineTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VaccineTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VaccineTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VaccineTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VaccineType"
    objects: {
      vaccinationRecords: Prisma.$VaccinationRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      vaccineName: string
      speciesApplicability: number[]
      durationMonths: number | null
      isRequiredByLaw: boolean
    }, ExtArgs["result"]["vaccineType"]>
    composites: {}
  }

  type VaccineTypeGetPayload<S extends boolean | null | undefined | VaccineTypeDefaultArgs> = $Result.GetResult<Prisma.$VaccineTypePayload, S>

  type VaccineTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VaccineTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VaccineTypeCountAggregateInputType | true
    }

  export interface VaccineTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VaccineType'], meta: { name: 'VaccineType' } }
    /**
     * Find zero or one VaccineType that matches the filter.
     * @param {VaccineTypeFindUniqueArgs} args - Arguments to find a VaccineType
     * @example
     * // Get one VaccineType
     * const vaccineType = await prisma.vaccineType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VaccineTypeFindUniqueArgs>(args: SelectSubset<T, VaccineTypeFindUniqueArgs<ExtArgs>>): Prisma__VaccineTypeClient<$Result.GetResult<Prisma.$VaccineTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VaccineType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VaccineTypeFindUniqueOrThrowArgs} args - Arguments to find a VaccineType
     * @example
     * // Get one VaccineType
     * const vaccineType = await prisma.vaccineType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VaccineTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, VaccineTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VaccineTypeClient<$Result.GetResult<Prisma.$VaccineTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VaccineType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineTypeFindFirstArgs} args - Arguments to find a VaccineType
     * @example
     * // Get one VaccineType
     * const vaccineType = await prisma.vaccineType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VaccineTypeFindFirstArgs>(args?: SelectSubset<T, VaccineTypeFindFirstArgs<ExtArgs>>): Prisma__VaccineTypeClient<$Result.GetResult<Prisma.$VaccineTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VaccineType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineTypeFindFirstOrThrowArgs} args - Arguments to find a VaccineType
     * @example
     * // Get one VaccineType
     * const vaccineType = await prisma.vaccineType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VaccineTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, VaccineTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__VaccineTypeClient<$Result.GetResult<Prisma.$VaccineTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VaccineTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VaccineTypes
     * const vaccineTypes = await prisma.vaccineType.findMany()
     * 
     * // Get first 10 VaccineTypes
     * const vaccineTypes = await prisma.vaccineType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vaccineTypeWithIdOnly = await prisma.vaccineType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VaccineTypeFindManyArgs>(args?: SelectSubset<T, VaccineTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccineTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VaccineType.
     * @param {VaccineTypeCreateArgs} args - Arguments to create a VaccineType.
     * @example
     * // Create one VaccineType
     * const VaccineType = await prisma.vaccineType.create({
     *   data: {
     *     // ... data to create a VaccineType
     *   }
     * })
     * 
     */
    create<T extends VaccineTypeCreateArgs>(args: SelectSubset<T, VaccineTypeCreateArgs<ExtArgs>>): Prisma__VaccineTypeClient<$Result.GetResult<Prisma.$VaccineTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VaccineTypes.
     * @param {VaccineTypeCreateManyArgs} args - Arguments to create many VaccineTypes.
     * @example
     * // Create many VaccineTypes
     * const vaccineType = await prisma.vaccineType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VaccineTypeCreateManyArgs>(args?: SelectSubset<T, VaccineTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VaccineTypes and returns the data saved in the database.
     * @param {VaccineTypeCreateManyAndReturnArgs} args - Arguments to create many VaccineTypes.
     * @example
     * // Create many VaccineTypes
     * const vaccineType = await prisma.vaccineType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VaccineTypes and only return the `id`
     * const vaccineTypeWithIdOnly = await prisma.vaccineType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VaccineTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, VaccineTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccineTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VaccineType.
     * @param {VaccineTypeDeleteArgs} args - Arguments to delete one VaccineType.
     * @example
     * // Delete one VaccineType
     * const VaccineType = await prisma.vaccineType.delete({
     *   where: {
     *     // ... filter to delete one VaccineType
     *   }
     * })
     * 
     */
    delete<T extends VaccineTypeDeleteArgs>(args: SelectSubset<T, VaccineTypeDeleteArgs<ExtArgs>>): Prisma__VaccineTypeClient<$Result.GetResult<Prisma.$VaccineTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VaccineType.
     * @param {VaccineTypeUpdateArgs} args - Arguments to update one VaccineType.
     * @example
     * // Update one VaccineType
     * const vaccineType = await prisma.vaccineType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VaccineTypeUpdateArgs>(args: SelectSubset<T, VaccineTypeUpdateArgs<ExtArgs>>): Prisma__VaccineTypeClient<$Result.GetResult<Prisma.$VaccineTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VaccineTypes.
     * @param {VaccineTypeDeleteManyArgs} args - Arguments to filter VaccineTypes to delete.
     * @example
     * // Delete a few VaccineTypes
     * const { count } = await prisma.vaccineType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VaccineTypeDeleteManyArgs>(args?: SelectSubset<T, VaccineTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VaccineTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VaccineTypes
     * const vaccineType = await prisma.vaccineType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VaccineTypeUpdateManyArgs>(args: SelectSubset<T, VaccineTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VaccineTypes and returns the data updated in the database.
     * @param {VaccineTypeUpdateManyAndReturnArgs} args - Arguments to update many VaccineTypes.
     * @example
     * // Update many VaccineTypes
     * const vaccineType = await prisma.vaccineType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VaccineTypes and only return the `id`
     * const vaccineTypeWithIdOnly = await prisma.vaccineType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VaccineTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, VaccineTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccineTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VaccineType.
     * @param {VaccineTypeUpsertArgs} args - Arguments to update or create a VaccineType.
     * @example
     * // Update or create a VaccineType
     * const vaccineType = await prisma.vaccineType.upsert({
     *   create: {
     *     // ... data to create a VaccineType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VaccineType we want to update
     *   }
     * })
     */
    upsert<T extends VaccineTypeUpsertArgs>(args: SelectSubset<T, VaccineTypeUpsertArgs<ExtArgs>>): Prisma__VaccineTypeClient<$Result.GetResult<Prisma.$VaccineTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VaccineTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineTypeCountArgs} args - Arguments to filter VaccineTypes to count.
     * @example
     * // Count the number of VaccineTypes
     * const count = await prisma.vaccineType.count({
     *   where: {
     *     // ... the filter for the VaccineTypes we want to count
     *   }
     * })
    **/
    count<T extends VaccineTypeCountArgs>(
      args?: Subset<T, VaccineTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VaccineTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VaccineType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VaccineTypeAggregateArgs>(args: Subset<T, VaccineTypeAggregateArgs>): Prisma.PrismaPromise<GetVaccineTypeAggregateType<T>>

    /**
     * Group by VaccineType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VaccineTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VaccineTypeGroupByArgs['orderBy'] }
        : { orderBy?: VaccineTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VaccineTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVaccineTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VaccineType model
   */
  readonly fields: VaccineTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VaccineType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VaccineTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vaccinationRecords<T extends VaccineType$vaccinationRecordsArgs<ExtArgs> = {}>(args?: Subset<T, VaccineType$vaccinationRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinationRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VaccineType model
   */
  interface VaccineTypeFieldRefs {
    readonly id: FieldRef<"VaccineType", 'Int'>
    readonly vaccineName: FieldRef<"VaccineType", 'String'>
    readonly speciesApplicability: FieldRef<"VaccineType", 'Int[]'>
    readonly durationMonths: FieldRef<"VaccineType", 'Int'>
    readonly isRequiredByLaw: FieldRef<"VaccineType", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * VaccineType findUnique
   */
  export type VaccineTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineType
     */
    select?: VaccineTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccineType
     */
    omit?: VaccineTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineTypeInclude<ExtArgs> | null
    /**
     * Filter, which VaccineType to fetch.
     */
    where: VaccineTypeWhereUniqueInput
  }

  /**
   * VaccineType findUniqueOrThrow
   */
  export type VaccineTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineType
     */
    select?: VaccineTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccineType
     */
    omit?: VaccineTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineTypeInclude<ExtArgs> | null
    /**
     * Filter, which VaccineType to fetch.
     */
    where: VaccineTypeWhereUniqueInput
  }

  /**
   * VaccineType findFirst
   */
  export type VaccineTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineType
     */
    select?: VaccineTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccineType
     */
    omit?: VaccineTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineTypeInclude<ExtArgs> | null
    /**
     * Filter, which VaccineType to fetch.
     */
    where?: VaccineTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccineTypes to fetch.
     */
    orderBy?: VaccineTypeOrderByWithRelationInput | VaccineTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VaccineTypes.
     */
    cursor?: VaccineTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccineTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccineTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VaccineTypes.
     */
    distinct?: VaccineTypeScalarFieldEnum | VaccineTypeScalarFieldEnum[]
  }

  /**
   * VaccineType findFirstOrThrow
   */
  export type VaccineTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineType
     */
    select?: VaccineTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccineType
     */
    omit?: VaccineTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineTypeInclude<ExtArgs> | null
    /**
     * Filter, which VaccineType to fetch.
     */
    where?: VaccineTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccineTypes to fetch.
     */
    orderBy?: VaccineTypeOrderByWithRelationInput | VaccineTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VaccineTypes.
     */
    cursor?: VaccineTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccineTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccineTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VaccineTypes.
     */
    distinct?: VaccineTypeScalarFieldEnum | VaccineTypeScalarFieldEnum[]
  }

  /**
   * VaccineType findMany
   */
  export type VaccineTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineType
     */
    select?: VaccineTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccineType
     */
    omit?: VaccineTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineTypeInclude<ExtArgs> | null
    /**
     * Filter, which VaccineTypes to fetch.
     */
    where?: VaccineTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccineTypes to fetch.
     */
    orderBy?: VaccineTypeOrderByWithRelationInput | VaccineTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VaccineTypes.
     */
    cursor?: VaccineTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccineTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccineTypes.
     */
    skip?: number
    distinct?: VaccineTypeScalarFieldEnum | VaccineTypeScalarFieldEnum[]
  }

  /**
   * VaccineType create
   */
  export type VaccineTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineType
     */
    select?: VaccineTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccineType
     */
    omit?: VaccineTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a VaccineType.
     */
    data: XOR<VaccineTypeCreateInput, VaccineTypeUncheckedCreateInput>
  }

  /**
   * VaccineType createMany
   */
  export type VaccineTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VaccineTypes.
     */
    data: VaccineTypeCreateManyInput | VaccineTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VaccineType createManyAndReturn
   */
  export type VaccineTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineType
     */
    select?: VaccineTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VaccineType
     */
    omit?: VaccineTypeOmit<ExtArgs> | null
    /**
     * The data used to create many VaccineTypes.
     */
    data: VaccineTypeCreateManyInput | VaccineTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VaccineType update
   */
  export type VaccineTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineType
     */
    select?: VaccineTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccineType
     */
    omit?: VaccineTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a VaccineType.
     */
    data: XOR<VaccineTypeUpdateInput, VaccineTypeUncheckedUpdateInput>
    /**
     * Choose, which VaccineType to update.
     */
    where: VaccineTypeWhereUniqueInput
  }

  /**
   * VaccineType updateMany
   */
  export type VaccineTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VaccineTypes.
     */
    data: XOR<VaccineTypeUpdateManyMutationInput, VaccineTypeUncheckedUpdateManyInput>
    /**
     * Filter which VaccineTypes to update
     */
    where?: VaccineTypeWhereInput
    /**
     * Limit how many VaccineTypes to update.
     */
    limit?: number
  }

  /**
   * VaccineType updateManyAndReturn
   */
  export type VaccineTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineType
     */
    select?: VaccineTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VaccineType
     */
    omit?: VaccineTypeOmit<ExtArgs> | null
    /**
     * The data used to update VaccineTypes.
     */
    data: XOR<VaccineTypeUpdateManyMutationInput, VaccineTypeUncheckedUpdateManyInput>
    /**
     * Filter which VaccineTypes to update
     */
    where?: VaccineTypeWhereInput
    /**
     * Limit how many VaccineTypes to update.
     */
    limit?: number
  }

  /**
   * VaccineType upsert
   */
  export type VaccineTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineType
     */
    select?: VaccineTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccineType
     */
    omit?: VaccineTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the VaccineType to update in case it exists.
     */
    where: VaccineTypeWhereUniqueInput
    /**
     * In case the VaccineType found by the `where` argument doesn't exist, create a new VaccineType with this data.
     */
    create: XOR<VaccineTypeCreateInput, VaccineTypeUncheckedCreateInput>
    /**
     * In case the VaccineType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VaccineTypeUpdateInput, VaccineTypeUncheckedUpdateInput>
  }

  /**
   * VaccineType delete
   */
  export type VaccineTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineType
     */
    select?: VaccineTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccineType
     */
    omit?: VaccineTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineTypeInclude<ExtArgs> | null
    /**
     * Filter which VaccineType to delete.
     */
    where: VaccineTypeWhereUniqueInput
  }

  /**
   * VaccineType deleteMany
   */
  export type VaccineTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VaccineTypes to delete
     */
    where?: VaccineTypeWhereInput
    /**
     * Limit how many VaccineTypes to delete.
     */
    limit?: number
  }

  /**
   * VaccineType.vaccinationRecords
   */
  export type VaccineType$vaccinationRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationRecord
     */
    select?: VaccinationRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationRecord
     */
    omit?: VaccinationRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationRecordInclude<ExtArgs> | null
    where?: VaccinationRecordWhereInput
    orderBy?: VaccinationRecordOrderByWithRelationInput | VaccinationRecordOrderByWithRelationInput[]
    cursor?: VaccinationRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VaccinationRecordScalarFieldEnum | VaccinationRecordScalarFieldEnum[]
  }

  /**
   * VaccineType without action
   */
  export type VaccineTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineType
     */
    select?: VaccineTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccineType
     */
    omit?: VaccineTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineTypeInclude<ExtArgs> | null
  }


  /**
   * Model VaccinationRecord
   */

  export type AggregateVaccinationRecord = {
    _count: VaccinationRecordCountAggregateOutputType | null
    _avg: VaccinationRecordAvgAggregateOutputType | null
    _sum: VaccinationRecordSumAggregateOutputType | null
    _min: VaccinationRecordMinAggregateOutputType | null
    _max: VaccinationRecordMaxAggregateOutputType | null
  }

  export type VaccinationRecordAvgAggregateOutputType = {
    vaccineTypeId: number | null
  }

  export type VaccinationRecordSumAggregateOutputType = {
    vaccineTypeId: number | null
  }

  export type VaccinationRecordMinAggregateOutputType = {
    id: string | null
    petId: string | null
    vaccineTypeId: number | null
    administeredDate: Date | null
    expirationDate: Date | null
    batchNumber: string | null
    veterinarianName: string | null
    clinicName: string | null
    notes: string | null
    certificateUrl: string | null
    createdAt: Date | null
  }

  export type VaccinationRecordMaxAggregateOutputType = {
    id: string | null
    petId: string | null
    vaccineTypeId: number | null
    administeredDate: Date | null
    expirationDate: Date | null
    batchNumber: string | null
    veterinarianName: string | null
    clinicName: string | null
    notes: string | null
    certificateUrl: string | null
    createdAt: Date | null
  }

  export type VaccinationRecordCountAggregateOutputType = {
    id: number
    petId: number
    vaccineTypeId: number
    administeredDate: number
    expirationDate: number
    batchNumber: number
    veterinarianName: number
    clinicName: number
    notes: number
    certificateUrl: number
    createdAt: number
    _all: number
  }


  export type VaccinationRecordAvgAggregateInputType = {
    vaccineTypeId?: true
  }

  export type VaccinationRecordSumAggregateInputType = {
    vaccineTypeId?: true
  }

  export type VaccinationRecordMinAggregateInputType = {
    id?: true
    petId?: true
    vaccineTypeId?: true
    administeredDate?: true
    expirationDate?: true
    batchNumber?: true
    veterinarianName?: true
    clinicName?: true
    notes?: true
    certificateUrl?: true
    createdAt?: true
  }

  export type VaccinationRecordMaxAggregateInputType = {
    id?: true
    petId?: true
    vaccineTypeId?: true
    administeredDate?: true
    expirationDate?: true
    batchNumber?: true
    veterinarianName?: true
    clinicName?: true
    notes?: true
    certificateUrl?: true
    createdAt?: true
  }

  export type VaccinationRecordCountAggregateInputType = {
    id?: true
    petId?: true
    vaccineTypeId?: true
    administeredDate?: true
    expirationDate?: true
    batchNumber?: true
    veterinarianName?: true
    clinicName?: true
    notes?: true
    certificateUrl?: true
    createdAt?: true
    _all?: true
  }

  export type VaccinationRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VaccinationRecord to aggregate.
     */
    where?: VaccinationRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccinationRecords to fetch.
     */
    orderBy?: VaccinationRecordOrderByWithRelationInput | VaccinationRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VaccinationRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccinationRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccinationRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VaccinationRecords
    **/
    _count?: true | VaccinationRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VaccinationRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VaccinationRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VaccinationRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VaccinationRecordMaxAggregateInputType
  }

  export type GetVaccinationRecordAggregateType<T extends VaccinationRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateVaccinationRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVaccinationRecord[P]>
      : GetScalarType<T[P], AggregateVaccinationRecord[P]>
  }




  export type VaccinationRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VaccinationRecordWhereInput
    orderBy?: VaccinationRecordOrderByWithAggregationInput | VaccinationRecordOrderByWithAggregationInput[]
    by: VaccinationRecordScalarFieldEnum[] | VaccinationRecordScalarFieldEnum
    having?: VaccinationRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VaccinationRecordCountAggregateInputType | true
    _avg?: VaccinationRecordAvgAggregateInputType
    _sum?: VaccinationRecordSumAggregateInputType
    _min?: VaccinationRecordMinAggregateInputType
    _max?: VaccinationRecordMaxAggregateInputType
  }

  export type VaccinationRecordGroupByOutputType = {
    id: string
    petId: string
    vaccineTypeId: number
    administeredDate: Date
    expirationDate: Date | null
    batchNumber: string | null
    veterinarianName: string | null
    clinicName: string | null
    notes: string | null
    certificateUrl: string | null
    createdAt: Date
    _count: VaccinationRecordCountAggregateOutputType | null
    _avg: VaccinationRecordAvgAggregateOutputType | null
    _sum: VaccinationRecordSumAggregateOutputType | null
    _min: VaccinationRecordMinAggregateOutputType | null
    _max: VaccinationRecordMaxAggregateOutputType | null
  }

  type GetVaccinationRecordGroupByPayload<T extends VaccinationRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VaccinationRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VaccinationRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VaccinationRecordGroupByOutputType[P]>
            : GetScalarType<T[P], VaccinationRecordGroupByOutputType[P]>
        }
      >
    >


  export type VaccinationRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    petId?: boolean
    vaccineTypeId?: boolean
    administeredDate?: boolean
    expirationDate?: boolean
    batchNumber?: boolean
    veterinarianName?: boolean
    clinicName?: boolean
    notes?: boolean
    certificateUrl?: boolean
    createdAt?: boolean
    pet?: boolean | PetDefaultArgs<ExtArgs>
    vaccineType?: boolean | VaccineTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vaccinationRecord"]>

  export type VaccinationRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    petId?: boolean
    vaccineTypeId?: boolean
    administeredDate?: boolean
    expirationDate?: boolean
    batchNumber?: boolean
    veterinarianName?: boolean
    clinicName?: boolean
    notes?: boolean
    certificateUrl?: boolean
    createdAt?: boolean
    pet?: boolean | PetDefaultArgs<ExtArgs>
    vaccineType?: boolean | VaccineTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vaccinationRecord"]>

  export type VaccinationRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    petId?: boolean
    vaccineTypeId?: boolean
    administeredDate?: boolean
    expirationDate?: boolean
    batchNumber?: boolean
    veterinarianName?: boolean
    clinicName?: boolean
    notes?: boolean
    certificateUrl?: boolean
    createdAt?: boolean
    pet?: boolean | PetDefaultArgs<ExtArgs>
    vaccineType?: boolean | VaccineTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vaccinationRecord"]>

  export type VaccinationRecordSelectScalar = {
    id?: boolean
    petId?: boolean
    vaccineTypeId?: boolean
    administeredDate?: boolean
    expirationDate?: boolean
    batchNumber?: boolean
    veterinarianName?: boolean
    clinicName?: boolean
    notes?: boolean
    certificateUrl?: boolean
    createdAt?: boolean
  }

  export type VaccinationRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "petId" | "vaccineTypeId" | "administeredDate" | "expirationDate" | "batchNumber" | "veterinarianName" | "clinicName" | "notes" | "certificateUrl" | "createdAt", ExtArgs["result"]["vaccinationRecord"]>
  export type VaccinationRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | PetDefaultArgs<ExtArgs>
    vaccineType?: boolean | VaccineTypeDefaultArgs<ExtArgs>
  }
  export type VaccinationRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | PetDefaultArgs<ExtArgs>
    vaccineType?: boolean | VaccineTypeDefaultArgs<ExtArgs>
  }
  export type VaccinationRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | PetDefaultArgs<ExtArgs>
    vaccineType?: boolean | VaccineTypeDefaultArgs<ExtArgs>
  }

  export type $VaccinationRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VaccinationRecord"
    objects: {
      pet: Prisma.$PetPayload<ExtArgs>
      vaccineType: Prisma.$VaccineTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      petId: string
      vaccineTypeId: number
      administeredDate: Date
      expirationDate: Date | null
      batchNumber: string | null
      veterinarianName: string | null
      clinicName: string | null
      notes: string | null
      certificateUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["vaccinationRecord"]>
    composites: {}
  }

  type VaccinationRecordGetPayload<S extends boolean | null | undefined | VaccinationRecordDefaultArgs> = $Result.GetResult<Prisma.$VaccinationRecordPayload, S>

  type VaccinationRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VaccinationRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VaccinationRecordCountAggregateInputType | true
    }

  export interface VaccinationRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VaccinationRecord'], meta: { name: 'VaccinationRecord' } }
    /**
     * Find zero or one VaccinationRecord that matches the filter.
     * @param {VaccinationRecordFindUniqueArgs} args - Arguments to find a VaccinationRecord
     * @example
     * // Get one VaccinationRecord
     * const vaccinationRecord = await prisma.vaccinationRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VaccinationRecordFindUniqueArgs>(args: SelectSubset<T, VaccinationRecordFindUniqueArgs<ExtArgs>>): Prisma__VaccinationRecordClient<$Result.GetResult<Prisma.$VaccinationRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VaccinationRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VaccinationRecordFindUniqueOrThrowArgs} args - Arguments to find a VaccinationRecord
     * @example
     * // Get one VaccinationRecord
     * const vaccinationRecord = await prisma.vaccinationRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VaccinationRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, VaccinationRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VaccinationRecordClient<$Result.GetResult<Prisma.$VaccinationRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VaccinationRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationRecordFindFirstArgs} args - Arguments to find a VaccinationRecord
     * @example
     * // Get one VaccinationRecord
     * const vaccinationRecord = await prisma.vaccinationRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VaccinationRecordFindFirstArgs>(args?: SelectSubset<T, VaccinationRecordFindFirstArgs<ExtArgs>>): Prisma__VaccinationRecordClient<$Result.GetResult<Prisma.$VaccinationRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VaccinationRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationRecordFindFirstOrThrowArgs} args - Arguments to find a VaccinationRecord
     * @example
     * // Get one VaccinationRecord
     * const vaccinationRecord = await prisma.vaccinationRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VaccinationRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, VaccinationRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__VaccinationRecordClient<$Result.GetResult<Prisma.$VaccinationRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VaccinationRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VaccinationRecords
     * const vaccinationRecords = await prisma.vaccinationRecord.findMany()
     * 
     * // Get first 10 VaccinationRecords
     * const vaccinationRecords = await prisma.vaccinationRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vaccinationRecordWithIdOnly = await prisma.vaccinationRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VaccinationRecordFindManyArgs>(args?: SelectSubset<T, VaccinationRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinationRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VaccinationRecord.
     * @param {VaccinationRecordCreateArgs} args - Arguments to create a VaccinationRecord.
     * @example
     * // Create one VaccinationRecord
     * const VaccinationRecord = await prisma.vaccinationRecord.create({
     *   data: {
     *     // ... data to create a VaccinationRecord
     *   }
     * })
     * 
     */
    create<T extends VaccinationRecordCreateArgs>(args: SelectSubset<T, VaccinationRecordCreateArgs<ExtArgs>>): Prisma__VaccinationRecordClient<$Result.GetResult<Prisma.$VaccinationRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VaccinationRecords.
     * @param {VaccinationRecordCreateManyArgs} args - Arguments to create many VaccinationRecords.
     * @example
     * // Create many VaccinationRecords
     * const vaccinationRecord = await prisma.vaccinationRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VaccinationRecordCreateManyArgs>(args?: SelectSubset<T, VaccinationRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VaccinationRecords and returns the data saved in the database.
     * @param {VaccinationRecordCreateManyAndReturnArgs} args - Arguments to create many VaccinationRecords.
     * @example
     * // Create many VaccinationRecords
     * const vaccinationRecord = await prisma.vaccinationRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VaccinationRecords and only return the `id`
     * const vaccinationRecordWithIdOnly = await prisma.vaccinationRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VaccinationRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, VaccinationRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinationRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VaccinationRecord.
     * @param {VaccinationRecordDeleteArgs} args - Arguments to delete one VaccinationRecord.
     * @example
     * // Delete one VaccinationRecord
     * const VaccinationRecord = await prisma.vaccinationRecord.delete({
     *   where: {
     *     // ... filter to delete one VaccinationRecord
     *   }
     * })
     * 
     */
    delete<T extends VaccinationRecordDeleteArgs>(args: SelectSubset<T, VaccinationRecordDeleteArgs<ExtArgs>>): Prisma__VaccinationRecordClient<$Result.GetResult<Prisma.$VaccinationRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VaccinationRecord.
     * @param {VaccinationRecordUpdateArgs} args - Arguments to update one VaccinationRecord.
     * @example
     * // Update one VaccinationRecord
     * const vaccinationRecord = await prisma.vaccinationRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VaccinationRecordUpdateArgs>(args: SelectSubset<T, VaccinationRecordUpdateArgs<ExtArgs>>): Prisma__VaccinationRecordClient<$Result.GetResult<Prisma.$VaccinationRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VaccinationRecords.
     * @param {VaccinationRecordDeleteManyArgs} args - Arguments to filter VaccinationRecords to delete.
     * @example
     * // Delete a few VaccinationRecords
     * const { count } = await prisma.vaccinationRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VaccinationRecordDeleteManyArgs>(args?: SelectSubset<T, VaccinationRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VaccinationRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VaccinationRecords
     * const vaccinationRecord = await prisma.vaccinationRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VaccinationRecordUpdateManyArgs>(args: SelectSubset<T, VaccinationRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VaccinationRecords and returns the data updated in the database.
     * @param {VaccinationRecordUpdateManyAndReturnArgs} args - Arguments to update many VaccinationRecords.
     * @example
     * // Update many VaccinationRecords
     * const vaccinationRecord = await prisma.vaccinationRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VaccinationRecords and only return the `id`
     * const vaccinationRecordWithIdOnly = await prisma.vaccinationRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VaccinationRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, VaccinationRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinationRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VaccinationRecord.
     * @param {VaccinationRecordUpsertArgs} args - Arguments to update or create a VaccinationRecord.
     * @example
     * // Update or create a VaccinationRecord
     * const vaccinationRecord = await prisma.vaccinationRecord.upsert({
     *   create: {
     *     // ... data to create a VaccinationRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VaccinationRecord we want to update
     *   }
     * })
     */
    upsert<T extends VaccinationRecordUpsertArgs>(args: SelectSubset<T, VaccinationRecordUpsertArgs<ExtArgs>>): Prisma__VaccinationRecordClient<$Result.GetResult<Prisma.$VaccinationRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VaccinationRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationRecordCountArgs} args - Arguments to filter VaccinationRecords to count.
     * @example
     * // Count the number of VaccinationRecords
     * const count = await prisma.vaccinationRecord.count({
     *   where: {
     *     // ... the filter for the VaccinationRecords we want to count
     *   }
     * })
    **/
    count<T extends VaccinationRecordCountArgs>(
      args?: Subset<T, VaccinationRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VaccinationRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VaccinationRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VaccinationRecordAggregateArgs>(args: Subset<T, VaccinationRecordAggregateArgs>): Prisma.PrismaPromise<GetVaccinationRecordAggregateType<T>>

    /**
     * Group by VaccinationRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VaccinationRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VaccinationRecordGroupByArgs['orderBy'] }
        : { orderBy?: VaccinationRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VaccinationRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVaccinationRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VaccinationRecord model
   */
  readonly fields: VaccinationRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VaccinationRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VaccinationRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pet<T extends PetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PetDefaultArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vaccineType<T extends VaccineTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VaccineTypeDefaultArgs<ExtArgs>>): Prisma__VaccineTypeClient<$Result.GetResult<Prisma.$VaccineTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VaccinationRecord model
   */
  interface VaccinationRecordFieldRefs {
    readonly id: FieldRef<"VaccinationRecord", 'String'>
    readonly petId: FieldRef<"VaccinationRecord", 'String'>
    readonly vaccineTypeId: FieldRef<"VaccinationRecord", 'Int'>
    readonly administeredDate: FieldRef<"VaccinationRecord", 'DateTime'>
    readonly expirationDate: FieldRef<"VaccinationRecord", 'DateTime'>
    readonly batchNumber: FieldRef<"VaccinationRecord", 'String'>
    readonly veterinarianName: FieldRef<"VaccinationRecord", 'String'>
    readonly clinicName: FieldRef<"VaccinationRecord", 'String'>
    readonly notes: FieldRef<"VaccinationRecord", 'String'>
    readonly certificateUrl: FieldRef<"VaccinationRecord", 'String'>
    readonly createdAt: FieldRef<"VaccinationRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VaccinationRecord findUnique
   */
  export type VaccinationRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationRecord
     */
    select?: VaccinationRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationRecord
     */
    omit?: VaccinationRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationRecordInclude<ExtArgs> | null
    /**
     * Filter, which VaccinationRecord to fetch.
     */
    where: VaccinationRecordWhereUniqueInput
  }

  /**
   * VaccinationRecord findUniqueOrThrow
   */
  export type VaccinationRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationRecord
     */
    select?: VaccinationRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationRecord
     */
    omit?: VaccinationRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationRecordInclude<ExtArgs> | null
    /**
     * Filter, which VaccinationRecord to fetch.
     */
    where: VaccinationRecordWhereUniqueInput
  }

  /**
   * VaccinationRecord findFirst
   */
  export type VaccinationRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationRecord
     */
    select?: VaccinationRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationRecord
     */
    omit?: VaccinationRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationRecordInclude<ExtArgs> | null
    /**
     * Filter, which VaccinationRecord to fetch.
     */
    where?: VaccinationRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccinationRecords to fetch.
     */
    orderBy?: VaccinationRecordOrderByWithRelationInput | VaccinationRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VaccinationRecords.
     */
    cursor?: VaccinationRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccinationRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccinationRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VaccinationRecords.
     */
    distinct?: VaccinationRecordScalarFieldEnum | VaccinationRecordScalarFieldEnum[]
  }

  /**
   * VaccinationRecord findFirstOrThrow
   */
  export type VaccinationRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationRecord
     */
    select?: VaccinationRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationRecord
     */
    omit?: VaccinationRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationRecordInclude<ExtArgs> | null
    /**
     * Filter, which VaccinationRecord to fetch.
     */
    where?: VaccinationRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccinationRecords to fetch.
     */
    orderBy?: VaccinationRecordOrderByWithRelationInput | VaccinationRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VaccinationRecords.
     */
    cursor?: VaccinationRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccinationRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccinationRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VaccinationRecords.
     */
    distinct?: VaccinationRecordScalarFieldEnum | VaccinationRecordScalarFieldEnum[]
  }

  /**
   * VaccinationRecord findMany
   */
  export type VaccinationRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationRecord
     */
    select?: VaccinationRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationRecord
     */
    omit?: VaccinationRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationRecordInclude<ExtArgs> | null
    /**
     * Filter, which VaccinationRecords to fetch.
     */
    where?: VaccinationRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccinationRecords to fetch.
     */
    orderBy?: VaccinationRecordOrderByWithRelationInput | VaccinationRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VaccinationRecords.
     */
    cursor?: VaccinationRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccinationRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccinationRecords.
     */
    skip?: number
    distinct?: VaccinationRecordScalarFieldEnum | VaccinationRecordScalarFieldEnum[]
  }

  /**
   * VaccinationRecord create
   */
  export type VaccinationRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationRecord
     */
    select?: VaccinationRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationRecord
     */
    omit?: VaccinationRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a VaccinationRecord.
     */
    data: XOR<VaccinationRecordCreateInput, VaccinationRecordUncheckedCreateInput>
  }

  /**
   * VaccinationRecord createMany
   */
  export type VaccinationRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VaccinationRecords.
     */
    data: VaccinationRecordCreateManyInput | VaccinationRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VaccinationRecord createManyAndReturn
   */
  export type VaccinationRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationRecord
     */
    select?: VaccinationRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationRecord
     */
    omit?: VaccinationRecordOmit<ExtArgs> | null
    /**
     * The data used to create many VaccinationRecords.
     */
    data: VaccinationRecordCreateManyInput | VaccinationRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VaccinationRecord update
   */
  export type VaccinationRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationRecord
     */
    select?: VaccinationRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationRecord
     */
    omit?: VaccinationRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a VaccinationRecord.
     */
    data: XOR<VaccinationRecordUpdateInput, VaccinationRecordUncheckedUpdateInput>
    /**
     * Choose, which VaccinationRecord to update.
     */
    where: VaccinationRecordWhereUniqueInput
  }

  /**
   * VaccinationRecord updateMany
   */
  export type VaccinationRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VaccinationRecords.
     */
    data: XOR<VaccinationRecordUpdateManyMutationInput, VaccinationRecordUncheckedUpdateManyInput>
    /**
     * Filter which VaccinationRecords to update
     */
    where?: VaccinationRecordWhereInput
    /**
     * Limit how many VaccinationRecords to update.
     */
    limit?: number
  }

  /**
   * VaccinationRecord updateManyAndReturn
   */
  export type VaccinationRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationRecord
     */
    select?: VaccinationRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationRecord
     */
    omit?: VaccinationRecordOmit<ExtArgs> | null
    /**
     * The data used to update VaccinationRecords.
     */
    data: XOR<VaccinationRecordUpdateManyMutationInput, VaccinationRecordUncheckedUpdateManyInput>
    /**
     * Filter which VaccinationRecords to update
     */
    where?: VaccinationRecordWhereInput
    /**
     * Limit how many VaccinationRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VaccinationRecord upsert
   */
  export type VaccinationRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationRecord
     */
    select?: VaccinationRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationRecord
     */
    omit?: VaccinationRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the VaccinationRecord to update in case it exists.
     */
    where: VaccinationRecordWhereUniqueInput
    /**
     * In case the VaccinationRecord found by the `where` argument doesn't exist, create a new VaccinationRecord with this data.
     */
    create: XOR<VaccinationRecordCreateInput, VaccinationRecordUncheckedCreateInput>
    /**
     * In case the VaccinationRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VaccinationRecordUpdateInput, VaccinationRecordUncheckedUpdateInput>
  }

  /**
   * VaccinationRecord delete
   */
  export type VaccinationRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationRecord
     */
    select?: VaccinationRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationRecord
     */
    omit?: VaccinationRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationRecordInclude<ExtArgs> | null
    /**
     * Filter which VaccinationRecord to delete.
     */
    where: VaccinationRecordWhereUniqueInput
  }

  /**
   * VaccinationRecord deleteMany
   */
  export type VaccinationRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VaccinationRecords to delete
     */
    where?: VaccinationRecordWhereInput
    /**
     * Limit how many VaccinationRecords to delete.
     */
    limit?: number
  }

  /**
   * VaccinationRecord without action
   */
  export type VaccinationRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationRecord
     */
    select?: VaccinationRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationRecord
     */
    omit?: VaccinationRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationRecordInclude<ExtArgs> | null
  }


  /**
   * Model MedicalRecord
   */

  export type AggregateMedicalRecord = {
    _count: MedicalRecordCountAggregateOutputType | null
    _avg: MedicalRecordAvgAggregateOutputType | null
    _sum: MedicalRecordSumAggregateOutputType | null
    _min: MedicalRecordMinAggregateOutputType | null
    _max: MedicalRecordMaxAggregateOutputType | null
  }

  export type MedicalRecordAvgAggregateOutputType = {
    cost: Decimal | null
  }

  export type MedicalRecordSumAggregateOutputType = {
    cost: Decimal | null
  }

  export type MedicalRecordMinAggregateOutputType = {
    id: string | null
    petId: string | null
    visitDate: Date | null
    veterinarianName: string | null
    clinicName: string | null
    diagnosis: string | null
    treatment: string | null
    followUpRequired: boolean | null
    followUpDate: Date | null
    cost: Decimal | null
    createdAt: Date | null
  }

  export type MedicalRecordMaxAggregateOutputType = {
    id: string | null
    petId: string | null
    visitDate: Date | null
    veterinarianName: string | null
    clinicName: string | null
    diagnosis: string | null
    treatment: string | null
    followUpRequired: boolean | null
    followUpDate: Date | null
    cost: Decimal | null
    createdAt: Date | null
  }

  export type MedicalRecordCountAggregateOutputType = {
    id: number
    petId: number
    visitDate: number
    veterinarianName: number
    clinicName: number
    diagnosis: number
    treatment: number
    medications: number
    followUpRequired: number
    followUpDate: number
    cost: number
    documentUrls: number
    createdAt: number
    _all: number
  }


  export type MedicalRecordAvgAggregateInputType = {
    cost?: true
  }

  export type MedicalRecordSumAggregateInputType = {
    cost?: true
  }

  export type MedicalRecordMinAggregateInputType = {
    id?: true
    petId?: true
    visitDate?: true
    veterinarianName?: true
    clinicName?: true
    diagnosis?: true
    treatment?: true
    followUpRequired?: true
    followUpDate?: true
    cost?: true
    createdAt?: true
  }

  export type MedicalRecordMaxAggregateInputType = {
    id?: true
    petId?: true
    visitDate?: true
    veterinarianName?: true
    clinicName?: true
    diagnosis?: true
    treatment?: true
    followUpRequired?: true
    followUpDate?: true
    cost?: true
    createdAt?: true
  }

  export type MedicalRecordCountAggregateInputType = {
    id?: true
    petId?: true
    visitDate?: true
    veterinarianName?: true
    clinicName?: true
    diagnosis?: true
    treatment?: true
    medications?: true
    followUpRequired?: true
    followUpDate?: true
    cost?: true
    documentUrls?: true
    createdAt?: true
    _all?: true
  }

  export type MedicalRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalRecord to aggregate.
     */
    where?: MedicalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalRecords to fetch.
     */
    orderBy?: MedicalRecordOrderByWithRelationInput | MedicalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalRecords
    **/
    _count?: true | MedicalRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicalRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicalRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalRecordMaxAggregateInputType
  }

  export type GetMedicalRecordAggregateType<T extends MedicalRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalRecord[P]>
      : GetScalarType<T[P], AggregateMedicalRecord[P]>
  }




  export type MedicalRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalRecordWhereInput
    orderBy?: MedicalRecordOrderByWithAggregationInput | MedicalRecordOrderByWithAggregationInput[]
    by: MedicalRecordScalarFieldEnum[] | MedicalRecordScalarFieldEnum
    having?: MedicalRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalRecordCountAggregateInputType | true
    _avg?: MedicalRecordAvgAggregateInputType
    _sum?: MedicalRecordSumAggregateInputType
    _min?: MedicalRecordMinAggregateInputType
    _max?: MedicalRecordMaxAggregateInputType
  }

  export type MedicalRecordGroupByOutputType = {
    id: string
    petId: string
    visitDate: Date
    veterinarianName: string | null
    clinicName: string | null
    diagnosis: string | null
    treatment: string | null
    medications: JsonValue | null
    followUpRequired: boolean
    followUpDate: Date | null
    cost: Decimal | null
    documentUrls: string[]
    createdAt: Date
    _count: MedicalRecordCountAggregateOutputType | null
    _avg: MedicalRecordAvgAggregateOutputType | null
    _sum: MedicalRecordSumAggregateOutputType | null
    _min: MedicalRecordMinAggregateOutputType | null
    _max: MedicalRecordMaxAggregateOutputType | null
  }

  type GetMedicalRecordGroupByPayload<T extends MedicalRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalRecordGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalRecordGroupByOutputType[P]>
        }
      >
    >


  export type MedicalRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    petId?: boolean
    visitDate?: boolean
    veterinarianName?: boolean
    clinicName?: boolean
    diagnosis?: boolean
    treatment?: boolean
    medications?: boolean
    followUpRequired?: boolean
    followUpDate?: boolean
    cost?: boolean
    documentUrls?: boolean
    createdAt?: boolean
    pet?: boolean | PetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalRecord"]>

  export type MedicalRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    petId?: boolean
    visitDate?: boolean
    veterinarianName?: boolean
    clinicName?: boolean
    diagnosis?: boolean
    treatment?: boolean
    medications?: boolean
    followUpRequired?: boolean
    followUpDate?: boolean
    cost?: boolean
    documentUrls?: boolean
    createdAt?: boolean
    pet?: boolean | PetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalRecord"]>

  export type MedicalRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    petId?: boolean
    visitDate?: boolean
    veterinarianName?: boolean
    clinicName?: boolean
    diagnosis?: boolean
    treatment?: boolean
    medications?: boolean
    followUpRequired?: boolean
    followUpDate?: boolean
    cost?: boolean
    documentUrls?: boolean
    createdAt?: boolean
    pet?: boolean | PetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalRecord"]>

  export type MedicalRecordSelectScalar = {
    id?: boolean
    petId?: boolean
    visitDate?: boolean
    veterinarianName?: boolean
    clinicName?: boolean
    diagnosis?: boolean
    treatment?: boolean
    medications?: boolean
    followUpRequired?: boolean
    followUpDate?: boolean
    cost?: boolean
    documentUrls?: boolean
    createdAt?: boolean
  }

  export type MedicalRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "petId" | "visitDate" | "veterinarianName" | "clinicName" | "diagnosis" | "treatment" | "medications" | "followUpRequired" | "followUpDate" | "cost" | "documentUrls" | "createdAt", ExtArgs["result"]["medicalRecord"]>
  export type MedicalRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | PetDefaultArgs<ExtArgs>
  }
  export type MedicalRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | PetDefaultArgs<ExtArgs>
  }
  export type MedicalRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | PetDefaultArgs<ExtArgs>
  }

  export type $MedicalRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalRecord"
    objects: {
      pet: Prisma.$PetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      petId: string
      visitDate: Date
      veterinarianName: string | null
      clinicName: string | null
      diagnosis: string | null
      treatment: string | null
      medications: Prisma.JsonValue | null
      followUpRequired: boolean
      followUpDate: Date | null
      cost: Prisma.Decimal | null
      documentUrls: string[]
      createdAt: Date
    }, ExtArgs["result"]["medicalRecord"]>
    composites: {}
  }

  type MedicalRecordGetPayload<S extends boolean | null | undefined | MedicalRecordDefaultArgs> = $Result.GetResult<Prisma.$MedicalRecordPayload, S>

  type MedicalRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicalRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicalRecordCountAggregateInputType | true
    }

  export interface MedicalRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalRecord'], meta: { name: 'MedicalRecord' } }
    /**
     * Find zero or one MedicalRecord that matches the filter.
     * @param {MedicalRecordFindUniqueArgs} args - Arguments to find a MedicalRecord
     * @example
     * // Get one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicalRecordFindUniqueArgs>(args: SelectSubset<T, MedicalRecordFindUniqueArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicalRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicalRecordFindUniqueOrThrowArgs} args - Arguments to find a MedicalRecord
     * @example
     * // Get one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicalRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicalRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordFindFirstArgs} args - Arguments to find a MedicalRecord
     * @example
     * // Get one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicalRecordFindFirstArgs>(args?: SelectSubset<T, MedicalRecordFindFirstArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordFindFirstOrThrowArgs} args - Arguments to find a MedicalRecord
     * @example
     * // Get one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicalRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicalRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicalRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalRecords
     * const medicalRecords = await prisma.medicalRecord.findMany()
     * 
     * // Get first 10 MedicalRecords
     * const medicalRecords = await prisma.medicalRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalRecordWithIdOnly = await prisma.medicalRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicalRecordFindManyArgs>(args?: SelectSubset<T, MedicalRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicalRecord.
     * @param {MedicalRecordCreateArgs} args - Arguments to create a MedicalRecord.
     * @example
     * // Create one MedicalRecord
     * const MedicalRecord = await prisma.medicalRecord.create({
     *   data: {
     *     // ... data to create a MedicalRecord
     *   }
     * })
     * 
     */
    create<T extends MedicalRecordCreateArgs>(args: SelectSubset<T, MedicalRecordCreateArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicalRecords.
     * @param {MedicalRecordCreateManyArgs} args - Arguments to create many MedicalRecords.
     * @example
     * // Create many MedicalRecords
     * const medicalRecord = await prisma.medicalRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicalRecordCreateManyArgs>(args?: SelectSubset<T, MedicalRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicalRecords and returns the data saved in the database.
     * @param {MedicalRecordCreateManyAndReturnArgs} args - Arguments to create many MedicalRecords.
     * @example
     * // Create many MedicalRecords
     * const medicalRecord = await prisma.medicalRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicalRecords and only return the `id`
     * const medicalRecordWithIdOnly = await prisma.medicalRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicalRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicalRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MedicalRecord.
     * @param {MedicalRecordDeleteArgs} args - Arguments to delete one MedicalRecord.
     * @example
     * // Delete one MedicalRecord
     * const MedicalRecord = await prisma.medicalRecord.delete({
     *   where: {
     *     // ... filter to delete one MedicalRecord
     *   }
     * })
     * 
     */
    delete<T extends MedicalRecordDeleteArgs>(args: SelectSubset<T, MedicalRecordDeleteArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicalRecord.
     * @param {MedicalRecordUpdateArgs} args - Arguments to update one MedicalRecord.
     * @example
     * // Update one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicalRecordUpdateArgs>(args: SelectSubset<T, MedicalRecordUpdateArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicalRecords.
     * @param {MedicalRecordDeleteManyArgs} args - Arguments to filter MedicalRecords to delete.
     * @example
     * // Delete a few MedicalRecords
     * const { count } = await prisma.medicalRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicalRecordDeleteManyArgs>(args?: SelectSubset<T, MedicalRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalRecords
     * const medicalRecord = await prisma.medicalRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicalRecordUpdateManyArgs>(args: SelectSubset<T, MedicalRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalRecords and returns the data updated in the database.
     * @param {MedicalRecordUpdateManyAndReturnArgs} args - Arguments to update many MedicalRecords.
     * @example
     * // Update many MedicalRecords
     * const medicalRecord = await prisma.medicalRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicalRecords and only return the `id`
     * const medicalRecordWithIdOnly = await prisma.medicalRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicalRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicalRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MedicalRecord.
     * @param {MedicalRecordUpsertArgs} args - Arguments to update or create a MedicalRecord.
     * @example
     * // Update or create a MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.upsert({
     *   create: {
     *     // ... data to create a MedicalRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalRecord we want to update
     *   }
     * })
     */
    upsert<T extends MedicalRecordUpsertArgs>(args: SelectSubset<T, MedicalRecordUpsertArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicalRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordCountArgs} args - Arguments to filter MedicalRecords to count.
     * @example
     * // Count the number of MedicalRecords
     * const count = await prisma.medicalRecord.count({
     *   where: {
     *     // ... the filter for the MedicalRecords we want to count
     *   }
     * })
    **/
    count<T extends MedicalRecordCountArgs>(
      args?: Subset<T, MedicalRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalRecordAggregateArgs>(args: Subset<T, MedicalRecordAggregateArgs>): Prisma.PrismaPromise<GetMedicalRecordAggregateType<T>>

    /**
     * Group by MedicalRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalRecordGroupByArgs['orderBy'] }
        : { orderBy?: MedicalRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalRecord model
   */
  readonly fields: MedicalRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pet<T extends PetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PetDefaultArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicalRecord model
   */
  interface MedicalRecordFieldRefs {
    readonly id: FieldRef<"MedicalRecord", 'String'>
    readonly petId: FieldRef<"MedicalRecord", 'String'>
    readonly visitDate: FieldRef<"MedicalRecord", 'DateTime'>
    readonly veterinarianName: FieldRef<"MedicalRecord", 'String'>
    readonly clinicName: FieldRef<"MedicalRecord", 'String'>
    readonly diagnosis: FieldRef<"MedicalRecord", 'String'>
    readonly treatment: FieldRef<"MedicalRecord", 'String'>
    readonly medications: FieldRef<"MedicalRecord", 'Json'>
    readonly followUpRequired: FieldRef<"MedicalRecord", 'Boolean'>
    readonly followUpDate: FieldRef<"MedicalRecord", 'DateTime'>
    readonly cost: FieldRef<"MedicalRecord", 'Decimal'>
    readonly documentUrls: FieldRef<"MedicalRecord", 'String[]'>
    readonly createdAt: FieldRef<"MedicalRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicalRecord findUnique
   */
  export type MedicalRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecord to fetch.
     */
    where: MedicalRecordWhereUniqueInput
  }

  /**
   * MedicalRecord findUniqueOrThrow
   */
  export type MedicalRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecord to fetch.
     */
    where: MedicalRecordWhereUniqueInput
  }

  /**
   * MedicalRecord findFirst
   */
  export type MedicalRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecord to fetch.
     */
    where?: MedicalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalRecords to fetch.
     */
    orderBy?: MedicalRecordOrderByWithRelationInput | MedicalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalRecords.
     */
    cursor?: MedicalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalRecords.
     */
    distinct?: MedicalRecordScalarFieldEnum | MedicalRecordScalarFieldEnum[]
  }

  /**
   * MedicalRecord findFirstOrThrow
   */
  export type MedicalRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecord to fetch.
     */
    where?: MedicalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalRecords to fetch.
     */
    orderBy?: MedicalRecordOrderByWithRelationInput | MedicalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalRecords.
     */
    cursor?: MedicalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalRecords.
     */
    distinct?: MedicalRecordScalarFieldEnum | MedicalRecordScalarFieldEnum[]
  }

  /**
   * MedicalRecord findMany
   */
  export type MedicalRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecords to fetch.
     */
    where?: MedicalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalRecords to fetch.
     */
    orderBy?: MedicalRecordOrderByWithRelationInput | MedicalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalRecords.
     */
    cursor?: MedicalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalRecords.
     */
    skip?: number
    distinct?: MedicalRecordScalarFieldEnum | MedicalRecordScalarFieldEnum[]
  }

  /**
   * MedicalRecord create
   */
  export type MedicalRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalRecord.
     */
    data: XOR<MedicalRecordCreateInput, MedicalRecordUncheckedCreateInput>
  }

  /**
   * MedicalRecord createMany
   */
  export type MedicalRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalRecords.
     */
    data: MedicalRecordCreateManyInput | MedicalRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicalRecord createManyAndReturn
   */
  export type MedicalRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * The data used to create many MedicalRecords.
     */
    data: MedicalRecordCreateManyInput | MedicalRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicalRecord update
   */
  export type MedicalRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalRecord.
     */
    data: XOR<MedicalRecordUpdateInput, MedicalRecordUncheckedUpdateInput>
    /**
     * Choose, which MedicalRecord to update.
     */
    where: MedicalRecordWhereUniqueInput
  }

  /**
   * MedicalRecord updateMany
   */
  export type MedicalRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalRecords.
     */
    data: XOR<MedicalRecordUpdateManyMutationInput, MedicalRecordUncheckedUpdateManyInput>
    /**
     * Filter which MedicalRecords to update
     */
    where?: MedicalRecordWhereInput
    /**
     * Limit how many MedicalRecords to update.
     */
    limit?: number
  }

  /**
   * MedicalRecord updateManyAndReturn
   */
  export type MedicalRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * The data used to update MedicalRecords.
     */
    data: XOR<MedicalRecordUpdateManyMutationInput, MedicalRecordUncheckedUpdateManyInput>
    /**
     * Filter which MedicalRecords to update
     */
    where?: MedicalRecordWhereInput
    /**
     * Limit how many MedicalRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicalRecord upsert
   */
  export type MedicalRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalRecord to update in case it exists.
     */
    where: MedicalRecordWhereUniqueInput
    /**
     * In case the MedicalRecord found by the `where` argument doesn't exist, create a new MedicalRecord with this data.
     */
    create: XOR<MedicalRecordCreateInput, MedicalRecordUncheckedCreateInput>
    /**
     * In case the MedicalRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalRecordUpdateInput, MedicalRecordUncheckedUpdateInput>
  }

  /**
   * MedicalRecord delete
   */
  export type MedicalRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter which MedicalRecord to delete.
     */
    where: MedicalRecordWhereUniqueInput
  }

  /**
   * MedicalRecord deleteMany
   */
  export type MedicalRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalRecords to delete
     */
    where?: MedicalRecordWhereInput
    /**
     * Limit how many MedicalRecords to delete.
     */
    limit?: number
  }

  /**
   * MedicalRecord without action
   */
  export type MedicalRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
  }


  /**
   * Model QRCodePool
   */

  export type AggregateQRCodePool = {
    _count: QRCodePoolCountAggregateOutputType | null
    _avg: QRCodePoolAvgAggregateOutputType | null
    _sum: QRCodePoolSumAggregateOutputType | null
    _min: QRCodePoolMinAggregateOutputType | null
    _max: QRCodePoolMaxAggregateOutputType | null
  }

  export type QRCodePoolAvgAggregateOutputType = {
    totalCapacity: number | null
    usedCount: number | null
  }

  export type QRCodePoolSumAggregateOutputType = {
    totalCapacity: number | null
    usedCount: number | null
  }

  export type QRCodePoolMinAggregateOutputType = {
    id: string | null
    poolName: string | null
    totalCapacity: number | null
    usedCount: number | null
    createdAt: Date | null
    status: $Enums.PoolStatus | null
  }

  export type QRCodePoolMaxAggregateOutputType = {
    id: string | null
    poolName: string | null
    totalCapacity: number | null
    usedCount: number | null
    createdAt: Date | null
    status: $Enums.PoolStatus | null
  }

  export type QRCodePoolCountAggregateOutputType = {
    id: number
    poolName: number
    totalCapacity: number
    usedCount: number
    createdAt: number
    status: number
    _all: number
  }


  export type QRCodePoolAvgAggregateInputType = {
    totalCapacity?: true
    usedCount?: true
  }

  export type QRCodePoolSumAggregateInputType = {
    totalCapacity?: true
    usedCount?: true
  }

  export type QRCodePoolMinAggregateInputType = {
    id?: true
    poolName?: true
    totalCapacity?: true
    usedCount?: true
    createdAt?: true
    status?: true
  }

  export type QRCodePoolMaxAggregateInputType = {
    id?: true
    poolName?: true
    totalCapacity?: true
    usedCount?: true
    createdAt?: true
    status?: true
  }

  export type QRCodePoolCountAggregateInputType = {
    id?: true
    poolName?: true
    totalCapacity?: true
    usedCount?: true
    createdAt?: true
    status?: true
    _all?: true
  }

  export type QRCodePoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRCodePool to aggregate.
     */
    where?: QRCodePoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRCodePools to fetch.
     */
    orderBy?: QRCodePoolOrderByWithRelationInput | QRCodePoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QRCodePoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRCodePools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRCodePools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QRCodePools
    **/
    _count?: true | QRCodePoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QRCodePoolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QRCodePoolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QRCodePoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QRCodePoolMaxAggregateInputType
  }

  export type GetQRCodePoolAggregateType<T extends QRCodePoolAggregateArgs> = {
        [P in keyof T & keyof AggregateQRCodePool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQRCodePool[P]>
      : GetScalarType<T[P], AggregateQRCodePool[P]>
  }




  export type QRCodePoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QRCodePoolWhereInput
    orderBy?: QRCodePoolOrderByWithAggregationInput | QRCodePoolOrderByWithAggregationInput[]
    by: QRCodePoolScalarFieldEnum[] | QRCodePoolScalarFieldEnum
    having?: QRCodePoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QRCodePoolCountAggregateInputType | true
    _avg?: QRCodePoolAvgAggregateInputType
    _sum?: QRCodePoolSumAggregateInputType
    _min?: QRCodePoolMinAggregateInputType
    _max?: QRCodePoolMaxAggregateInputType
  }

  export type QRCodePoolGroupByOutputType = {
    id: string
    poolName: string
    totalCapacity: number
    usedCount: number
    createdAt: Date
    status: $Enums.PoolStatus
    _count: QRCodePoolCountAggregateOutputType | null
    _avg: QRCodePoolAvgAggregateOutputType | null
    _sum: QRCodePoolSumAggregateOutputType | null
    _min: QRCodePoolMinAggregateOutputType | null
    _max: QRCodePoolMaxAggregateOutputType | null
  }

  type GetQRCodePoolGroupByPayload<T extends QRCodePoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QRCodePoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QRCodePoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QRCodePoolGroupByOutputType[P]>
            : GetScalarType<T[P], QRCodePoolGroupByOutputType[P]>
        }
      >
    >


  export type QRCodePoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poolName?: boolean
    totalCapacity?: boolean
    usedCount?: boolean
    createdAt?: boolean
    status?: boolean
    qrCodes?: boolean | QRCodePool$qrCodesArgs<ExtArgs>
    _count?: boolean | QRCodePoolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qRCodePool"]>

  export type QRCodePoolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poolName?: boolean
    totalCapacity?: boolean
    usedCount?: boolean
    createdAt?: boolean
    status?: boolean
  }, ExtArgs["result"]["qRCodePool"]>

  export type QRCodePoolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poolName?: boolean
    totalCapacity?: boolean
    usedCount?: boolean
    createdAt?: boolean
    status?: boolean
  }, ExtArgs["result"]["qRCodePool"]>

  export type QRCodePoolSelectScalar = {
    id?: boolean
    poolName?: boolean
    totalCapacity?: boolean
    usedCount?: boolean
    createdAt?: boolean
    status?: boolean
  }

  export type QRCodePoolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "poolName" | "totalCapacity" | "usedCount" | "createdAt" | "status", ExtArgs["result"]["qRCodePool"]>
  export type QRCodePoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qrCodes?: boolean | QRCodePool$qrCodesArgs<ExtArgs>
    _count?: boolean | QRCodePoolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QRCodePoolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type QRCodePoolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $QRCodePoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QRCodePool"
    objects: {
      qrCodes: Prisma.$QRCodePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      poolName: string
      totalCapacity: number
      usedCount: number
      createdAt: Date
      status: $Enums.PoolStatus
    }, ExtArgs["result"]["qRCodePool"]>
    composites: {}
  }

  type QRCodePoolGetPayload<S extends boolean | null | undefined | QRCodePoolDefaultArgs> = $Result.GetResult<Prisma.$QRCodePoolPayload, S>

  type QRCodePoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QRCodePoolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QRCodePoolCountAggregateInputType | true
    }

  export interface QRCodePoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QRCodePool'], meta: { name: 'QRCodePool' } }
    /**
     * Find zero or one QRCodePool that matches the filter.
     * @param {QRCodePoolFindUniqueArgs} args - Arguments to find a QRCodePool
     * @example
     * // Get one QRCodePool
     * const qRCodePool = await prisma.qRCodePool.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QRCodePoolFindUniqueArgs>(args: SelectSubset<T, QRCodePoolFindUniqueArgs<ExtArgs>>): Prisma__QRCodePoolClient<$Result.GetResult<Prisma.$QRCodePoolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QRCodePool that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QRCodePoolFindUniqueOrThrowArgs} args - Arguments to find a QRCodePool
     * @example
     * // Get one QRCodePool
     * const qRCodePool = await prisma.qRCodePool.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QRCodePoolFindUniqueOrThrowArgs>(args: SelectSubset<T, QRCodePoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QRCodePoolClient<$Result.GetResult<Prisma.$QRCodePoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRCodePool that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRCodePoolFindFirstArgs} args - Arguments to find a QRCodePool
     * @example
     * // Get one QRCodePool
     * const qRCodePool = await prisma.qRCodePool.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QRCodePoolFindFirstArgs>(args?: SelectSubset<T, QRCodePoolFindFirstArgs<ExtArgs>>): Prisma__QRCodePoolClient<$Result.GetResult<Prisma.$QRCodePoolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRCodePool that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRCodePoolFindFirstOrThrowArgs} args - Arguments to find a QRCodePool
     * @example
     * // Get one QRCodePool
     * const qRCodePool = await prisma.qRCodePool.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QRCodePoolFindFirstOrThrowArgs>(args?: SelectSubset<T, QRCodePoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__QRCodePoolClient<$Result.GetResult<Prisma.$QRCodePoolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QRCodePools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRCodePoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QRCodePools
     * const qRCodePools = await prisma.qRCodePool.findMany()
     * 
     * // Get first 10 QRCodePools
     * const qRCodePools = await prisma.qRCodePool.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qRCodePoolWithIdOnly = await prisma.qRCodePool.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QRCodePoolFindManyArgs>(args?: SelectSubset<T, QRCodePoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRCodePoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QRCodePool.
     * @param {QRCodePoolCreateArgs} args - Arguments to create a QRCodePool.
     * @example
     * // Create one QRCodePool
     * const QRCodePool = await prisma.qRCodePool.create({
     *   data: {
     *     // ... data to create a QRCodePool
     *   }
     * })
     * 
     */
    create<T extends QRCodePoolCreateArgs>(args: SelectSubset<T, QRCodePoolCreateArgs<ExtArgs>>): Prisma__QRCodePoolClient<$Result.GetResult<Prisma.$QRCodePoolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QRCodePools.
     * @param {QRCodePoolCreateManyArgs} args - Arguments to create many QRCodePools.
     * @example
     * // Create many QRCodePools
     * const qRCodePool = await prisma.qRCodePool.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QRCodePoolCreateManyArgs>(args?: SelectSubset<T, QRCodePoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QRCodePools and returns the data saved in the database.
     * @param {QRCodePoolCreateManyAndReturnArgs} args - Arguments to create many QRCodePools.
     * @example
     * // Create many QRCodePools
     * const qRCodePool = await prisma.qRCodePool.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QRCodePools and only return the `id`
     * const qRCodePoolWithIdOnly = await prisma.qRCodePool.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QRCodePoolCreateManyAndReturnArgs>(args?: SelectSubset<T, QRCodePoolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRCodePoolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QRCodePool.
     * @param {QRCodePoolDeleteArgs} args - Arguments to delete one QRCodePool.
     * @example
     * // Delete one QRCodePool
     * const QRCodePool = await prisma.qRCodePool.delete({
     *   where: {
     *     // ... filter to delete one QRCodePool
     *   }
     * })
     * 
     */
    delete<T extends QRCodePoolDeleteArgs>(args: SelectSubset<T, QRCodePoolDeleteArgs<ExtArgs>>): Prisma__QRCodePoolClient<$Result.GetResult<Prisma.$QRCodePoolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QRCodePool.
     * @param {QRCodePoolUpdateArgs} args - Arguments to update one QRCodePool.
     * @example
     * // Update one QRCodePool
     * const qRCodePool = await prisma.qRCodePool.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QRCodePoolUpdateArgs>(args: SelectSubset<T, QRCodePoolUpdateArgs<ExtArgs>>): Prisma__QRCodePoolClient<$Result.GetResult<Prisma.$QRCodePoolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QRCodePools.
     * @param {QRCodePoolDeleteManyArgs} args - Arguments to filter QRCodePools to delete.
     * @example
     * // Delete a few QRCodePools
     * const { count } = await prisma.qRCodePool.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QRCodePoolDeleteManyArgs>(args?: SelectSubset<T, QRCodePoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QRCodePools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRCodePoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QRCodePools
     * const qRCodePool = await prisma.qRCodePool.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QRCodePoolUpdateManyArgs>(args: SelectSubset<T, QRCodePoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QRCodePools and returns the data updated in the database.
     * @param {QRCodePoolUpdateManyAndReturnArgs} args - Arguments to update many QRCodePools.
     * @example
     * // Update many QRCodePools
     * const qRCodePool = await prisma.qRCodePool.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QRCodePools and only return the `id`
     * const qRCodePoolWithIdOnly = await prisma.qRCodePool.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QRCodePoolUpdateManyAndReturnArgs>(args: SelectSubset<T, QRCodePoolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRCodePoolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QRCodePool.
     * @param {QRCodePoolUpsertArgs} args - Arguments to update or create a QRCodePool.
     * @example
     * // Update or create a QRCodePool
     * const qRCodePool = await prisma.qRCodePool.upsert({
     *   create: {
     *     // ... data to create a QRCodePool
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QRCodePool we want to update
     *   }
     * })
     */
    upsert<T extends QRCodePoolUpsertArgs>(args: SelectSubset<T, QRCodePoolUpsertArgs<ExtArgs>>): Prisma__QRCodePoolClient<$Result.GetResult<Prisma.$QRCodePoolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QRCodePools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRCodePoolCountArgs} args - Arguments to filter QRCodePools to count.
     * @example
     * // Count the number of QRCodePools
     * const count = await prisma.qRCodePool.count({
     *   where: {
     *     // ... the filter for the QRCodePools we want to count
     *   }
     * })
    **/
    count<T extends QRCodePoolCountArgs>(
      args?: Subset<T, QRCodePoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QRCodePoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QRCodePool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRCodePoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QRCodePoolAggregateArgs>(args: Subset<T, QRCodePoolAggregateArgs>): Prisma.PrismaPromise<GetQRCodePoolAggregateType<T>>

    /**
     * Group by QRCodePool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRCodePoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QRCodePoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QRCodePoolGroupByArgs['orderBy'] }
        : { orderBy?: QRCodePoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QRCodePoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQRCodePoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QRCodePool model
   */
  readonly fields: QRCodePoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QRCodePool.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QRCodePoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    qrCodes<T extends QRCodePool$qrCodesArgs<ExtArgs> = {}>(args?: Subset<T, QRCodePool$qrCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QRCodePool model
   */
  interface QRCodePoolFieldRefs {
    readonly id: FieldRef<"QRCodePool", 'String'>
    readonly poolName: FieldRef<"QRCodePool", 'String'>
    readonly totalCapacity: FieldRef<"QRCodePool", 'Int'>
    readonly usedCount: FieldRef<"QRCodePool", 'Int'>
    readonly createdAt: FieldRef<"QRCodePool", 'DateTime'>
    readonly status: FieldRef<"QRCodePool", 'PoolStatus'>
  }
    

  // Custom InputTypes
  /**
   * QRCodePool findUnique
   */
  export type QRCodePoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCodePool
     */
    select?: QRCodePoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCodePool
     */
    omit?: QRCodePoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodePoolInclude<ExtArgs> | null
    /**
     * Filter, which QRCodePool to fetch.
     */
    where: QRCodePoolWhereUniqueInput
  }

  /**
   * QRCodePool findUniqueOrThrow
   */
  export type QRCodePoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCodePool
     */
    select?: QRCodePoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCodePool
     */
    omit?: QRCodePoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodePoolInclude<ExtArgs> | null
    /**
     * Filter, which QRCodePool to fetch.
     */
    where: QRCodePoolWhereUniqueInput
  }

  /**
   * QRCodePool findFirst
   */
  export type QRCodePoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCodePool
     */
    select?: QRCodePoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCodePool
     */
    omit?: QRCodePoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodePoolInclude<ExtArgs> | null
    /**
     * Filter, which QRCodePool to fetch.
     */
    where?: QRCodePoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRCodePools to fetch.
     */
    orderBy?: QRCodePoolOrderByWithRelationInput | QRCodePoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRCodePools.
     */
    cursor?: QRCodePoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRCodePools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRCodePools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRCodePools.
     */
    distinct?: QRCodePoolScalarFieldEnum | QRCodePoolScalarFieldEnum[]
  }

  /**
   * QRCodePool findFirstOrThrow
   */
  export type QRCodePoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCodePool
     */
    select?: QRCodePoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCodePool
     */
    omit?: QRCodePoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodePoolInclude<ExtArgs> | null
    /**
     * Filter, which QRCodePool to fetch.
     */
    where?: QRCodePoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRCodePools to fetch.
     */
    orderBy?: QRCodePoolOrderByWithRelationInput | QRCodePoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRCodePools.
     */
    cursor?: QRCodePoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRCodePools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRCodePools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRCodePools.
     */
    distinct?: QRCodePoolScalarFieldEnum | QRCodePoolScalarFieldEnum[]
  }

  /**
   * QRCodePool findMany
   */
  export type QRCodePoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCodePool
     */
    select?: QRCodePoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCodePool
     */
    omit?: QRCodePoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodePoolInclude<ExtArgs> | null
    /**
     * Filter, which QRCodePools to fetch.
     */
    where?: QRCodePoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRCodePools to fetch.
     */
    orderBy?: QRCodePoolOrderByWithRelationInput | QRCodePoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QRCodePools.
     */
    cursor?: QRCodePoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRCodePools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRCodePools.
     */
    skip?: number
    distinct?: QRCodePoolScalarFieldEnum | QRCodePoolScalarFieldEnum[]
  }

  /**
   * QRCodePool create
   */
  export type QRCodePoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCodePool
     */
    select?: QRCodePoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCodePool
     */
    omit?: QRCodePoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodePoolInclude<ExtArgs> | null
    /**
     * The data needed to create a QRCodePool.
     */
    data: XOR<QRCodePoolCreateInput, QRCodePoolUncheckedCreateInput>
  }

  /**
   * QRCodePool createMany
   */
  export type QRCodePoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QRCodePools.
     */
    data: QRCodePoolCreateManyInput | QRCodePoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QRCodePool createManyAndReturn
   */
  export type QRCodePoolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCodePool
     */
    select?: QRCodePoolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QRCodePool
     */
    omit?: QRCodePoolOmit<ExtArgs> | null
    /**
     * The data used to create many QRCodePools.
     */
    data: QRCodePoolCreateManyInput | QRCodePoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QRCodePool update
   */
  export type QRCodePoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCodePool
     */
    select?: QRCodePoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCodePool
     */
    omit?: QRCodePoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodePoolInclude<ExtArgs> | null
    /**
     * The data needed to update a QRCodePool.
     */
    data: XOR<QRCodePoolUpdateInput, QRCodePoolUncheckedUpdateInput>
    /**
     * Choose, which QRCodePool to update.
     */
    where: QRCodePoolWhereUniqueInput
  }

  /**
   * QRCodePool updateMany
   */
  export type QRCodePoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QRCodePools.
     */
    data: XOR<QRCodePoolUpdateManyMutationInput, QRCodePoolUncheckedUpdateManyInput>
    /**
     * Filter which QRCodePools to update
     */
    where?: QRCodePoolWhereInput
    /**
     * Limit how many QRCodePools to update.
     */
    limit?: number
  }

  /**
   * QRCodePool updateManyAndReturn
   */
  export type QRCodePoolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCodePool
     */
    select?: QRCodePoolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QRCodePool
     */
    omit?: QRCodePoolOmit<ExtArgs> | null
    /**
     * The data used to update QRCodePools.
     */
    data: XOR<QRCodePoolUpdateManyMutationInput, QRCodePoolUncheckedUpdateManyInput>
    /**
     * Filter which QRCodePools to update
     */
    where?: QRCodePoolWhereInput
    /**
     * Limit how many QRCodePools to update.
     */
    limit?: number
  }

  /**
   * QRCodePool upsert
   */
  export type QRCodePoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCodePool
     */
    select?: QRCodePoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCodePool
     */
    omit?: QRCodePoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodePoolInclude<ExtArgs> | null
    /**
     * The filter to search for the QRCodePool to update in case it exists.
     */
    where: QRCodePoolWhereUniqueInput
    /**
     * In case the QRCodePool found by the `where` argument doesn't exist, create a new QRCodePool with this data.
     */
    create: XOR<QRCodePoolCreateInput, QRCodePoolUncheckedCreateInput>
    /**
     * In case the QRCodePool was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QRCodePoolUpdateInput, QRCodePoolUncheckedUpdateInput>
  }

  /**
   * QRCodePool delete
   */
  export type QRCodePoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCodePool
     */
    select?: QRCodePoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCodePool
     */
    omit?: QRCodePoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodePoolInclude<ExtArgs> | null
    /**
     * Filter which QRCodePool to delete.
     */
    where: QRCodePoolWhereUniqueInput
  }

  /**
   * QRCodePool deleteMany
   */
  export type QRCodePoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRCodePools to delete
     */
    where?: QRCodePoolWhereInput
    /**
     * Limit how many QRCodePools to delete.
     */
    limit?: number
  }

  /**
   * QRCodePool.qrCodes
   */
  export type QRCodePool$qrCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
    where?: QRCodeWhereInput
    orderBy?: QRCodeOrderByWithRelationInput | QRCodeOrderByWithRelationInput[]
    cursor?: QRCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QRCodeScalarFieldEnum | QRCodeScalarFieldEnum[]
  }

  /**
   * QRCodePool without action
   */
  export type QRCodePoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCodePool
     */
    select?: QRCodePoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCodePool
     */
    omit?: QRCodePoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodePoolInclude<ExtArgs> | null
  }


  /**
   * Model QRCode
   */

  export type AggregateQRCode = {
    _count: QRCodeCountAggregateOutputType | null
    _min: QRCodeMinAggregateOutputType | null
    _max: QRCodeMaxAggregateOutputType | null
  }

  export type QRCodeMinAggregateOutputType = {
    id: string | null
    poolId: string | null
    qrCodeString: string | null
    qrCodeHash: string | null
    qrImageUrl: string | null
    status: $Enums.QRStatus | null
    assignedToPet: string | null
    assignedAt: Date | null
    activatedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type QRCodeMaxAggregateOutputType = {
    id: string | null
    poolId: string | null
    qrCodeString: string | null
    qrCodeHash: string | null
    qrImageUrl: string | null
    status: $Enums.QRStatus | null
    assignedToPet: string | null
    assignedAt: Date | null
    activatedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type QRCodeCountAggregateOutputType = {
    id: number
    poolId: number
    qrCodeString: number
    qrCodeHash: number
    qrImageUrl: number
    status: number
    assignedToPet: number
    assignedAt: number
    activatedAt: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type QRCodeMinAggregateInputType = {
    id?: true
    poolId?: true
    qrCodeString?: true
    qrCodeHash?: true
    qrImageUrl?: true
    status?: true
    assignedToPet?: true
    assignedAt?: true
    activatedAt?: true
    expiresAt?: true
    createdAt?: true
  }

  export type QRCodeMaxAggregateInputType = {
    id?: true
    poolId?: true
    qrCodeString?: true
    qrCodeHash?: true
    qrImageUrl?: true
    status?: true
    assignedToPet?: true
    assignedAt?: true
    activatedAt?: true
    expiresAt?: true
    createdAt?: true
  }

  export type QRCodeCountAggregateInputType = {
    id?: true
    poolId?: true
    qrCodeString?: true
    qrCodeHash?: true
    qrImageUrl?: true
    status?: true
    assignedToPet?: true
    assignedAt?: true
    activatedAt?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type QRCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRCode to aggregate.
     */
    where?: QRCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRCodes to fetch.
     */
    orderBy?: QRCodeOrderByWithRelationInput | QRCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QRCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QRCodes
    **/
    _count?: true | QRCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QRCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QRCodeMaxAggregateInputType
  }

  export type GetQRCodeAggregateType<T extends QRCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateQRCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQRCode[P]>
      : GetScalarType<T[P], AggregateQRCode[P]>
  }




  export type QRCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QRCodeWhereInput
    orderBy?: QRCodeOrderByWithAggregationInput | QRCodeOrderByWithAggregationInput[]
    by: QRCodeScalarFieldEnum[] | QRCodeScalarFieldEnum
    having?: QRCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QRCodeCountAggregateInputType | true
    _min?: QRCodeMinAggregateInputType
    _max?: QRCodeMaxAggregateInputType
  }

  export type QRCodeGroupByOutputType = {
    id: string
    poolId: string | null
    qrCodeString: string
    qrCodeHash: string
    qrImageUrl: string | null
    status: $Enums.QRStatus
    assignedToPet: string | null
    assignedAt: Date | null
    activatedAt: Date | null
    expiresAt: Date | null
    createdAt: Date
    _count: QRCodeCountAggregateOutputType | null
    _min: QRCodeMinAggregateOutputType | null
    _max: QRCodeMaxAggregateOutputType | null
  }

  type GetQRCodeGroupByPayload<T extends QRCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QRCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QRCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QRCodeGroupByOutputType[P]>
            : GetScalarType<T[P], QRCodeGroupByOutputType[P]>
        }
      >
    >


  export type QRCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poolId?: boolean
    qrCodeString?: boolean
    qrCodeHash?: boolean
    qrImageUrl?: boolean
    status?: boolean
    assignedToPet?: boolean
    assignedAt?: boolean
    activatedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    paymentEvents?: boolean | QRCode$paymentEventsArgs<ExtArgs>
    pet?: boolean | QRCode$petArgs<ExtArgs>
    pool?: boolean | QRCode$poolArgs<ExtArgs>
    scanEvents?: boolean | QRCode$scanEventsArgs<ExtArgs>
    _count?: boolean | QRCodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qRCode"]>

  export type QRCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poolId?: boolean
    qrCodeString?: boolean
    qrCodeHash?: boolean
    qrImageUrl?: boolean
    status?: boolean
    assignedToPet?: boolean
    assignedAt?: boolean
    activatedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    pet?: boolean | QRCode$petArgs<ExtArgs>
    pool?: boolean | QRCode$poolArgs<ExtArgs>
  }, ExtArgs["result"]["qRCode"]>

  export type QRCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poolId?: boolean
    qrCodeString?: boolean
    qrCodeHash?: boolean
    qrImageUrl?: boolean
    status?: boolean
    assignedToPet?: boolean
    assignedAt?: boolean
    activatedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    pet?: boolean | QRCode$petArgs<ExtArgs>
    pool?: boolean | QRCode$poolArgs<ExtArgs>
  }, ExtArgs["result"]["qRCode"]>

  export type QRCodeSelectScalar = {
    id?: boolean
    poolId?: boolean
    qrCodeString?: boolean
    qrCodeHash?: boolean
    qrImageUrl?: boolean
    status?: boolean
    assignedToPet?: boolean
    assignedAt?: boolean
    activatedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type QRCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "poolId" | "qrCodeString" | "qrCodeHash" | "qrImageUrl" | "status" | "assignedToPet" | "assignedAt" | "activatedAt" | "expiresAt" | "createdAt", ExtArgs["result"]["qRCode"]>
  export type QRCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentEvents?: boolean | QRCode$paymentEventsArgs<ExtArgs>
    pet?: boolean | QRCode$petArgs<ExtArgs>
    pool?: boolean | QRCode$poolArgs<ExtArgs>
    scanEvents?: boolean | QRCode$scanEventsArgs<ExtArgs>
    _count?: boolean | QRCodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QRCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | QRCode$petArgs<ExtArgs>
    pool?: boolean | QRCode$poolArgs<ExtArgs>
  }
  export type QRCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | QRCode$petArgs<ExtArgs>
    pool?: boolean | QRCode$poolArgs<ExtArgs>
  }

  export type $QRCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QRCode"
    objects: {
      paymentEvents: Prisma.$PaymentEventPayload<ExtArgs>[]
      pet: Prisma.$PetPayload<ExtArgs> | null
      pool: Prisma.$QRCodePoolPayload<ExtArgs> | null
      scanEvents: Prisma.$QRScanEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      poolId: string | null
      qrCodeString: string
      qrCodeHash: string
      qrImageUrl: string | null
      status: $Enums.QRStatus
      assignedToPet: string | null
      assignedAt: Date | null
      activatedAt: Date | null
      expiresAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["qRCode"]>
    composites: {}
  }

  type QRCodeGetPayload<S extends boolean | null | undefined | QRCodeDefaultArgs> = $Result.GetResult<Prisma.$QRCodePayload, S>

  type QRCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QRCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QRCodeCountAggregateInputType | true
    }

  export interface QRCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QRCode'], meta: { name: 'QRCode' } }
    /**
     * Find zero or one QRCode that matches the filter.
     * @param {QRCodeFindUniqueArgs} args - Arguments to find a QRCode
     * @example
     * // Get one QRCode
     * const qRCode = await prisma.qRCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QRCodeFindUniqueArgs>(args: SelectSubset<T, QRCodeFindUniqueArgs<ExtArgs>>): Prisma__QRCodeClient<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QRCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QRCodeFindUniqueOrThrowArgs} args - Arguments to find a QRCode
     * @example
     * // Get one QRCode
     * const qRCode = await prisma.qRCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QRCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, QRCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QRCodeClient<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRCodeFindFirstArgs} args - Arguments to find a QRCode
     * @example
     * // Get one QRCode
     * const qRCode = await prisma.qRCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QRCodeFindFirstArgs>(args?: SelectSubset<T, QRCodeFindFirstArgs<ExtArgs>>): Prisma__QRCodeClient<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRCodeFindFirstOrThrowArgs} args - Arguments to find a QRCode
     * @example
     * // Get one QRCode
     * const qRCode = await prisma.qRCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QRCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, QRCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__QRCodeClient<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QRCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QRCodes
     * const qRCodes = await prisma.qRCode.findMany()
     * 
     * // Get first 10 QRCodes
     * const qRCodes = await prisma.qRCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qRCodeWithIdOnly = await prisma.qRCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QRCodeFindManyArgs>(args?: SelectSubset<T, QRCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QRCode.
     * @param {QRCodeCreateArgs} args - Arguments to create a QRCode.
     * @example
     * // Create one QRCode
     * const QRCode = await prisma.qRCode.create({
     *   data: {
     *     // ... data to create a QRCode
     *   }
     * })
     * 
     */
    create<T extends QRCodeCreateArgs>(args: SelectSubset<T, QRCodeCreateArgs<ExtArgs>>): Prisma__QRCodeClient<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QRCodes.
     * @param {QRCodeCreateManyArgs} args - Arguments to create many QRCodes.
     * @example
     * // Create many QRCodes
     * const qRCode = await prisma.qRCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QRCodeCreateManyArgs>(args?: SelectSubset<T, QRCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QRCodes and returns the data saved in the database.
     * @param {QRCodeCreateManyAndReturnArgs} args - Arguments to create many QRCodes.
     * @example
     * // Create many QRCodes
     * const qRCode = await prisma.qRCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QRCodes and only return the `id`
     * const qRCodeWithIdOnly = await prisma.qRCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QRCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, QRCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QRCode.
     * @param {QRCodeDeleteArgs} args - Arguments to delete one QRCode.
     * @example
     * // Delete one QRCode
     * const QRCode = await prisma.qRCode.delete({
     *   where: {
     *     // ... filter to delete one QRCode
     *   }
     * })
     * 
     */
    delete<T extends QRCodeDeleteArgs>(args: SelectSubset<T, QRCodeDeleteArgs<ExtArgs>>): Prisma__QRCodeClient<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QRCode.
     * @param {QRCodeUpdateArgs} args - Arguments to update one QRCode.
     * @example
     * // Update one QRCode
     * const qRCode = await prisma.qRCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QRCodeUpdateArgs>(args: SelectSubset<T, QRCodeUpdateArgs<ExtArgs>>): Prisma__QRCodeClient<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QRCodes.
     * @param {QRCodeDeleteManyArgs} args - Arguments to filter QRCodes to delete.
     * @example
     * // Delete a few QRCodes
     * const { count } = await prisma.qRCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QRCodeDeleteManyArgs>(args?: SelectSubset<T, QRCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QRCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QRCodes
     * const qRCode = await prisma.qRCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QRCodeUpdateManyArgs>(args: SelectSubset<T, QRCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QRCodes and returns the data updated in the database.
     * @param {QRCodeUpdateManyAndReturnArgs} args - Arguments to update many QRCodes.
     * @example
     * // Update many QRCodes
     * const qRCode = await prisma.qRCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QRCodes and only return the `id`
     * const qRCodeWithIdOnly = await prisma.qRCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QRCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, QRCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QRCode.
     * @param {QRCodeUpsertArgs} args - Arguments to update or create a QRCode.
     * @example
     * // Update or create a QRCode
     * const qRCode = await prisma.qRCode.upsert({
     *   create: {
     *     // ... data to create a QRCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QRCode we want to update
     *   }
     * })
     */
    upsert<T extends QRCodeUpsertArgs>(args: SelectSubset<T, QRCodeUpsertArgs<ExtArgs>>): Prisma__QRCodeClient<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QRCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRCodeCountArgs} args - Arguments to filter QRCodes to count.
     * @example
     * // Count the number of QRCodes
     * const count = await prisma.qRCode.count({
     *   where: {
     *     // ... the filter for the QRCodes we want to count
     *   }
     * })
    **/
    count<T extends QRCodeCountArgs>(
      args?: Subset<T, QRCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QRCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QRCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QRCodeAggregateArgs>(args: Subset<T, QRCodeAggregateArgs>): Prisma.PrismaPromise<GetQRCodeAggregateType<T>>

    /**
     * Group by QRCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QRCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QRCodeGroupByArgs['orderBy'] }
        : { orderBy?: QRCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QRCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQRCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QRCode model
   */
  readonly fields: QRCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QRCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QRCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paymentEvents<T extends QRCode$paymentEventsArgs<ExtArgs> = {}>(args?: Subset<T, QRCode$paymentEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pet<T extends QRCode$petArgs<ExtArgs> = {}>(args?: Subset<T, QRCode$petArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pool<T extends QRCode$poolArgs<ExtArgs> = {}>(args?: Subset<T, QRCode$poolArgs<ExtArgs>>): Prisma__QRCodePoolClient<$Result.GetResult<Prisma.$QRCodePoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    scanEvents<T extends QRCode$scanEventsArgs<ExtArgs> = {}>(args?: Subset<T, QRCode$scanEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRScanEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QRCode model
   */
  interface QRCodeFieldRefs {
    readonly id: FieldRef<"QRCode", 'String'>
    readonly poolId: FieldRef<"QRCode", 'String'>
    readonly qrCodeString: FieldRef<"QRCode", 'String'>
    readonly qrCodeHash: FieldRef<"QRCode", 'String'>
    readonly qrImageUrl: FieldRef<"QRCode", 'String'>
    readonly status: FieldRef<"QRCode", 'QRStatus'>
    readonly assignedToPet: FieldRef<"QRCode", 'String'>
    readonly assignedAt: FieldRef<"QRCode", 'DateTime'>
    readonly activatedAt: FieldRef<"QRCode", 'DateTime'>
    readonly expiresAt: FieldRef<"QRCode", 'DateTime'>
    readonly createdAt: FieldRef<"QRCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QRCode findUnique
   */
  export type QRCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
    /**
     * Filter, which QRCode to fetch.
     */
    where: QRCodeWhereUniqueInput
  }

  /**
   * QRCode findUniqueOrThrow
   */
  export type QRCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
    /**
     * Filter, which QRCode to fetch.
     */
    where: QRCodeWhereUniqueInput
  }

  /**
   * QRCode findFirst
   */
  export type QRCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
    /**
     * Filter, which QRCode to fetch.
     */
    where?: QRCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRCodes to fetch.
     */
    orderBy?: QRCodeOrderByWithRelationInput | QRCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRCodes.
     */
    cursor?: QRCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRCodes.
     */
    distinct?: QRCodeScalarFieldEnum | QRCodeScalarFieldEnum[]
  }

  /**
   * QRCode findFirstOrThrow
   */
  export type QRCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
    /**
     * Filter, which QRCode to fetch.
     */
    where?: QRCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRCodes to fetch.
     */
    orderBy?: QRCodeOrderByWithRelationInput | QRCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRCodes.
     */
    cursor?: QRCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRCodes.
     */
    distinct?: QRCodeScalarFieldEnum | QRCodeScalarFieldEnum[]
  }

  /**
   * QRCode findMany
   */
  export type QRCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
    /**
     * Filter, which QRCodes to fetch.
     */
    where?: QRCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRCodes to fetch.
     */
    orderBy?: QRCodeOrderByWithRelationInput | QRCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QRCodes.
     */
    cursor?: QRCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRCodes.
     */
    skip?: number
    distinct?: QRCodeScalarFieldEnum | QRCodeScalarFieldEnum[]
  }

  /**
   * QRCode create
   */
  export type QRCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a QRCode.
     */
    data: XOR<QRCodeCreateInput, QRCodeUncheckedCreateInput>
  }

  /**
   * QRCode createMany
   */
  export type QRCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QRCodes.
     */
    data: QRCodeCreateManyInput | QRCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QRCode createManyAndReturn
   */
  export type QRCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * The data used to create many QRCodes.
     */
    data: QRCodeCreateManyInput | QRCodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QRCode update
   */
  export type QRCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a QRCode.
     */
    data: XOR<QRCodeUpdateInput, QRCodeUncheckedUpdateInput>
    /**
     * Choose, which QRCode to update.
     */
    where: QRCodeWhereUniqueInput
  }

  /**
   * QRCode updateMany
   */
  export type QRCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QRCodes.
     */
    data: XOR<QRCodeUpdateManyMutationInput, QRCodeUncheckedUpdateManyInput>
    /**
     * Filter which QRCodes to update
     */
    where?: QRCodeWhereInput
    /**
     * Limit how many QRCodes to update.
     */
    limit?: number
  }

  /**
   * QRCode updateManyAndReturn
   */
  export type QRCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * The data used to update QRCodes.
     */
    data: XOR<QRCodeUpdateManyMutationInput, QRCodeUncheckedUpdateManyInput>
    /**
     * Filter which QRCodes to update
     */
    where?: QRCodeWhereInput
    /**
     * Limit how many QRCodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QRCode upsert
   */
  export type QRCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the QRCode to update in case it exists.
     */
    where: QRCodeWhereUniqueInput
    /**
     * In case the QRCode found by the `where` argument doesn't exist, create a new QRCode with this data.
     */
    create: XOR<QRCodeCreateInput, QRCodeUncheckedCreateInput>
    /**
     * In case the QRCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QRCodeUpdateInput, QRCodeUncheckedUpdateInput>
  }

  /**
   * QRCode delete
   */
  export type QRCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
    /**
     * Filter which QRCode to delete.
     */
    where: QRCodeWhereUniqueInput
  }

  /**
   * QRCode deleteMany
   */
  export type QRCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRCodes to delete
     */
    where?: QRCodeWhereInput
    /**
     * Limit how many QRCodes to delete.
     */
    limit?: number
  }

  /**
   * QRCode.paymentEvents
   */
  export type QRCode$paymentEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentEvent
     */
    omit?: PaymentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
    where?: PaymentEventWhereInput
    orderBy?: PaymentEventOrderByWithRelationInput | PaymentEventOrderByWithRelationInput[]
    cursor?: PaymentEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentEventScalarFieldEnum | PaymentEventScalarFieldEnum[]
  }

  /**
   * QRCode.pet
   */
  export type QRCode$petArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    where?: PetWhereInput
  }

  /**
   * QRCode.pool
   */
  export type QRCode$poolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCodePool
     */
    select?: QRCodePoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCodePool
     */
    omit?: QRCodePoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodePoolInclude<ExtArgs> | null
    where?: QRCodePoolWhereInput
  }

  /**
   * QRCode.scanEvents
   */
  export type QRCode$scanEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRScanEvent
     */
    select?: QRScanEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRScanEvent
     */
    omit?: QRScanEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRScanEventInclude<ExtArgs> | null
    where?: QRScanEventWhereInput
    orderBy?: QRScanEventOrderByWithRelationInput | QRScanEventOrderByWithRelationInput[]
    cursor?: QRScanEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QRScanEventScalarFieldEnum | QRScanEventScalarFieldEnum[]
  }

  /**
   * QRCode without action
   */
  export type QRCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
  }


  /**
   * Model QRScanEvent
   */

  export type AggregateQRScanEvent = {
    _count: QRScanEventCountAggregateOutputType | null
    _avg: QRScanEventAvgAggregateOutputType | null
    _sum: QRScanEventSumAggregateOutputType | null
    _min: QRScanEventMinAggregateOutputType | null
    _max: QRScanEventMaxAggregateOutputType | null
  }

  export type QRScanEventAvgAggregateOutputType = {
    locationAccuracy: Decimal | null
  }

  export type QRScanEventSumAggregateOutputType = {
    locationAccuracy: Decimal | null
  }

  export type QRScanEventMinAggregateOutputType = {
    id: string | null
    qrId: string | null
    petId: string | null
    scanTimestamp: Date | null
    scannerIp: string | null
    userAgent: string | null
    deviceType: $Enums.DeviceType | null
    scanLocation: string | null
    locationAccuracy: Decimal | null
    locationName: string | null
    countryCode: string | null
    city: string | null
    scanResult: $Enums.ScanResult | null
    createdAt: Date | null
  }

  export type QRScanEventMaxAggregateOutputType = {
    id: string | null
    qrId: string | null
    petId: string | null
    scanTimestamp: Date | null
    scannerIp: string | null
    userAgent: string | null
    deviceType: $Enums.DeviceType | null
    scanLocation: string | null
    locationAccuracy: Decimal | null
    locationName: string | null
    countryCode: string | null
    city: string | null
    scanResult: $Enums.ScanResult | null
    createdAt: Date | null
  }

  export type QRScanEventCountAggregateOutputType = {
    id: number
    qrId: number
    petId: number
    scanTimestamp: number
    scannerIp: number
    userAgent: number
    deviceType: number
    scanLocation: number
    locationAccuracy: number
    locationName: number
    countryCode: number
    city: number
    scannerContactInfo: number
    scanResult: number
    createdAt: number
    _all: number
  }


  export type QRScanEventAvgAggregateInputType = {
    locationAccuracy?: true
  }

  export type QRScanEventSumAggregateInputType = {
    locationAccuracy?: true
  }

  export type QRScanEventMinAggregateInputType = {
    id?: true
    qrId?: true
    petId?: true
    scanTimestamp?: true
    scannerIp?: true
    userAgent?: true
    deviceType?: true
    scanLocation?: true
    locationAccuracy?: true
    locationName?: true
    countryCode?: true
    city?: true
    scanResult?: true
    createdAt?: true
  }

  export type QRScanEventMaxAggregateInputType = {
    id?: true
    qrId?: true
    petId?: true
    scanTimestamp?: true
    scannerIp?: true
    userAgent?: true
    deviceType?: true
    scanLocation?: true
    locationAccuracy?: true
    locationName?: true
    countryCode?: true
    city?: true
    scanResult?: true
    createdAt?: true
  }

  export type QRScanEventCountAggregateInputType = {
    id?: true
    qrId?: true
    petId?: true
    scanTimestamp?: true
    scannerIp?: true
    userAgent?: true
    deviceType?: true
    scanLocation?: true
    locationAccuracy?: true
    locationName?: true
    countryCode?: true
    city?: true
    scannerContactInfo?: true
    scanResult?: true
    createdAt?: true
    _all?: true
  }

  export type QRScanEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRScanEvent to aggregate.
     */
    where?: QRScanEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRScanEvents to fetch.
     */
    orderBy?: QRScanEventOrderByWithRelationInput | QRScanEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QRScanEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRScanEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRScanEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QRScanEvents
    **/
    _count?: true | QRScanEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QRScanEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QRScanEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QRScanEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QRScanEventMaxAggregateInputType
  }

  export type GetQRScanEventAggregateType<T extends QRScanEventAggregateArgs> = {
        [P in keyof T & keyof AggregateQRScanEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQRScanEvent[P]>
      : GetScalarType<T[P], AggregateQRScanEvent[P]>
  }




  export type QRScanEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QRScanEventWhereInput
    orderBy?: QRScanEventOrderByWithAggregationInput | QRScanEventOrderByWithAggregationInput[]
    by: QRScanEventScalarFieldEnum[] | QRScanEventScalarFieldEnum
    having?: QRScanEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QRScanEventCountAggregateInputType | true
    _avg?: QRScanEventAvgAggregateInputType
    _sum?: QRScanEventSumAggregateInputType
    _min?: QRScanEventMinAggregateInputType
    _max?: QRScanEventMaxAggregateInputType
  }

  export type QRScanEventGroupByOutputType = {
    id: string
    qrId: string
    petId: string | null
    scanTimestamp: Date
    scannerIp: string | null
    userAgent: string | null
    deviceType: $Enums.DeviceType | null
    scanLocation: string | null
    locationAccuracy: Decimal | null
    locationName: string | null
    countryCode: string | null
    city: string | null
    scannerContactInfo: JsonValue | null
    scanResult: $Enums.ScanResult
    createdAt: Date
    _count: QRScanEventCountAggregateOutputType | null
    _avg: QRScanEventAvgAggregateOutputType | null
    _sum: QRScanEventSumAggregateOutputType | null
    _min: QRScanEventMinAggregateOutputType | null
    _max: QRScanEventMaxAggregateOutputType | null
  }

  type GetQRScanEventGroupByPayload<T extends QRScanEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QRScanEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QRScanEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QRScanEventGroupByOutputType[P]>
            : GetScalarType<T[P], QRScanEventGroupByOutputType[P]>
        }
      >
    >


  export type QRScanEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qrId?: boolean
    petId?: boolean
    scanTimestamp?: boolean
    scannerIp?: boolean
    userAgent?: boolean
    deviceType?: boolean
    scanLocation?: boolean
    locationAccuracy?: boolean
    locationName?: boolean
    countryCode?: boolean
    city?: boolean
    scannerContactInfo?: boolean
    scanResult?: boolean
    createdAt?: boolean
    qrCode?: boolean | QRCodeDefaultArgs<ExtArgs>
    pet?: boolean | QRScanEvent$petArgs<ExtArgs>
    locationEvents?: boolean | QRScanEvent$locationEventsArgs<ExtArgs>
    _count?: boolean | QRScanEventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qRScanEvent"]>

  export type QRScanEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qrId?: boolean
    petId?: boolean
    scanTimestamp?: boolean
    scannerIp?: boolean
    userAgent?: boolean
    deviceType?: boolean
    scanLocation?: boolean
    locationAccuracy?: boolean
    locationName?: boolean
    countryCode?: boolean
    city?: boolean
    scannerContactInfo?: boolean
    scanResult?: boolean
    createdAt?: boolean
    qrCode?: boolean | QRCodeDefaultArgs<ExtArgs>
    pet?: boolean | QRScanEvent$petArgs<ExtArgs>
  }, ExtArgs["result"]["qRScanEvent"]>

  export type QRScanEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qrId?: boolean
    petId?: boolean
    scanTimestamp?: boolean
    scannerIp?: boolean
    userAgent?: boolean
    deviceType?: boolean
    scanLocation?: boolean
    locationAccuracy?: boolean
    locationName?: boolean
    countryCode?: boolean
    city?: boolean
    scannerContactInfo?: boolean
    scanResult?: boolean
    createdAt?: boolean
    qrCode?: boolean | QRCodeDefaultArgs<ExtArgs>
    pet?: boolean | QRScanEvent$petArgs<ExtArgs>
  }, ExtArgs["result"]["qRScanEvent"]>

  export type QRScanEventSelectScalar = {
    id?: boolean
    qrId?: boolean
    petId?: boolean
    scanTimestamp?: boolean
    scannerIp?: boolean
    userAgent?: boolean
    deviceType?: boolean
    scanLocation?: boolean
    locationAccuracy?: boolean
    locationName?: boolean
    countryCode?: boolean
    city?: boolean
    scannerContactInfo?: boolean
    scanResult?: boolean
    createdAt?: boolean
  }

  export type QRScanEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "qrId" | "petId" | "scanTimestamp" | "scannerIp" | "userAgent" | "deviceType" | "scanLocation" | "locationAccuracy" | "locationName" | "countryCode" | "city" | "scannerContactInfo" | "scanResult" | "createdAt", ExtArgs["result"]["qRScanEvent"]>
  export type QRScanEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qrCode?: boolean | QRCodeDefaultArgs<ExtArgs>
    pet?: boolean | QRScanEvent$petArgs<ExtArgs>
    locationEvents?: boolean | QRScanEvent$locationEventsArgs<ExtArgs>
    _count?: boolean | QRScanEventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QRScanEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qrCode?: boolean | QRCodeDefaultArgs<ExtArgs>
    pet?: boolean | QRScanEvent$petArgs<ExtArgs>
  }
  export type QRScanEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qrCode?: boolean | QRCodeDefaultArgs<ExtArgs>
    pet?: boolean | QRScanEvent$petArgs<ExtArgs>
  }

  export type $QRScanEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QRScanEvent"
    objects: {
      qrCode: Prisma.$QRCodePayload<ExtArgs>
      pet: Prisma.$PetPayload<ExtArgs> | null
      locationEvents: Prisma.$PetLocationEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      qrId: string
      petId: string | null
      scanTimestamp: Date
      scannerIp: string | null
      userAgent: string | null
      deviceType: $Enums.DeviceType | null
      scanLocation: string | null
      locationAccuracy: Prisma.Decimal | null
      locationName: string | null
      countryCode: string | null
      city: string | null
      scannerContactInfo: Prisma.JsonValue | null
      scanResult: $Enums.ScanResult
      createdAt: Date
    }, ExtArgs["result"]["qRScanEvent"]>
    composites: {}
  }

  type QRScanEventGetPayload<S extends boolean | null | undefined | QRScanEventDefaultArgs> = $Result.GetResult<Prisma.$QRScanEventPayload, S>

  type QRScanEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QRScanEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QRScanEventCountAggregateInputType | true
    }

  export interface QRScanEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QRScanEvent'], meta: { name: 'QRScanEvent' } }
    /**
     * Find zero or one QRScanEvent that matches the filter.
     * @param {QRScanEventFindUniqueArgs} args - Arguments to find a QRScanEvent
     * @example
     * // Get one QRScanEvent
     * const qRScanEvent = await prisma.qRScanEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QRScanEventFindUniqueArgs>(args: SelectSubset<T, QRScanEventFindUniqueArgs<ExtArgs>>): Prisma__QRScanEventClient<$Result.GetResult<Prisma.$QRScanEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QRScanEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QRScanEventFindUniqueOrThrowArgs} args - Arguments to find a QRScanEvent
     * @example
     * // Get one QRScanEvent
     * const qRScanEvent = await prisma.qRScanEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QRScanEventFindUniqueOrThrowArgs>(args: SelectSubset<T, QRScanEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QRScanEventClient<$Result.GetResult<Prisma.$QRScanEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRScanEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRScanEventFindFirstArgs} args - Arguments to find a QRScanEvent
     * @example
     * // Get one QRScanEvent
     * const qRScanEvent = await prisma.qRScanEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QRScanEventFindFirstArgs>(args?: SelectSubset<T, QRScanEventFindFirstArgs<ExtArgs>>): Prisma__QRScanEventClient<$Result.GetResult<Prisma.$QRScanEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRScanEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRScanEventFindFirstOrThrowArgs} args - Arguments to find a QRScanEvent
     * @example
     * // Get one QRScanEvent
     * const qRScanEvent = await prisma.qRScanEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QRScanEventFindFirstOrThrowArgs>(args?: SelectSubset<T, QRScanEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__QRScanEventClient<$Result.GetResult<Prisma.$QRScanEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QRScanEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRScanEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QRScanEvents
     * const qRScanEvents = await prisma.qRScanEvent.findMany()
     * 
     * // Get first 10 QRScanEvents
     * const qRScanEvents = await prisma.qRScanEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qRScanEventWithIdOnly = await prisma.qRScanEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QRScanEventFindManyArgs>(args?: SelectSubset<T, QRScanEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRScanEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QRScanEvent.
     * @param {QRScanEventCreateArgs} args - Arguments to create a QRScanEvent.
     * @example
     * // Create one QRScanEvent
     * const QRScanEvent = await prisma.qRScanEvent.create({
     *   data: {
     *     // ... data to create a QRScanEvent
     *   }
     * })
     * 
     */
    create<T extends QRScanEventCreateArgs>(args: SelectSubset<T, QRScanEventCreateArgs<ExtArgs>>): Prisma__QRScanEventClient<$Result.GetResult<Prisma.$QRScanEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QRScanEvents.
     * @param {QRScanEventCreateManyArgs} args - Arguments to create many QRScanEvents.
     * @example
     * // Create many QRScanEvents
     * const qRScanEvent = await prisma.qRScanEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QRScanEventCreateManyArgs>(args?: SelectSubset<T, QRScanEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QRScanEvents and returns the data saved in the database.
     * @param {QRScanEventCreateManyAndReturnArgs} args - Arguments to create many QRScanEvents.
     * @example
     * // Create many QRScanEvents
     * const qRScanEvent = await prisma.qRScanEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QRScanEvents and only return the `id`
     * const qRScanEventWithIdOnly = await prisma.qRScanEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QRScanEventCreateManyAndReturnArgs>(args?: SelectSubset<T, QRScanEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRScanEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QRScanEvent.
     * @param {QRScanEventDeleteArgs} args - Arguments to delete one QRScanEvent.
     * @example
     * // Delete one QRScanEvent
     * const QRScanEvent = await prisma.qRScanEvent.delete({
     *   where: {
     *     // ... filter to delete one QRScanEvent
     *   }
     * })
     * 
     */
    delete<T extends QRScanEventDeleteArgs>(args: SelectSubset<T, QRScanEventDeleteArgs<ExtArgs>>): Prisma__QRScanEventClient<$Result.GetResult<Prisma.$QRScanEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QRScanEvent.
     * @param {QRScanEventUpdateArgs} args - Arguments to update one QRScanEvent.
     * @example
     * // Update one QRScanEvent
     * const qRScanEvent = await prisma.qRScanEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QRScanEventUpdateArgs>(args: SelectSubset<T, QRScanEventUpdateArgs<ExtArgs>>): Prisma__QRScanEventClient<$Result.GetResult<Prisma.$QRScanEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QRScanEvents.
     * @param {QRScanEventDeleteManyArgs} args - Arguments to filter QRScanEvents to delete.
     * @example
     * // Delete a few QRScanEvents
     * const { count } = await prisma.qRScanEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QRScanEventDeleteManyArgs>(args?: SelectSubset<T, QRScanEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QRScanEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRScanEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QRScanEvents
     * const qRScanEvent = await prisma.qRScanEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QRScanEventUpdateManyArgs>(args: SelectSubset<T, QRScanEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QRScanEvents and returns the data updated in the database.
     * @param {QRScanEventUpdateManyAndReturnArgs} args - Arguments to update many QRScanEvents.
     * @example
     * // Update many QRScanEvents
     * const qRScanEvent = await prisma.qRScanEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QRScanEvents and only return the `id`
     * const qRScanEventWithIdOnly = await prisma.qRScanEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QRScanEventUpdateManyAndReturnArgs>(args: SelectSubset<T, QRScanEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRScanEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QRScanEvent.
     * @param {QRScanEventUpsertArgs} args - Arguments to update or create a QRScanEvent.
     * @example
     * // Update or create a QRScanEvent
     * const qRScanEvent = await prisma.qRScanEvent.upsert({
     *   create: {
     *     // ... data to create a QRScanEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QRScanEvent we want to update
     *   }
     * })
     */
    upsert<T extends QRScanEventUpsertArgs>(args: SelectSubset<T, QRScanEventUpsertArgs<ExtArgs>>): Prisma__QRScanEventClient<$Result.GetResult<Prisma.$QRScanEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QRScanEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRScanEventCountArgs} args - Arguments to filter QRScanEvents to count.
     * @example
     * // Count the number of QRScanEvents
     * const count = await prisma.qRScanEvent.count({
     *   where: {
     *     // ... the filter for the QRScanEvents we want to count
     *   }
     * })
    **/
    count<T extends QRScanEventCountArgs>(
      args?: Subset<T, QRScanEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QRScanEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QRScanEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRScanEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QRScanEventAggregateArgs>(args: Subset<T, QRScanEventAggregateArgs>): Prisma.PrismaPromise<GetQRScanEventAggregateType<T>>

    /**
     * Group by QRScanEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRScanEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QRScanEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QRScanEventGroupByArgs['orderBy'] }
        : { orderBy?: QRScanEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QRScanEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQRScanEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QRScanEvent model
   */
  readonly fields: QRScanEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QRScanEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QRScanEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    qrCode<T extends QRCodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QRCodeDefaultArgs<ExtArgs>>): Prisma__QRCodeClient<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pet<T extends QRScanEvent$petArgs<ExtArgs> = {}>(args?: Subset<T, QRScanEvent$petArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    locationEvents<T extends QRScanEvent$locationEventsArgs<ExtArgs> = {}>(args?: Subset<T, QRScanEvent$locationEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetLocationEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QRScanEvent model
   */
  interface QRScanEventFieldRefs {
    readonly id: FieldRef<"QRScanEvent", 'String'>
    readonly qrId: FieldRef<"QRScanEvent", 'String'>
    readonly petId: FieldRef<"QRScanEvent", 'String'>
    readonly scanTimestamp: FieldRef<"QRScanEvent", 'DateTime'>
    readonly scannerIp: FieldRef<"QRScanEvent", 'String'>
    readonly userAgent: FieldRef<"QRScanEvent", 'String'>
    readonly deviceType: FieldRef<"QRScanEvent", 'DeviceType'>
    readonly scanLocation: FieldRef<"QRScanEvent", 'String'>
    readonly locationAccuracy: FieldRef<"QRScanEvent", 'Decimal'>
    readonly locationName: FieldRef<"QRScanEvent", 'String'>
    readonly countryCode: FieldRef<"QRScanEvent", 'String'>
    readonly city: FieldRef<"QRScanEvent", 'String'>
    readonly scannerContactInfo: FieldRef<"QRScanEvent", 'Json'>
    readonly scanResult: FieldRef<"QRScanEvent", 'ScanResult'>
    readonly createdAt: FieldRef<"QRScanEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QRScanEvent findUnique
   */
  export type QRScanEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRScanEvent
     */
    select?: QRScanEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRScanEvent
     */
    omit?: QRScanEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRScanEventInclude<ExtArgs> | null
    /**
     * Filter, which QRScanEvent to fetch.
     */
    where: QRScanEventWhereUniqueInput
  }

  /**
   * QRScanEvent findUniqueOrThrow
   */
  export type QRScanEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRScanEvent
     */
    select?: QRScanEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRScanEvent
     */
    omit?: QRScanEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRScanEventInclude<ExtArgs> | null
    /**
     * Filter, which QRScanEvent to fetch.
     */
    where: QRScanEventWhereUniqueInput
  }

  /**
   * QRScanEvent findFirst
   */
  export type QRScanEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRScanEvent
     */
    select?: QRScanEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRScanEvent
     */
    omit?: QRScanEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRScanEventInclude<ExtArgs> | null
    /**
     * Filter, which QRScanEvent to fetch.
     */
    where?: QRScanEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRScanEvents to fetch.
     */
    orderBy?: QRScanEventOrderByWithRelationInput | QRScanEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRScanEvents.
     */
    cursor?: QRScanEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRScanEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRScanEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRScanEvents.
     */
    distinct?: QRScanEventScalarFieldEnum | QRScanEventScalarFieldEnum[]
  }

  /**
   * QRScanEvent findFirstOrThrow
   */
  export type QRScanEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRScanEvent
     */
    select?: QRScanEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRScanEvent
     */
    omit?: QRScanEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRScanEventInclude<ExtArgs> | null
    /**
     * Filter, which QRScanEvent to fetch.
     */
    where?: QRScanEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRScanEvents to fetch.
     */
    orderBy?: QRScanEventOrderByWithRelationInput | QRScanEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRScanEvents.
     */
    cursor?: QRScanEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRScanEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRScanEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRScanEvents.
     */
    distinct?: QRScanEventScalarFieldEnum | QRScanEventScalarFieldEnum[]
  }

  /**
   * QRScanEvent findMany
   */
  export type QRScanEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRScanEvent
     */
    select?: QRScanEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRScanEvent
     */
    omit?: QRScanEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRScanEventInclude<ExtArgs> | null
    /**
     * Filter, which QRScanEvents to fetch.
     */
    where?: QRScanEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRScanEvents to fetch.
     */
    orderBy?: QRScanEventOrderByWithRelationInput | QRScanEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QRScanEvents.
     */
    cursor?: QRScanEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRScanEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRScanEvents.
     */
    skip?: number
    distinct?: QRScanEventScalarFieldEnum | QRScanEventScalarFieldEnum[]
  }

  /**
   * QRScanEvent create
   */
  export type QRScanEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRScanEvent
     */
    select?: QRScanEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRScanEvent
     */
    omit?: QRScanEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRScanEventInclude<ExtArgs> | null
    /**
     * The data needed to create a QRScanEvent.
     */
    data: XOR<QRScanEventCreateInput, QRScanEventUncheckedCreateInput>
  }

  /**
   * QRScanEvent createMany
   */
  export type QRScanEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QRScanEvents.
     */
    data: QRScanEventCreateManyInput | QRScanEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QRScanEvent createManyAndReturn
   */
  export type QRScanEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRScanEvent
     */
    select?: QRScanEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QRScanEvent
     */
    omit?: QRScanEventOmit<ExtArgs> | null
    /**
     * The data used to create many QRScanEvents.
     */
    data: QRScanEventCreateManyInput | QRScanEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRScanEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QRScanEvent update
   */
  export type QRScanEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRScanEvent
     */
    select?: QRScanEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRScanEvent
     */
    omit?: QRScanEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRScanEventInclude<ExtArgs> | null
    /**
     * The data needed to update a QRScanEvent.
     */
    data: XOR<QRScanEventUpdateInput, QRScanEventUncheckedUpdateInput>
    /**
     * Choose, which QRScanEvent to update.
     */
    where: QRScanEventWhereUniqueInput
  }

  /**
   * QRScanEvent updateMany
   */
  export type QRScanEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QRScanEvents.
     */
    data: XOR<QRScanEventUpdateManyMutationInput, QRScanEventUncheckedUpdateManyInput>
    /**
     * Filter which QRScanEvents to update
     */
    where?: QRScanEventWhereInput
    /**
     * Limit how many QRScanEvents to update.
     */
    limit?: number
  }

  /**
   * QRScanEvent updateManyAndReturn
   */
  export type QRScanEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRScanEvent
     */
    select?: QRScanEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QRScanEvent
     */
    omit?: QRScanEventOmit<ExtArgs> | null
    /**
     * The data used to update QRScanEvents.
     */
    data: XOR<QRScanEventUpdateManyMutationInput, QRScanEventUncheckedUpdateManyInput>
    /**
     * Filter which QRScanEvents to update
     */
    where?: QRScanEventWhereInput
    /**
     * Limit how many QRScanEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRScanEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QRScanEvent upsert
   */
  export type QRScanEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRScanEvent
     */
    select?: QRScanEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRScanEvent
     */
    omit?: QRScanEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRScanEventInclude<ExtArgs> | null
    /**
     * The filter to search for the QRScanEvent to update in case it exists.
     */
    where: QRScanEventWhereUniqueInput
    /**
     * In case the QRScanEvent found by the `where` argument doesn't exist, create a new QRScanEvent with this data.
     */
    create: XOR<QRScanEventCreateInput, QRScanEventUncheckedCreateInput>
    /**
     * In case the QRScanEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QRScanEventUpdateInput, QRScanEventUncheckedUpdateInput>
  }

  /**
   * QRScanEvent delete
   */
  export type QRScanEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRScanEvent
     */
    select?: QRScanEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRScanEvent
     */
    omit?: QRScanEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRScanEventInclude<ExtArgs> | null
    /**
     * Filter which QRScanEvent to delete.
     */
    where: QRScanEventWhereUniqueInput
  }

  /**
   * QRScanEvent deleteMany
   */
  export type QRScanEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRScanEvents to delete
     */
    where?: QRScanEventWhereInput
    /**
     * Limit how many QRScanEvents to delete.
     */
    limit?: number
  }

  /**
   * QRScanEvent.pet
   */
  export type QRScanEvent$petArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    where?: PetWhereInput
  }

  /**
   * QRScanEvent.locationEvents
   */
  export type QRScanEvent$locationEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetLocationEvent
     */
    select?: PetLocationEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetLocationEvent
     */
    omit?: PetLocationEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetLocationEventInclude<ExtArgs> | null
    where?: PetLocationEventWhereInput
    orderBy?: PetLocationEventOrderByWithRelationInput | PetLocationEventOrderByWithRelationInput[]
    cursor?: PetLocationEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PetLocationEventScalarFieldEnum | PetLocationEventScalarFieldEnum[]
  }

  /**
   * QRScanEvent without action
   */
  export type QRScanEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRScanEvent
     */
    select?: QRScanEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRScanEvent
     */
    omit?: QRScanEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRScanEventInclude<ExtArgs> | null
  }


  /**
   * Model PetLocationEvent
   */

  export type AggregatePetLocationEvent = {
    _count: PetLocationEventCountAggregateOutputType | null
    _avg: PetLocationEventAvgAggregateOutputType | null
    _sum: PetLocationEventSumAggregateOutputType | null
    _min: PetLocationEventMinAggregateOutputType | null
    _max: PetLocationEventMaxAggregateOutputType | null
  }

  export type PetLocationEventAvgAggregateOutputType = {
    latitude: Decimal | null
    longitude: Decimal | null
    accuracy: Decimal | null
  }

  export type PetLocationEventSumAggregateOutputType = {
    latitude: Decimal | null
    longitude: Decimal | null
    accuracy: Decimal | null
  }

  export type PetLocationEventMinAggregateOutputType = {
    id: string | null
    petId: string | null
    qrScanId: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    accuracy: Decimal | null
    scannerIp: string | null
    userAgent: string | null
    deviceType: $Enums.DeviceType | null
    locationName: string | null
    countryCode: string | null
    city: string | null
    state: string | null
    createdAt: Date | null
  }

  export type PetLocationEventMaxAggregateOutputType = {
    id: string | null
    petId: string | null
    qrScanId: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    accuracy: Decimal | null
    scannerIp: string | null
    userAgent: string | null
    deviceType: $Enums.DeviceType | null
    locationName: string | null
    countryCode: string | null
    city: string | null
    state: string | null
    createdAt: Date | null
  }

  export type PetLocationEventCountAggregateOutputType = {
    id: number
    petId: number
    qrScanId: number
    latitude: number
    longitude: number
    accuracy: number
    scannerIp: number
    userAgent: number
    deviceType: number
    locationName: number
    countryCode: number
    city: number
    state: number
    scannerContactInfo: number
    createdAt: number
    _all: number
  }


  export type PetLocationEventAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    accuracy?: true
  }

  export type PetLocationEventSumAggregateInputType = {
    latitude?: true
    longitude?: true
    accuracy?: true
  }

  export type PetLocationEventMinAggregateInputType = {
    id?: true
    petId?: true
    qrScanId?: true
    latitude?: true
    longitude?: true
    accuracy?: true
    scannerIp?: true
    userAgent?: true
    deviceType?: true
    locationName?: true
    countryCode?: true
    city?: true
    state?: true
    createdAt?: true
  }

  export type PetLocationEventMaxAggregateInputType = {
    id?: true
    petId?: true
    qrScanId?: true
    latitude?: true
    longitude?: true
    accuracy?: true
    scannerIp?: true
    userAgent?: true
    deviceType?: true
    locationName?: true
    countryCode?: true
    city?: true
    state?: true
    createdAt?: true
  }

  export type PetLocationEventCountAggregateInputType = {
    id?: true
    petId?: true
    qrScanId?: true
    latitude?: true
    longitude?: true
    accuracy?: true
    scannerIp?: true
    userAgent?: true
    deviceType?: true
    locationName?: true
    countryCode?: true
    city?: true
    state?: true
    scannerContactInfo?: true
    createdAt?: true
    _all?: true
  }

  export type PetLocationEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PetLocationEvent to aggregate.
     */
    where?: PetLocationEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetLocationEvents to fetch.
     */
    orderBy?: PetLocationEventOrderByWithRelationInput | PetLocationEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PetLocationEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetLocationEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetLocationEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PetLocationEvents
    **/
    _count?: true | PetLocationEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PetLocationEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PetLocationEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PetLocationEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PetLocationEventMaxAggregateInputType
  }

  export type GetPetLocationEventAggregateType<T extends PetLocationEventAggregateArgs> = {
        [P in keyof T & keyof AggregatePetLocationEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePetLocationEvent[P]>
      : GetScalarType<T[P], AggregatePetLocationEvent[P]>
  }




  export type PetLocationEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PetLocationEventWhereInput
    orderBy?: PetLocationEventOrderByWithAggregationInput | PetLocationEventOrderByWithAggregationInput[]
    by: PetLocationEventScalarFieldEnum[] | PetLocationEventScalarFieldEnum
    having?: PetLocationEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PetLocationEventCountAggregateInputType | true
    _avg?: PetLocationEventAvgAggregateInputType
    _sum?: PetLocationEventSumAggregateInputType
    _min?: PetLocationEventMinAggregateInputType
    _max?: PetLocationEventMaxAggregateInputType
  }

  export type PetLocationEventGroupByOutputType = {
    id: string
    petId: string
    qrScanId: string | null
    latitude: Decimal
    longitude: Decimal
    accuracy: Decimal | null
    scannerIp: string | null
    userAgent: string | null
    deviceType: $Enums.DeviceType | null
    locationName: string | null
    countryCode: string | null
    city: string | null
    state: string | null
    scannerContactInfo: JsonValue | null
    createdAt: Date
    _count: PetLocationEventCountAggregateOutputType | null
    _avg: PetLocationEventAvgAggregateOutputType | null
    _sum: PetLocationEventSumAggregateOutputType | null
    _min: PetLocationEventMinAggregateOutputType | null
    _max: PetLocationEventMaxAggregateOutputType | null
  }

  type GetPetLocationEventGroupByPayload<T extends PetLocationEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PetLocationEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PetLocationEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PetLocationEventGroupByOutputType[P]>
            : GetScalarType<T[P], PetLocationEventGroupByOutputType[P]>
        }
      >
    >


  export type PetLocationEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    petId?: boolean
    qrScanId?: boolean
    latitude?: boolean
    longitude?: boolean
    accuracy?: boolean
    scannerIp?: boolean
    userAgent?: boolean
    deviceType?: boolean
    locationName?: boolean
    countryCode?: boolean
    city?: boolean
    state?: boolean
    scannerContactInfo?: boolean
    createdAt?: boolean
    pet?: boolean | PetDefaultArgs<ExtArgs>
    qrScanEvent?: boolean | PetLocationEvent$qrScanEventArgs<ExtArgs>
  }, ExtArgs["result"]["petLocationEvent"]>

  export type PetLocationEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    petId?: boolean
    qrScanId?: boolean
    latitude?: boolean
    longitude?: boolean
    accuracy?: boolean
    scannerIp?: boolean
    userAgent?: boolean
    deviceType?: boolean
    locationName?: boolean
    countryCode?: boolean
    city?: boolean
    state?: boolean
    scannerContactInfo?: boolean
    createdAt?: boolean
    pet?: boolean | PetDefaultArgs<ExtArgs>
    qrScanEvent?: boolean | PetLocationEvent$qrScanEventArgs<ExtArgs>
  }, ExtArgs["result"]["petLocationEvent"]>

  export type PetLocationEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    petId?: boolean
    qrScanId?: boolean
    latitude?: boolean
    longitude?: boolean
    accuracy?: boolean
    scannerIp?: boolean
    userAgent?: boolean
    deviceType?: boolean
    locationName?: boolean
    countryCode?: boolean
    city?: boolean
    state?: boolean
    scannerContactInfo?: boolean
    createdAt?: boolean
    pet?: boolean | PetDefaultArgs<ExtArgs>
    qrScanEvent?: boolean | PetLocationEvent$qrScanEventArgs<ExtArgs>
  }, ExtArgs["result"]["petLocationEvent"]>

  export type PetLocationEventSelectScalar = {
    id?: boolean
    petId?: boolean
    qrScanId?: boolean
    latitude?: boolean
    longitude?: boolean
    accuracy?: boolean
    scannerIp?: boolean
    userAgent?: boolean
    deviceType?: boolean
    locationName?: boolean
    countryCode?: boolean
    city?: boolean
    state?: boolean
    scannerContactInfo?: boolean
    createdAt?: boolean
  }

  export type PetLocationEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "petId" | "qrScanId" | "latitude" | "longitude" | "accuracy" | "scannerIp" | "userAgent" | "deviceType" | "locationName" | "countryCode" | "city" | "state" | "scannerContactInfo" | "createdAt", ExtArgs["result"]["petLocationEvent"]>
  export type PetLocationEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | PetDefaultArgs<ExtArgs>
    qrScanEvent?: boolean | PetLocationEvent$qrScanEventArgs<ExtArgs>
  }
  export type PetLocationEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | PetDefaultArgs<ExtArgs>
    qrScanEvent?: boolean | PetLocationEvent$qrScanEventArgs<ExtArgs>
  }
  export type PetLocationEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | PetDefaultArgs<ExtArgs>
    qrScanEvent?: boolean | PetLocationEvent$qrScanEventArgs<ExtArgs>
  }

  export type $PetLocationEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PetLocationEvent"
    objects: {
      pet: Prisma.$PetPayload<ExtArgs>
      qrScanEvent: Prisma.$QRScanEventPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      petId: string
      qrScanId: string | null
      latitude: Prisma.Decimal
      longitude: Prisma.Decimal
      accuracy: Prisma.Decimal | null
      scannerIp: string | null
      userAgent: string | null
      deviceType: $Enums.DeviceType | null
      locationName: string | null
      countryCode: string | null
      city: string | null
      state: string | null
      scannerContactInfo: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["petLocationEvent"]>
    composites: {}
  }

  type PetLocationEventGetPayload<S extends boolean | null | undefined | PetLocationEventDefaultArgs> = $Result.GetResult<Prisma.$PetLocationEventPayload, S>

  type PetLocationEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PetLocationEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PetLocationEventCountAggregateInputType | true
    }

  export interface PetLocationEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PetLocationEvent'], meta: { name: 'PetLocationEvent' } }
    /**
     * Find zero or one PetLocationEvent that matches the filter.
     * @param {PetLocationEventFindUniqueArgs} args - Arguments to find a PetLocationEvent
     * @example
     * // Get one PetLocationEvent
     * const petLocationEvent = await prisma.petLocationEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PetLocationEventFindUniqueArgs>(args: SelectSubset<T, PetLocationEventFindUniqueArgs<ExtArgs>>): Prisma__PetLocationEventClient<$Result.GetResult<Prisma.$PetLocationEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PetLocationEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PetLocationEventFindUniqueOrThrowArgs} args - Arguments to find a PetLocationEvent
     * @example
     * // Get one PetLocationEvent
     * const petLocationEvent = await prisma.petLocationEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PetLocationEventFindUniqueOrThrowArgs>(args: SelectSubset<T, PetLocationEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PetLocationEventClient<$Result.GetResult<Prisma.$PetLocationEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PetLocationEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetLocationEventFindFirstArgs} args - Arguments to find a PetLocationEvent
     * @example
     * // Get one PetLocationEvent
     * const petLocationEvent = await prisma.petLocationEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PetLocationEventFindFirstArgs>(args?: SelectSubset<T, PetLocationEventFindFirstArgs<ExtArgs>>): Prisma__PetLocationEventClient<$Result.GetResult<Prisma.$PetLocationEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PetLocationEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetLocationEventFindFirstOrThrowArgs} args - Arguments to find a PetLocationEvent
     * @example
     * // Get one PetLocationEvent
     * const petLocationEvent = await prisma.petLocationEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PetLocationEventFindFirstOrThrowArgs>(args?: SelectSubset<T, PetLocationEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__PetLocationEventClient<$Result.GetResult<Prisma.$PetLocationEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PetLocationEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetLocationEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PetLocationEvents
     * const petLocationEvents = await prisma.petLocationEvent.findMany()
     * 
     * // Get first 10 PetLocationEvents
     * const petLocationEvents = await prisma.petLocationEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const petLocationEventWithIdOnly = await prisma.petLocationEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PetLocationEventFindManyArgs>(args?: SelectSubset<T, PetLocationEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetLocationEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PetLocationEvent.
     * @param {PetLocationEventCreateArgs} args - Arguments to create a PetLocationEvent.
     * @example
     * // Create one PetLocationEvent
     * const PetLocationEvent = await prisma.petLocationEvent.create({
     *   data: {
     *     // ... data to create a PetLocationEvent
     *   }
     * })
     * 
     */
    create<T extends PetLocationEventCreateArgs>(args: SelectSubset<T, PetLocationEventCreateArgs<ExtArgs>>): Prisma__PetLocationEventClient<$Result.GetResult<Prisma.$PetLocationEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PetLocationEvents.
     * @param {PetLocationEventCreateManyArgs} args - Arguments to create many PetLocationEvents.
     * @example
     * // Create many PetLocationEvents
     * const petLocationEvent = await prisma.petLocationEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PetLocationEventCreateManyArgs>(args?: SelectSubset<T, PetLocationEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PetLocationEvents and returns the data saved in the database.
     * @param {PetLocationEventCreateManyAndReturnArgs} args - Arguments to create many PetLocationEvents.
     * @example
     * // Create many PetLocationEvents
     * const petLocationEvent = await prisma.petLocationEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PetLocationEvents and only return the `id`
     * const petLocationEventWithIdOnly = await prisma.petLocationEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PetLocationEventCreateManyAndReturnArgs>(args?: SelectSubset<T, PetLocationEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetLocationEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PetLocationEvent.
     * @param {PetLocationEventDeleteArgs} args - Arguments to delete one PetLocationEvent.
     * @example
     * // Delete one PetLocationEvent
     * const PetLocationEvent = await prisma.petLocationEvent.delete({
     *   where: {
     *     // ... filter to delete one PetLocationEvent
     *   }
     * })
     * 
     */
    delete<T extends PetLocationEventDeleteArgs>(args: SelectSubset<T, PetLocationEventDeleteArgs<ExtArgs>>): Prisma__PetLocationEventClient<$Result.GetResult<Prisma.$PetLocationEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PetLocationEvent.
     * @param {PetLocationEventUpdateArgs} args - Arguments to update one PetLocationEvent.
     * @example
     * // Update one PetLocationEvent
     * const petLocationEvent = await prisma.petLocationEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PetLocationEventUpdateArgs>(args: SelectSubset<T, PetLocationEventUpdateArgs<ExtArgs>>): Prisma__PetLocationEventClient<$Result.GetResult<Prisma.$PetLocationEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PetLocationEvents.
     * @param {PetLocationEventDeleteManyArgs} args - Arguments to filter PetLocationEvents to delete.
     * @example
     * // Delete a few PetLocationEvents
     * const { count } = await prisma.petLocationEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PetLocationEventDeleteManyArgs>(args?: SelectSubset<T, PetLocationEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PetLocationEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetLocationEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PetLocationEvents
     * const petLocationEvent = await prisma.petLocationEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PetLocationEventUpdateManyArgs>(args: SelectSubset<T, PetLocationEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PetLocationEvents and returns the data updated in the database.
     * @param {PetLocationEventUpdateManyAndReturnArgs} args - Arguments to update many PetLocationEvents.
     * @example
     * // Update many PetLocationEvents
     * const petLocationEvent = await prisma.petLocationEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PetLocationEvents and only return the `id`
     * const petLocationEventWithIdOnly = await prisma.petLocationEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PetLocationEventUpdateManyAndReturnArgs>(args: SelectSubset<T, PetLocationEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetLocationEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PetLocationEvent.
     * @param {PetLocationEventUpsertArgs} args - Arguments to update or create a PetLocationEvent.
     * @example
     * // Update or create a PetLocationEvent
     * const petLocationEvent = await prisma.petLocationEvent.upsert({
     *   create: {
     *     // ... data to create a PetLocationEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PetLocationEvent we want to update
     *   }
     * })
     */
    upsert<T extends PetLocationEventUpsertArgs>(args: SelectSubset<T, PetLocationEventUpsertArgs<ExtArgs>>): Prisma__PetLocationEventClient<$Result.GetResult<Prisma.$PetLocationEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PetLocationEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetLocationEventCountArgs} args - Arguments to filter PetLocationEvents to count.
     * @example
     * // Count the number of PetLocationEvents
     * const count = await prisma.petLocationEvent.count({
     *   where: {
     *     // ... the filter for the PetLocationEvents we want to count
     *   }
     * })
    **/
    count<T extends PetLocationEventCountArgs>(
      args?: Subset<T, PetLocationEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PetLocationEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PetLocationEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetLocationEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PetLocationEventAggregateArgs>(args: Subset<T, PetLocationEventAggregateArgs>): Prisma.PrismaPromise<GetPetLocationEventAggregateType<T>>

    /**
     * Group by PetLocationEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetLocationEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PetLocationEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PetLocationEventGroupByArgs['orderBy'] }
        : { orderBy?: PetLocationEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PetLocationEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPetLocationEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PetLocationEvent model
   */
  readonly fields: PetLocationEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PetLocationEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PetLocationEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pet<T extends PetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PetDefaultArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    qrScanEvent<T extends PetLocationEvent$qrScanEventArgs<ExtArgs> = {}>(args?: Subset<T, PetLocationEvent$qrScanEventArgs<ExtArgs>>): Prisma__QRScanEventClient<$Result.GetResult<Prisma.$QRScanEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PetLocationEvent model
   */
  interface PetLocationEventFieldRefs {
    readonly id: FieldRef<"PetLocationEvent", 'String'>
    readonly petId: FieldRef<"PetLocationEvent", 'String'>
    readonly qrScanId: FieldRef<"PetLocationEvent", 'String'>
    readonly latitude: FieldRef<"PetLocationEvent", 'Decimal'>
    readonly longitude: FieldRef<"PetLocationEvent", 'Decimal'>
    readonly accuracy: FieldRef<"PetLocationEvent", 'Decimal'>
    readonly scannerIp: FieldRef<"PetLocationEvent", 'String'>
    readonly userAgent: FieldRef<"PetLocationEvent", 'String'>
    readonly deviceType: FieldRef<"PetLocationEvent", 'DeviceType'>
    readonly locationName: FieldRef<"PetLocationEvent", 'String'>
    readonly countryCode: FieldRef<"PetLocationEvent", 'String'>
    readonly city: FieldRef<"PetLocationEvent", 'String'>
    readonly state: FieldRef<"PetLocationEvent", 'String'>
    readonly scannerContactInfo: FieldRef<"PetLocationEvent", 'Json'>
    readonly createdAt: FieldRef<"PetLocationEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PetLocationEvent findUnique
   */
  export type PetLocationEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetLocationEvent
     */
    select?: PetLocationEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetLocationEvent
     */
    omit?: PetLocationEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetLocationEventInclude<ExtArgs> | null
    /**
     * Filter, which PetLocationEvent to fetch.
     */
    where: PetLocationEventWhereUniqueInput
  }

  /**
   * PetLocationEvent findUniqueOrThrow
   */
  export type PetLocationEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetLocationEvent
     */
    select?: PetLocationEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetLocationEvent
     */
    omit?: PetLocationEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetLocationEventInclude<ExtArgs> | null
    /**
     * Filter, which PetLocationEvent to fetch.
     */
    where: PetLocationEventWhereUniqueInput
  }

  /**
   * PetLocationEvent findFirst
   */
  export type PetLocationEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetLocationEvent
     */
    select?: PetLocationEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetLocationEvent
     */
    omit?: PetLocationEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetLocationEventInclude<ExtArgs> | null
    /**
     * Filter, which PetLocationEvent to fetch.
     */
    where?: PetLocationEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetLocationEvents to fetch.
     */
    orderBy?: PetLocationEventOrderByWithRelationInput | PetLocationEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PetLocationEvents.
     */
    cursor?: PetLocationEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetLocationEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetLocationEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PetLocationEvents.
     */
    distinct?: PetLocationEventScalarFieldEnum | PetLocationEventScalarFieldEnum[]
  }

  /**
   * PetLocationEvent findFirstOrThrow
   */
  export type PetLocationEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetLocationEvent
     */
    select?: PetLocationEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetLocationEvent
     */
    omit?: PetLocationEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetLocationEventInclude<ExtArgs> | null
    /**
     * Filter, which PetLocationEvent to fetch.
     */
    where?: PetLocationEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetLocationEvents to fetch.
     */
    orderBy?: PetLocationEventOrderByWithRelationInput | PetLocationEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PetLocationEvents.
     */
    cursor?: PetLocationEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetLocationEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetLocationEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PetLocationEvents.
     */
    distinct?: PetLocationEventScalarFieldEnum | PetLocationEventScalarFieldEnum[]
  }

  /**
   * PetLocationEvent findMany
   */
  export type PetLocationEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetLocationEvent
     */
    select?: PetLocationEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetLocationEvent
     */
    omit?: PetLocationEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetLocationEventInclude<ExtArgs> | null
    /**
     * Filter, which PetLocationEvents to fetch.
     */
    where?: PetLocationEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetLocationEvents to fetch.
     */
    orderBy?: PetLocationEventOrderByWithRelationInput | PetLocationEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PetLocationEvents.
     */
    cursor?: PetLocationEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetLocationEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetLocationEvents.
     */
    skip?: number
    distinct?: PetLocationEventScalarFieldEnum | PetLocationEventScalarFieldEnum[]
  }

  /**
   * PetLocationEvent create
   */
  export type PetLocationEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetLocationEvent
     */
    select?: PetLocationEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetLocationEvent
     */
    omit?: PetLocationEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetLocationEventInclude<ExtArgs> | null
    /**
     * The data needed to create a PetLocationEvent.
     */
    data: XOR<PetLocationEventCreateInput, PetLocationEventUncheckedCreateInput>
  }

  /**
   * PetLocationEvent createMany
   */
  export type PetLocationEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PetLocationEvents.
     */
    data: PetLocationEventCreateManyInput | PetLocationEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PetLocationEvent createManyAndReturn
   */
  export type PetLocationEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetLocationEvent
     */
    select?: PetLocationEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PetLocationEvent
     */
    omit?: PetLocationEventOmit<ExtArgs> | null
    /**
     * The data used to create many PetLocationEvents.
     */
    data: PetLocationEventCreateManyInput | PetLocationEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetLocationEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PetLocationEvent update
   */
  export type PetLocationEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetLocationEvent
     */
    select?: PetLocationEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetLocationEvent
     */
    omit?: PetLocationEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetLocationEventInclude<ExtArgs> | null
    /**
     * The data needed to update a PetLocationEvent.
     */
    data: XOR<PetLocationEventUpdateInput, PetLocationEventUncheckedUpdateInput>
    /**
     * Choose, which PetLocationEvent to update.
     */
    where: PetLocationEventWhereUniqueInput
  }

  /**
   * PetLocationEvent updateMany
   */
  export type PetLocationEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PetLocationEvents.
     */
    data: XOR<PetLocationEventUpdateManyMutationInput, PetLocationEventUncheckedUpdateManyInput>
    /**
     * Filter which PetLocationEvents to update
     */
    where?: PetLocationEventWhereInput
    /**
     * Limit how many PetLocationEvents to update.
     */
    limit?: number
  }

  /**
   * PetLocationEvent updateManyAndReturn
   */
  export type PetLocationEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetLocationEvent
     */
    select?: PetLocationEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PetLocationEvent
     */
    omit?: PetLocationEventOmit<ExtArgs> | null
    /**
     * The data used to update PetLocationEvents.
     */
    data: XOR<PetLocationEventUpdateManyMutationInput, PetLocationEventUncheckedUpdateManyInput>
    /**
     * Filter which PetLocationEvents to update
     */
    where?: PetLocationEventWhereInput
    /**
     * Limit how many PetLocationEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetLocationEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PetLocationEvent upsert
   */
  export type PetLocationEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetLocationEvent
     */
    select?: PetLocationEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetLocationEvent
     */
    omit?: PetLocationEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetLocationEventInclude<ExtArgs> | null
    /**
     * The filter to search for the PetLocationEvent to update in case it exists.
     */
    where: PetLocationEventWhereUniqueInput
    /**
     * In case the PetLocationEvent found by the `where` argument doesn't exist, create a new PetLocationEvent with this data.
     */
    create: XOR<PetLocationEventCreateInput, PetLocationEventUncheckedCreateInput>
    /**
     * In case the PetLocationEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PetLocationEventUpdateInput, PetLocationEventUncheckedUpdateInput>
  }

  /**
   * PetLocationEvent delete
   */
  export type PetLocationEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetLocationEvent
     */
    select?: PetLocationEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetLocationEvent
     */
    omit?: PetLocationEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetLocationEventInclude<ExtArgs> | null
    /**
     * Filter which PetLocationEvent to delete.
     */
    where: PetLocationEventWhereUniqueInput
  }

  /**
   * PetLocationEvent deleteMany
   */
  export type PetLocationEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PetLocationEvents to delete
     */
    where?: PetLocationEventWhereInput
    /**
     * Limit how many PetLocationEvents to delete.
     */
    limit?: number
  }

  /**
   * PetLocationEvent.qrScanEvent
   */
  export type PetLocationEvent$qrScanEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRScanEvent
     */
    select?: QRScanEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRScanEvent
     */
    omit?: QRScanEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRScanEventInclude<ExtArgs> | null
    where?: QRScanEventWhereInput
  }

  /**
   * PetLocationEvent without action
   */
  export type PetLocationEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetLocationEvent
     */
    select?: PetLocationEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetLocationEvent
     */
    omit?: PetLocationEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetLocationEventInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    amountInPaise: number | null
  }

  export type OrderSumAggregateOutputType = {
    amountInPaise: bigint | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    razorpayOrderId: string | null
    userId: string | null
    receipt: string | null
    amountInPaise: bigint | null
    currency: string | null
    status: $Enums.OrderStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    razorpayOrderId: string | null
    userId: string | null
    receipt: string | null
    amountInPaise: bigint | null
    currency: string | null
    status: $Enums.OrderStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    razorpayOrderId: number
    userId: number
    receipt: number
    amountInPaise: number
    currency: number
    status: number
    notes: number
    metadata: number
    createdAt: number
    updatedAt: number
    expiresAt: number
    rawOrderPayload: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    amountInPaise?: true
  }

  export type OrderSumAggregateInputType = {
    amountInPaise?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    razorpayOrderId?: true
    userId?: true
    receipt?: true
    amountInPaise?: true
    currency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    razorpayOrderId?: true
    userId?: true
    receipt?: true
    amountInPaise?: true
    currency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    razorpayOrderId?: true
    userId?: true
    receipt?: true
    amountInPaise?: true
    currency?: true
    status?: true
    notes?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    rawOrderPayload?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    razorpayOrderId: string | null
    userId: string
    receipt: string | null
    amountInPaise: bigint
    currency: string
    status: $Enums.OrderStatus
    notes: JsonValue | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    expiresAt: Date | null
    rawOrderPayload: JsonValue | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    razorpayOrderId?: boolean
    userId?: boolean
    receipt?: boolean
    amountInPaise?: boolean
    currency?: boolean
    status?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    rawOrderPayload?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    payments?: boolean | Order$paymentsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    razorpayOrderId?: boolean
    userId?: boolean
    receipt?: boolean
    amountInPaise?: boolean
    currency?: boolean
    status?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    rawOrderPayload?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    razorpayOrderId?: boolean
    userId?: boolean
    receipt?: boolean
    amountInPaise?: boolean
    currency?: boolean
    status?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    rawOrderPayload?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    razorpayOrderId?: boolean
    userId?: boolean
    receipt?: boolean
    amountInPaise?: boolean
    currency?: boolean
    status?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    rawOrderPayload?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "razorpayOrderId" | "userId" | "receipt" | "amountInPaise" | "currency" | "status" | "notes" | "metadata" | "createdAt" | "updatedAt" | "expiresAt" | "rawOrderPayload", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    payments?: boolean | Order$paymentsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      razorpayOrderId: string | null
      userId: string
      receipt: string | null
      amountInPaise: bigint
      currency: string
      status: $Enums.OrderStatus
      notes: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      expiresAt: Date | null
      rawOrderPayload: Prisma.JsonValue | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends Order$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Order$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly razorpayOrderId: FieldRef<"Order", 'String'>
    readonly userId: FieldRef<"Order", 'String'>
    readonly receipt: FieldRef<"Order", 'String'>
    readonly amountInPaise: FieldRef<"Order", 'BigInt'>
    readonly currency: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly notes: FieldRef<"Order", 'Json'>
    readonly metadata: FieldRef<"Order", 'Json'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly expiresAt: FieldRef<"Order", 'DateTime'>
    readonly rawOrderPayload: FieldRef<"Order", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.payments
   */
  export type Order$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amountInPaise: number | null
    fee: number | null
    tax: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amountInPaise: bigint | null
    fee: bigint | null
    tax: bigint | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    localOrderId: string | null
    razorpayPaymentId: string | null
    razorpayOrderId: string | null
    amountInPaise: bigint | null
    currency: string | null
    method: string | null
    status: $Enums.PaymentStatusNew | null
    captured: boolean | null
    capturedAt: Date | null
    bank: string | null
    vpa: string | null
    fee: bigint | null
    tax: bigint | null
    signatureValid: boolean | null
    signatureVerifiedAt: Date | null
    verificationMethod: $Enums.VerificationMethod | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    localOrderId: string | null
    razorpayPaymentId: string | null
    razorpayOrderId: string | null
    amountInPaise: bigint | null
    currency: string | null
    method: string | null
    status: $Enums.PaymentStatusNew | null
    captured: boolean | null
    capturedAt: Date | null
    bank: string | null
    vpa: string | null
    fee: bigint | null
    tax: bigint | null
    signatureValid: boolean | null
    signatureVerifiedAt: Date | null
    verificationMethod: $Enums.VerificationMethod | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    localOrderId: number
    razorpayPaymentId: number
    razorpayOrderId: number
    amountInPaise: number
    currency: number
    method: number
    status: number
    captured: number
    capturedAt: number
    bank: number
    vpa: number
    card: number
    fee: number
    tax: number
    currencyConversion: number
    signatureValid: number
    signatureVerifiedAt: number
    verificationMethod: number
    rawPaymentPayload: number
    clientMeta: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amountInPaise?: true
    fee?: true
    tax?: true
  }

  export type PaymentSumAggregateInputType = {
    amountInPaise?: true
    fee?: true
    tax?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    localOrderId?: true
    razorpayPaymentId?: true
    razorpayOrderId?: true
    amountInPaise?: true
    currency?: true
    method?: true
    status?: true
    captured?: true
    capturedAt?: true
    bank?: true
    vpa?: true
    fee?: true
    tax?: true
    signatureValid?: true
    signatureVerifiedAt?: true
    verificationMethod?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    localOrderId?: true
    razorpayPaymentId?: true
    razorpayOrderId?: true
    amountInPaise?: true
    currency?: true
    method?: true
    status?: true
    captured?: true
    capturedAt?: true
    bank?: true
    vpa?: true
    fee?: true
    tax?: true
    signatureValid?: true
    signatureVerifiedAt?: true
    verificationMethod?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    localOrderId?: true
    razorpayPaymentId?: true
    razorpayOrderId?: true
    amountInPaise?: true
    currency?: true
    method?: true
    status?: true
    captured?: true
    capturedAt?: true
    bank?: true
    vpa?: true
    card?: true
    fee?: true
    tax?: true
    currencyConversion?: true
    signatureValid?: true
    signatureVerifiedAt?: true
    verificationMethod?: true
    rawPaymentPayload?: true
    clientMeta?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    localOrderId: string
    razorpayPaymentId: string
    razorpayOrderId: string
    amountInPaise: bigint
    currency: string
    method: string | null
    status: $Enums.PaymentStatusNew
    captured: boolean
    capturedAt: Date | null
    bank: string | null
    vpa: string | null
    card: JsonValue | null
    fee: bigint | null
    tax: bigint | null
    currencyConversion: JsonValue | null
    signatureValid: boolean | null
    signatureVerifiedAt: Date | null
    verificationMethod: $Enums.VerificationMethod | null
    rawPaymentPayload: JsonValue | null
    clientMeta: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    localOrderId?: boolean
    razorpayPaymentId?: boolean
    razorpayOrderId?: boolean
    amountInPaise?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    captured?: boolean
    capturedAt?: boolean
    bank?: boolean
    vpa?: boolean
    card?: boolean
    fee?: boolean
    tax?: boolean
    currencyConversion?: boolean
    signatureValid?: boolean
    signatureVerifiedAt?: boolean
    verificationMethod?: boolean
    rawPaymentPayload?: boolean
    clientMeta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    refunds?: boolean | Payment$refundsArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    localOrderId?: boolean
    razorpayPaymentId?: boolean
    razorpayOrderId?: boolean
    amountInPaise?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    captured?: boolean
    capturedAt?: boolean
    bank?: boolean
    vpa?: boolean
    card?: boolean
    fee?: boolean
    tax?: boolean
    currencyConversion?: boolean
    signatureValid?: boolean
    signatureVerifiedAt?: boolean
    verificationMethod?: boolean
    rawPaymentPayload?: boolean
    clientMeta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    localOrderId?: boolean
    razorpayPaymentId?: boolean
    razorpayOrderId?: boolean
    amountInPaise?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    captured?: boolean
    capturedAt?: boolean
    bank?: boolean
    vpa?: boolean
    card?: boolean
    fee?: boolean
    tax?: boolean
    currencyConversion?: boolean
    signatureValid?: boolean
    signatureVerifiedAt?: boolean
    verificationMethod?: boolean
    rawPaymentPayload?: boolean
    clientMeta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    localOrderId?: boolean
    razorpayPaymentId?: boolean
    razorpayOrderId?: boolean
    amountInPaise?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    captured?: boolean
    capturedAt?: boolean
    bank?: boolean
    vpa?: boolean
    card?: boolean
    fee?: boolean
    tax?: boolean
    currencyConversion?: boolean
    signatureValid?: boolean
    signatureVerifiedAt?: boolean
    verificationMethod?: boolean
    rawPaymentPayload?: boolean
    clientMeta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "localOrderId" | "razorpayPaymentId" | "razorpayOrderId" | "amountInPaise" | "currency" | "method" | "status" | "captured" | "capturedAt" | "bank" | "vpa" | "card" | "fee" | "tax" | "currencyConversion" | "signatureValid" | "signatureVerifiedAt" | "verificationMethod" | "rawPaymentPayload" | "clientMeta" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    refunds?: boolean | Payment$refundsArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      refunds: Prisma.$RefundPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      localOrderId: string
      razorpayPaymentId: string
      razorpayOrderId: string
      amountInPaise: bigint
      currency: string
      method: string | null
      status: $Enums.PaymentStatusNew
      captured: boolean
      capturedAt: Date | null
      bank: string | null
      vpa: string | null
      card: Prisma.JsonValue | null
      fee: bigint | null
      tax: bigint | null
      currencyConversion: Prisma.JsonValue | null
      signatureValid: boolean | null
      signatureVerifiedAt: Date | null
      verificationMethod: $Enums.VerificationMethod | null
      rawPaymentPayload: Prisma.JsonValue | null
      clientMeta: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    refunds<T extends Payment$refundsArgs<ExtArgs> = {}>(args?: Subset<T, Payment$refundsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly localOrderId: FieldRef<"Payment", 'String'>
    readonly razorpayPaymentId: FieldRef<"Payment", 'String'>
    readonly razorpayOrderId: FieldRef<"Payment", 'String'>
    readonly amountInPaise: FieldRef<"Payment", 'BigInt'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly method: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatusNew'>
    readonly captured: FieldRef<"Payment", 'Boolean'>
    readonly capturedAt: FieldRef<"Payment", 'DateTime'>
    readonly bank: FieldRef<"Payment", 'String'>
    readonly vpa: FieldRef<"Payment", 'String'>
    readonly card: FieldRef<"Payment", 'Json'>
    readonly fee: FieldRef<"Payment", 'BigInt'>
    readonly tax: FieldRef<"Payment", 'BigInt'>
    readonly currencyConversion: FieldRef<"Payment", 'Json'>
    readonly signatureValid: FieldRef<"Payment", 'Boolean'>
    readonly signatureVerifiedAt: FieldRef<"Payment", 'DateTime'>
    readonly verificationMethod: FieldRef<"Payment", 'VerificationMethod'>
    readonly rawPaymentPayload: FieldRef<"Payment", 'Json'>
    readonly clientMeta: FieldRef<"Payment", 'Json'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.refunds
   */
  export type Payment$refundsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    where?: RefundWhereInput
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    cursor?: RefundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Refund
   */

  export type AggregateRefund = {
    _count: RefundCountAggregateOutputType | null
    _avg: RefundAvgAggregateOutputType | null
    _sum: RefundSumAggregateOutputType | null
    _min: RefundMinAggregateOutputType | null
    _max: RefundMaxAggregateOutputType | null
  }

  export type RefundAvgAggregateOutputType = {
    amountInPaise: number | null
    refundAmount: Decimal | null
  }

  export type RefundSumAggregateOutputType = {
    amountInPaise: bigint | null
    refundAmount: Decimal | null
  }

  export type RefundMinAggregateOutputType = {
    id: string | null
    razorpayRefundId: string | null
    razorpayPaymentId: string | null
    paymentEventId: string | null
    amountInPaise: bigint | null
    refundAmount: Decimal | null
    reason: string | null
    initiatedBy: string | null
    status: $Enums.RefundStatus | null
    processedAt: Date | null
    createdAt: Date | null
  }

  export type RefundMaxAggregateOutputType = {
    id: string | null
    razorpayRefundId: string | null
    razorpayPaymentId: string | null
    paymentEventId: string | null
    amountInPaise: bigint | null
    refundAmount: Decimal | null
    reason: string | null
    initiatedBy: string | null
    status: $Enums.RefundStatus | null
    processedAt: Date | null
    createdAt: Date | null
  }

  export type RefundCountAggregateOutputType = {
    id: number
    razorpayRefundId: number
    razorpayPaymentId: number
    paymentEventId: number
    amountInPaise: number
    refundAmount: number
    reason: number
    initiatedBy: number
    status: number
    processedAt: number
    rawRefundPayload: number
    createdAt: number
    _all: number
  }


  export type RefundAvgAggregateInputType = {
    amountInPaise?: true
    refundAmount?: true
  }

  export type RefundSumAggregateInputType = {
    amountInPaise?: true
    refundAmount?: true
  }

  export type RefundMinAggregateInputType = {
    id?: true
    razorpayRefundId?: true
    razorpayPaymentId?: true
    paymentEventId?: true
    amountInPaise?: true
    refundAmount?: true
    reason?: true
    initiatedBy?: true
    status?: true
    processedAt?: true
    createdAt?: true
  }

  export type RefundMaxAggregateInputType = {
    id?: true
    razorpayRefundId?: true
    razorpayPaymentId?: true
    paymentEventId?: true
    amountInPaise?: true
    refundAmount?: true
    reason?: true
    initiatedBy?: true
    status?: true
    processedAt?: true
    createdAt?: true
  }

  export type RefundCountAggregateInputType = {
    id?: true
    razorpayRefundId?: true
    razorpayPaymentId?: true
    paymentEventId?: true
    amountInPaise?: true
    refundAmount?: true
    reason?: true
    initiatedBy?: true
    status?: true
    processedAt?: true
    rawRefundPayload?: true
    createdAt?: true
    _all?: true
  }

  export type RefundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Refund to aggregate.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Refunds
    **/
    _count?: true | RefundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefundMaxAggregateInputType
  }

  export type GetRefundAggregateType<T extends RefundAggregateArgs> = {
        [P in keyof T & keyof AggregateRefund]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefund[P]>
      : GetScalarType<T[P], AggregateRefund[P]>
  }




  export type RefundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundWhereInput
    orderBy?: RefundOrderByWithAggregationInput | RefundOrderByWithAggregationInput[]
    by: RefundScalarFieldEnum[] | RefundScalarFieldEnum
    having?: RefundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefundCountAggregateInputType | true
    _avg?: RefundAvgAggregateInputType
    _sum?: RefundSumAggregateInputType
    _min?: RefundMinAggregateInputType
    _max?: RefundMaxAggregateInputType
  }

  export type RefundGroupByOutputType = {
    id: string
    razorpayRefundId: string | null
    razorpayPaymentId: string
    paymentEventId: string | null
    amountInPaise: bigint
    refundAmount: Decimal | null
    reason: string | null
    initiatedBy: string | null
    status: $Enums.RefundStatus
    processedAt: Date | null
    rawRefundPayload: JsonValue | null
    createdAt: Date
    _count: RefundCountAggregateOutputType | null
    _avg: RefundAvgAggregateOutputType | null
    _sum: RefundSumAggregateOutputType | null
    _min: RefundMinAggregateOutputType | null
    _max: RefundMaxAggregateOutputType | null
  }

  type GetRefundGroupByPayload<T extends RefundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefundGroupByOutputType[P]>
            : GetScalarType<T[P], RefundGroupByOutputType[P]>
        }
      >
    >


  export type RefundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    razorpayRefundId?: boolean
    razorpayPaymentId?: boolean
    paymentEventId?: boolean
    amountInPaise?: boolean
    refundAmount?: boolean
    reason?: boolean
    initiatedBy?: boolean
    status?: boolean
    processedAt?: boolean
    rawRefundPayload?: boolean
    createdAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    paymentEvent?: boolean | Refund$paymentEventArgs<ExtArgs>
  }, ExtArgs["result"]["refund"]>

  export type RefundSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    razorpayRefundId?: boolean
    razorpayPaymentId?: boolean
    paymentEventId?: boolean
    amountInPaise?: boolean
    refundAmount?: boolean
    reason?: boolean
    initiatedBy?: boolean
    status?: boolean
    processedAt?: boolean
    rawRefundPayload?: boolean
    createdAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    paymentEvent?: boolean | Refund$paymentEventArgs<ExtArgs>
  }, ExtArgs["result"]["refund"]>

  export type RefundSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    razorpayRefundId?: boolean
    razorpayPaymentId?: boolean
    paymentEventId?: boolean
    amountInPaise?: boolean
    refundAmount?: boolean
    reason?: boolean
    initiatedBy?: boolean
    status?: boolean
    processedAt?: boolean
    rawRefundPayload?: boolean
    createdAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    paymentEvent?: boolean | Refund$paymentEventArgs<ExtArgs>
  }, ExtArgs["result"]["refund"]>

  export type RefundSelectScalar = {
    id?: boolean
    razorpayRefundId?: boolean
    razorpayPaymentId?: boolean
    paymentEventId?: boolean
    amountInPaise?: boolean
    refundAmount?: boolean
    reason?: boolean
    initiatedBy?: boolean
    status?: boolean
    processedAt?: boolean
    rawRefundPayload?: boolean
    createdAt?: boolean
  }

  export type RefundOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "razorpayRefundId" | "razorpayPaymentId" | "paymentEventId" | "amountInPaise" | "refundAmount" | "reason" | "initiatedBy" | "status" | "processedAt" | "rawRefundPayload" | "createdAt", ExtArgs["result"]["refund"]>
  export type RefundInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    paymentEvent?: boolean | Refund$paymentEventArgs<ExtArgs>
  }
  export type RefundIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    paymentEvent?: boolean | Refund$paymentEventArgs<ExtArgs>
  }
  export type RefundIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    paymentEvent?: boolean | Refund$paymentEventArgs<ExtArgs>
  }

  export type $RefundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Refund"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs>
      paymentEvent: Prisma.$PaymentEventPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      razorpayRefundId: string | null
      razorpayPaymentId: string
      paymentEventId: string | null
      amountInPaise: bigint
      refundAmount: Prisma.Decimal | null
      reason: string | null
      initiatedBy: string | null
      status: $Enums.RefundStatus
      processedAt: Date | null
      rawRefundPayload: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["refund"]>
    composites: {}
  }

  type RefundGetPayload<S extends boolean | null | undefined | RefundDefaultArgs> = $Result.GetResult<Prisma.$RefundPayload, S>

  type RefundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefundFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefundCountAggregateInputType | true
    }

  export interface RefundDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Refund'], meta: { name: 'Refund' } }
    /**
     * Find zero or one Refund that matches the filter.
     * @param {RefundFindUniqueArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefundFindUniqueArgs>(args: SelectSubset<T, RefundFindUniqueArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Refund that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefundFindUniqueOrThrowArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefundFindUniqueOrThrowArgs>(args: SelectSubset<T, RefundFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Refund that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundFindFirstArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefundFindFirstArgs>(args?: SelectSubset<T, RefundFindFirstArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Refund that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundFindFirstOrThrowArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefundFindFirstOrThrowArgs>(args?: SelectSubset<T, RefundFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Refunds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Refunds
     * const refunds = await prisma.refund.findMany()
     * 
     * // Get first 10 Refunds
     * const refunds = await prisma.refund.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refundWithIdOnly = await prisma.refund.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefundFindManyArgs>(args?: SelectSubset<T, RefundFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Refund.
     * @param {RefundCreateArgs} args - Arguments to create a Refund.
     * @example
     * // Create one Refund
     * const Refund = await prisma.refund.create({
     *   data: {
     *     // ... data to create a Refund
     *   }
     * })
     * 
     */
    create<T extends RefundCreateArgs>(args: SelectSubset<T, RefundCreateArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Refunds.
     * @param {RefundCreateManyArgs} args - Arguments to create many Refunds.
     * @example
     * // Create many Refunds
     * const refund = await prisma.refund.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefundCreateManyArgs>(args?: SelectSubset<T, RefundCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Refunds and returns the data saved in the database.
     * @param {RefundCreateManyAndReturnArgs} args - Arguments to create many Refunds.
     * @example
     * // Create many Refunds
     * const refund = await prisma.refund.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Refunds and only return the `id`
     * const refundWithIdOnly = await prisma.refund.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefundCreateManyAndReturnArgs>(args?: SelectSubset<T, RefundCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Refund.
     * @param {RefundDeleteArgs} args - Arguments to delete one Refund.
     * @example
     * // Delete one Refund
     * const Refund = await prisma.refund.delete({
     *   where: {
     *     // ... filter to delete one Refund
     *   }
     * })
     * 
     */
    delete<T extends RefundDeleteArgs>(args: SelectSubset<T, RefundDeleteArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Refund.
     * @param {RefundUpdateArgs} args - Arguments to update one Refund.
     * @example
     * // Update one Refund
     * const refund = await prisma.refund.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefundUpdateArgs>(args: SelectSubset<T, RefundUpdateArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Refunds.
     * @param {RefundDeleteManyArgs} args - Arguments to filter Refunds to delete.
     * @example
     * // Delete a few Refunds
     * const { count } = await prisma.refund.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefundDeleteManyArgs>(args?: SelectSubset<T, RefundDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Refunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Refunds
     * const refund = await prisma.refund.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefundUpdateManyArgs>(args: SelectSubset<T, RefundUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Refunds and returns the data updated in the database.
     * @param {RefundUpdateManyAndReturnArgs} args - Arguments to update many Refunds.
     * @example
     * // Update many Refunds
     * const refund = await prisma.refund.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Refunds and only return the `id`
     * const refundWithIdOnly = await prisma.refund.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefundUpdateManyAndReturnArgs>(args: SelectSubset<T, RefundUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Refund.
     * @param {RefundUpsertArgs} args - Arguments to update or create a Refund.
     * @example
     * // Update or create a Refund
     * const refund = await prisma.refund.upsert({
     *   create: {
     *     // ... data to create a Refund
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Refund we want to update
     *   }
     * })
     */
    upsert<T extends RefundUpsertArgs>(args: SelectSubset<T, RefundUpsertArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Refunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundCountArgs} args - Arguments to filter Refunds to count.
     * @example
     * // Count the number of Refunds
     * const count = await prisma.refund.count({
     *   where: {
     *     // ... the filter for the Refunds we want to count
     *   }
     * })
    **/
    count<T extends RefundCountArgs>(
      args?: Subset<T, RefundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Refund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefundAggregateArgs>(args: Subset<T, RefundAggregateArgs>): Prisma.PrismaPromise<GetRefundAggregateType<T>>

    /**
     * Group by Refund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefundGroupByArgs['orderBy'] }
        : { orderBy?: RefundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Refund model
   */
  readonly fields: RefundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Refund.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefundClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paymentEvent<T extends Refund$paymentEventArgs<ExtArgs> = {}>(args?: Subset<T, Refund$paymentEventArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Refund model
   */
  interface RefundFieldRefs {
    readonly id: FieldRef<"Refund", 'String'>
    readonly razorpayRefundId: FieldRef<"Refund", 'String'>
    readonly razorpayPaymentId: FieldRef<"Refund", 'String'>
    readonly paymentEventId: FieldRef<"Refund", 'String'>
    readonly amountInPaise: FieldRef<"Refund", 'BigInt'>
    readonly refundAmount: FieldRef<"Refund", 'Decimal'>
    readonly reason: FieldRef<"Refund", 'String'>
    readonly initiatedBy: FieldRef<"Refund", 'String'>
    readonly status: FieldRef<"Refund", 'RefundStatus'>
    readonly processedAt: FieldRef<"Refund", 'DateTime'>
    readonly rawRefundPayload: FieldRef<"Refund", 'Json'>
    readonly createdAt: FieldRef<"Refund", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Refund findUnique
   */
  export type RefundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where: RefundWhereUniqueInput
  }

  /**
   * Refund findUniqueOrThrow
   */
  export type RefundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where: RefundWhereUniqueInput
  }

  /**
   * Refund findFirst
   */
  export type RefundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Refunds.
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Refunds.
     */
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * Refund findFirstOrThrow
   */
  export type RefundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Refunds.
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Refunds.
     */
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * Refund findMany
   */
  export type RefundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refunds to fetch.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Refunds.
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * Refund create
   */
  export type RefundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * The data needed to create a Refund.
     */
    data: XOR<RefundCreateInput, RefundUncheckedCreateInput>
  }

  /**
   * Refund createMany
   */
  export type RefundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Refunds.
     */
    data: RefundCreateManyInput | RefundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Refund createManyAndReturn
   */
  export type RefundCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * The data used to create many Refunds.
     */
    data: RefundCreateManyInput | RefundCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Refund update
   */
  export type RefundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * The data needed to update a Refund.
     */
    data: XOR<RefundUpdateInput, RefundUncheckedUpdateInput>
    /**
     * Choose, which Refund to update.
     */
    where: RefundWhereUniqueInput
  }

  /**
   * Refund updateMany
   */
  export type RefundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Refunds.
     */
    data: XOR<RefundUpdateManyMutationInput, RefundUncheckedUpdateManyInput>
    /**
     * Filter which Refunds to update
     */
    where?: RefundWhereInput
    /**
     * Limit how many Refunds to update.
     */
    limit?: number
  }

  /**
   * Refund updateManyAndReturn
   */
  export type RefundUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * The data used to update Refunds.
     */
    data: XOR<RefundUpdateManyMutationInput, RefundUncheckedUpdateManyInput>
    /**
     * Filter which Refunds to update
     */
    where?: RefundWhereInput
    /**
     * Limit how many Refunds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Refund upsert
   */
  export type RefundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * The filter to search for the Refund to update in case it exists.
     */
    where: RefundWhereUniqueInput
    /**
     * In case the Refund found by the `where` argument doesn't exist, create a new Refund with this data.
     */
    create: XOR<RefundCreateInput, RefundUncheckedCreateInput>
    /**
     * In case the Refund was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefundUpdateInput, RefundUncheckedUpdateInput>
  }

  /**
   * Refund delete
   */
  export type RefundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter which Refund to delete.
     */
    where: RefundWhereUniqueInput
  }

  /**
   * Refund deleteMany
   */
  export type RefundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Refunds to delete
     */
    where?: RefundWhereInput
    /**
     * Limit how many Refunds to delete.
     */
    limit?: number
  }

  /**
   * Refund.paymentEvent
   */
  export type Refund$paymentEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentEvent
     */
    omit?: PaymentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
    where?: PaymentEventWhereInput
  }

  /**
   * Refund without action
   */
  export type RefundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
  }


  /**
   * Model WebhookEvent
   */

  export type AggregateWebhookEvent = {
    _count: WebhookEventCountAggregateOutputType | null
    _min: WebhookEventMinAggregateOutputType | null
    _max: WebhookEventMaxAggregateOutputType | null
  }

  export type WebhookEventMinAggregateOutputType = {
    id: string | null
    razorpayEventId: string | null
    eventType: string | null
    signatureValid: boolean | null
    receivedAt: Date | null
    processedAt: Date | null
  }

  export type WebhookEventMaxAggregateOutputType = {
    id: string | null
    razorpayEventId: string | null
    eventType: string | null
    signatureValid: boolean | null
    receivedAt: Date | null
    processedAt: Date | null
  }

  export type WebhookEventCountAggregateOutputType = {
    id: number
    razorpayEventId: number
    eventType: number
    rawEvent: number
    headers: number
    signatureValid: number
    receivedAt: number
    processedAt: number
    processingResult: number
    _all: number
  }


  export type WebhookEventMinAggregateInputType = {
    id?: true
    razorpayEventId?: true
    eventType?: true
    signatureValid?: true
    receivedAt?: true
    processedAt?: true
  }

  export type WebhookEventMaxAggregateInputType = {
    id?: true
    razorpayEventId?: true
    eventType?: true
    signatureValid?: true
    receivedAt?: true
    processedAt?: true
  }

  export type WebhookEventCountAggregateInputType = {
    id?: true
    razorpayEventId?: true
    eventType?: true
    rawEvent?: true
    headers?: true
    signatureValid?: true
    receivedAt?: true
    processedAt?: true
    processingResult?: true
    _all?: true
  }

  export type WebhookEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookEvent to aggregate.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookEvents
    **/
    _count?: true | WebhookEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookEventMaxAggregateInputType
  }

  export type GetWebhookEventAggregateType<T extends WebhookEventAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookEvent[P]>
      : GetScalarType<T[P], AggregateWebhookEvent[P]>
  }




  export type WebhookEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookEventWhereInput
    orderBy?: WebhookEventOrderByWithAggregationInput | WebhookEventOrderByWithAggregationInput[]
    by: WebhookEventScalarFieldEnum[] | WebhookEventScalarFieldEnum
    having?: WebhookEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookEventCountAggregateInputType | true
    _min?: WebhookEventMinAggregateInputType
    _max?: WebhookEventMaxAggregateInputType
  }

  export type WebhookEventGroupByOutputType = {
    id: string
    razorpayEventId: string | null
    eventType: string
    rawEvent: JsonValue
    headers: JsonValue | null
    signatureValid: boolean
    receivedAt: Date
    processedAt: Date | null
    processingResult: JsonValue | null
    _count: WebhookEventCountAggregateOutputType | null
    _min: WebhookEventMinAggregateOutputType | null
    _max: WebhookEventMaxAggregateOutputType | null
  }

  type GetWebhookEventGroupByPayload<T extends WebhookEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookEventGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookEventGroupByOutputType[P]>
        }
      >
    >


  export type WebhookEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    razorpayEventId?: boolean
    eventType?: boolean
    rawEvent?: boolean
    headers?: boolean
    signatureValid?: boolean
    receivedAt?: boolean
    processedAt?: boolean
    processingResult?: boolean
  }, ExtArgs["result"]["webhookEvent"]>

  export type WebhookEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    razorpayEventId?: boolean
    eventType?: boolean
    rawEvent?: boolean
    headers?: boolean
    signatureValid?: boolean
    receivedAt?: boolean
    processedAt?: boolean
    processingResult?: boolean
  }, ExtArgs["result"]["webhookEvent"]>

  export type WebhookEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    razorpayEventId?: boolean
    eventType?: boolean
    rawEvent?: boolean
    headers?: boolean
    signatureValid?: boolean
    receivedAt?: boolean
    processedAt?: boolean
    processingResult?: boolean
  }, ExtArgs["result"]["webhookEvent"]>

  export type WebhookEventSelectScalar = {
    id?: boolean
    razorpayEventId?: boolean
    eventType?: boolean
    rawEvent?: boolean
    headers?: boolean
    signatureValid?: boolean
    receivedAt?: boolean
    processedAt?: boolean
    processingResult?: boolean
  }

  export type WebhookEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "razorpayEventId" | "eventType" | "rawEvent" | "headers" | "signatureValid" | "receivedAt" | "processedAt" | "processingResult", ExtArgs["result"]["webhookEvent"]>

  export type $WebhookEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      razorpayEventId: string | null
      eventType: string
      rawEvent: Prisma.JsonValue
      headers: Prisma.JsonValue | null
      signatureValid: boolean
      receivedAt: Date
      processedAt: Date | null
      processingResult: Prisma.JsonValue | null
    }, ExtArgs["result"]["webhookEvent"]>
    composites: {}
  }

  type WebhookEventGetPayload<S extends boolean | null | undefined | WebhookEventDefaultArgs> = $Result.GetResult<Prisma.$WebhookEventPayload, S>

  type WebhookEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebhookEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebhookEventCountAggregateInputType | true
    }

  export interface WebhookEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookEvent'], meta: { name: 'WebhookEvent' } }
    /**
     * Find zero or one WebhookEvent that matches the filter.
     * @param {WebhookEventFindUniqueArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookEventFindUniqueArgs>(args: SelectSubset<T, WebhookEventFindUniqueArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WebhookEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebhookEventFindUniqueOrThrowArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookEventFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindFirstArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookEventFindFirstArgs>(args?: SelectSubset<T, WebhookEventFindFirstArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindFirstOrThrowArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookEventFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WebhookEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookEvents
     * const webhookEvents = await prisma.webhookEvent.findMany()
     * 
     * // Get first 10 WebhookEvents
     * const webhookEvents = await prisma.webhookEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookEventWithIdOnly = await prisma.webhookEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookEventFindManyArgs>(args?: SelectSubset<T, WebhookEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WebhookEvent.
     * @param {WebhookEventCreateArgs} args - Arguments to create a WebhookEvent.
     * @example
     * // Create one WebhookEvent
     * const WebhookEvent = await prisma.webhookEvent.create({
     *   data: {
     *     // ... data to create a WebhookEvent
     *   }
     * })
     * 
     */
    create<T extends WebhookEventCreateArgs>(args: SelectSubset<T, WebhookEventCreateArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WebhookEvents.
     * @param {WebhookEventCreateManyArgs} args - Arguments to create many WebhookEvents.
     * @example
     * // Create many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookEventCreateManyArgs>(args?: SelectSubset<T, WebhookEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookEvents and returns the data saved in the database.
     * @param {WebhookEventCreateManyAndReturnArgs} args - Arguments to create many WebhookEvents.
     * @example
     * // Create many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookEvents and only return the `id`
     * const webhookEventWithIdOnly = await prisma.webhookEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookEventCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WebhookEvent.
     * @param {WebhookEventDeleteArgs} args - Arguments to delete one WebhookEvent.
     * @example
     * // Delete one WebhookEvent
     * const WebhookEvent = await prisma.webhookEvent.delete({
     *   where: {
     *     // ... filter to delete one WebhookEvent
     *   }
     * })
     * 
     */
    delete<T extends WebhookEventDeleteArgs>(args: SelectSubset<T, WebhookEventDeleteArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WebhookEvent.
     * @param {WebhookEventUpdateArgs} args - Arguments to update one WebhookEvent.
     * @example
     * // Update one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookEventUpdateArgs>(args: SelectSubset<T, WebhookEventUpdateArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WebhookEvents.
     * @param {WebhookEventDeleteManyArgs} args - Arguments to filter WebhookEvents to delete.
     * @example
     * // Delete a few WebhookEvents
     * const { count } = await prisma.webhookEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookEventDeleteManyArgs>(args?: SelectSubset<T, WebhookEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookEventUpdateManyArgs>(args: SelectSubset<T, WebhookEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookEvents and returns the data updated in the database.
     * @param {WebhookEventUpdateManyAndReturnArgs} args - Arguments to update many WebhookEvents.
     * @example
     * // Update many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WebhookEvents and only return the `id`
     * const webhookEventWithIdOnly = await prisma.webhookEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebhookEventUpdateManyAndReturnArgs>(args: SelectSubset<T, WebhookEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WebhookEvent.
     * @param {WebhookEventUpsertArgs} args - Arguments to update or create a WebhookEvent.
     * @example
     * // Update or create a WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.upsert({
     *   create: {
     *     // ... data to create a WebhookEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookEvent we want to update
     *   }
     * })
     */
    upsert<T extends WebhookEventUpsertArgs>(args: SelectSubset<T, WebhookEventUpsertArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventCountArgs} args - Arguments to filter WebhookEvents to count.
     * @example
     * // Count the number of WebhookEvents
     * const count = await prisma.webhookEvent.count({
     *   where: {
     *     // ... the filter for the WebhookEvents we want to count
     *   }
     * })
    **/
    count<T extends WebhookEventCountArgs>(
      args?: Subset<T, WebhookEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookEventAggregateArgs>(args: Subset<T, WebhookEventAggregateArgs>): Prisma.PrismaPromise<GetWebhookEventAggregateType<T>>

    /**
     * Group by WebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookEventGroupByArgs['orderBy'] }
        : { orderBy?: WebhookEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookEvent model
   */
  readonly fields: WebhookEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookEvent model
   */
  interface WebhookEventFieldRefs {
    readonly id: FieldRef<"WebhookEvent", 'String'>
    readonly razorpayEventId: FieldRef<"WebhookEvent", 'String'>
    readonly eventType: FieldRef<"WebhookEvent", 'String'>
    readonly rawEvent: FieldRef<"WebhookEvent", 'Json'>
    readonly headers: FieldRef<"WebhookEvent", 'Json'>
    readonly signatureValid: FieldRef<"WebhookEvent", 'Boolean'>
    readonly receivedAt: FieldRef<"WebhookEvent", 'DateTime'>
    readonly processedAt: FieldRef<"WebhookEvent", 'DateTime'>
    readonly processingResult: FieldRef<"WebhookEvent", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * WebhookEvent findUnique
   */
  export type WebhookEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent findUniqueOrThrow
   */
  export type WebhookEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent findFirst
   */
  export type WebhookEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookEvents.
     */
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent findFirstOrThrow
   */
  export type WebhookEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookEvents.
     */
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent findMany
   */
  export type WebhookEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEvents to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent create
   */
  export type WebhookEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * The data needed to create a WebhookEvent.
     */
    data: XOR<WebhookEventCreateInput, WebhookEventUncheckedCreateInput>
  }

  /**
   * WebhookEvent createMany
   */
  export type WebhookEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookEvents.
     */
    data: WebhookEventCreateManyInput | WebhookEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookEvent createManyAndReturn
   */
  export type WebhookEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * The data used to create many WebhookEvents.
     */
    data: WebhookEventCreateManyInput | WebhookEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookEvent update
   */
  export type WebhookEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * The data needed to update a WebhookEvent.
     */
    data: XOR<WebhookEventUpdateInput, WebhookEventUncheckedUpdateInput>
    /**
     * Choose, which WebhookEvent to update.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent updateMany
   */
  export type WebhookEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookEvents.
     */
    data: XOR<WebhookEventUpdateManyMutationInput, WebhookEventUncheckedUpdateManyInput>
    /**
     * Filter which WebhookEvents to update
     */
    where?: WebhookEventWhereInput
    /**
     * Limit how many WebhookEvents to update.
     */
    limit?: number
  }

  /**
   * WebhookEvent updateManyAndReturn
   */
  export type WebhookEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * The data used to update WebhookEvents.
     */
    data: XOR<WebhookEventUpdateManyMutationInput, WebhookEventUncheckedUpdateManyInput>
    /**
     * Filter which WebhookEvents to update
     */
    where?: WebhookEventWhereInput
    /**
     * Limit how many WebhookEvents to update.
     */
    limit?: number
  }

  /**
   * WebhookEvent upsert
   */
  export type WebhookEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * The filter to search for the WebhookEvent to update in case it exists.
     */
    where: WebhookEventWhereUniqueInput
    /**
     * In case the WebhookEvent found by the `where` argument doesn't exist, create a new WebhookEvent with this data.
     */
    create: XOR<WebhookEventCreateInput, WebhookEventUncheckedCreateInput>
    /**
     * In case the WebhookEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookEventUpdateInput, WebhookEventUncheckedUpdateInput>
  }

  /**
   * WebhookEvent delete
   */
  export type WebhookEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * Filter which WebhookEvent to delete.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent deleteMany
   */
  export type WebhookEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookEvents to delete
     */
    where?: WebhookEventWhereInput
    /**
     * Limit how many WebhookEvents to delete.
     */
    limit?: number
  }

  /**
   * WebhookEvent without action
   */
  export type WebhookEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
  }


  /**
   * Model PaymentWebhook
   */

  export type AggregatePaymentWebhook = {
    _count: PaymentWebhookCountAggregateOutputType | null
    _avg: PaymentWebhookAvgAggregateOutputType | null
    _sum: PaymentWebhookSumAggregateOutputType | null
    _min: PaymentWebhookMinAggregateOutputType | null
    _max: PaymentWebhookMaxAggregateOutputType | null
  }

  export type PaymentWebhookAvgAggregateOutputType = {
    processingAttempts: number | null
  }

  export type PaymentWebhookSumAggregateOutputType = {
    processingAttempts: number | null
  }

  export type PaymentWebhookMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    eventType: string | null
    entityType: string | null
    entityId: string | null
    signature: string | null
    signatureVerified: boolean | null
    processed: boolean | null
    processedAt: Date | null
    processingAttempts: number | null
    createdAt: Date | null
  }

  export type PaymentWebhookMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    eventType: string | null
    entityType: string | null
    entityId: string | null
    signature: string | null
    signatureVerified: boolean | null
    processed: boolean | null
    processedAt: Date | null
    processingAttempts: number | null
    createdAt: Date | null
  }

  export type PaymentWebhookCountAggregateOutputType = {
    id: number
    eventId: number
    eventType: number
    entityType: number
    entityId: number
    payload: number
    signature: number
    signatureVerified: number
    processed: number
    processedAt: number
    processingAttempts: number
    createdAt: number
    _all: number
  }


  export type PaymentWebhookAvgAggregateInputType = {
    processingAttempts?: true
  }

  export type PaymentWebhookSumAggregateInputType = {
    processingAttempts?: true
  }

  export type PaymentWebhookMinAggregateInputType = {
    id?: true
    eventId?: true
    eventType?: true
    entityType?: true
    entityId?: true
    signature?: true
    signatureVerified?: true
    processed?: true
    processedAt?: true
    processingAttempts?: true
    createdAt?: true
  }

  export type PaymentWebhookMaxAggregateInputType = {
    id?: true
    eventId?: true
    eventType?: true
    entityType?: true
    entityId?: true
    signature?: true
    signatureVerified?: true
    processed?: true
    processedAt?: true
    processingAttempts?: true
    createdAt?: true
  }

  export type PaymentWebhookCountAggregateInputType = {
    id?: true
    eventId?: true
    eventType?: true
    entityType?: true
    entityId?: true
    payload?: true
    signature?: true
    signatureVerified?: true
    processed?: true
    processedAt?: true
    processingAttempts?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentWebhookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentWebhook to aggregate.
     */
    where?: PaymentWebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentWebhooks to fetch.
     */
    orderBy?: PaymentWebhookOrderByWithRelationInput | PaymentWebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentWebhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentWebhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentWebhooks
    **/
    _count?: true | PaymentWebhookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentWebhookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentWebhookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentWebhookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentWebhookMaxAggregateInputType
  }

  export type GetPaymentWebhookAggregateType<T extends PaymentWebhookAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentWebhook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentWebhook[P]>
      : GetScalarType<T[P], AggregatePaymentWebhook[P]>
  }




  export type PaymentWebhookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWebhookWhereInput
    orderBy?: PaymentWebhookOrderByWithAggregationInput | PaymentWebhookOrderByWithAggregationInput[]
    by: PaymentWebhookScalarFieldEnum[] | PaymentWebhookScalarFieldEnum
    having?: PaymentWebhookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentWebhookCountAggregateInputType | true
    _avg?: PaymentWebhookAvgAggregateInputType
    _sum?: PaymentWebhookSumAggregateInputType
    _min?: PaymentWebhookMinAggregateInputType
    _max?: PaymentWebhookMaxAggregateInputType
  }

  export type PaymentWebhookGroupByOutputType = {
    id: string
    eventId: string | null
    eventType: string
    entityType: string
    entityId: string
    payload: JsonValue
    signature: string
    signatureVerified: boolean
    processed: boolean
    processedAt: Date | null
    processingAttempts: number
    createdAt: Date
    _count: PaymentWebhookCountAggregateOutputType | null
    _avg: PaymentWebhookAvgAggregateOutputType | null
    _sum: PaymentWebhookSumAggregateOutputType | null
    _min: PaymentWebhookMinAggregateOutputType | null
    _max: PaymentWebhookMaxAggregateOutputType | null
  }

  type GetPaymentWebhookGroupByPayload<T extends PaymentWebhookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentWebhookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentWebhookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentWebhookGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentWebhookGroupByOutputType[P]>
        }
      >
    >


  export type PaymentWebhookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    eventType?: boolean
    entityType?: boolean
    entityId?: boolean
    payload?: boolean
    signature?: boolean
    signatureVerified?: boolean
    processed?: boolean
    processedAt?: boolean
    processingAttempts?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["paymentWebhook"]>

  export type PaymentWebhookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    eventType?: boolean
    entityType?: boolean
    entityId?: boolean
    payload?: boolean
    signature?: boolean
    signatureVerified?: boolean
    processed?: boolean
    processedAt?: boolean
    processingAttempts?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["paymentWebhook"]>

  export type PaymentWebhookSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    eventType?: boolean
    entityType?: boolean
    entityId?: boolean
    payload?: boolean
    signature?: boolean
    signatureVerified?: boolean
    processed?: boolean
    processedAt?: boolean
    processingAttempts?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["paymentWebhook"]>

  export type PaymentWebhookSelectScalar = {
    id?: boolean
    eventId?: boolean
    eventType?: boolean
    entityType?: boolean
    entityId?: boolean
    payload?: boolean
    signature?: boolean
    signatureVerified?: boolean
    processed?: boolean
    processedAt?: boolean
    processingAttempts?: boolean
    createdAt?: boolean
  }

  export type PaymentWebhookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "eventType" | "entityType" | "entityId" | "payload" | "signature" | "signatureVerified" | "processed" | "processedAt" | "processingAttempts" | "createdAt", ExtArgs["result"]["paymentWebhook"]>

  export type $PaymentWebhookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentWebhook"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string | null
      eventType: string
      entityType: string
      entityId: string
      payload: Prisma.JsonValue
      signature: string
      signatureVerified: boolean
      processed: boolean
      processedAt: Date | null
      processingAttempts: number
      createdAt: Date
    }, ExtArgs["result"]["paymentWebhook"]>
    composites: {}
  }

  type PaymentWebhookGetPayload<S extends boolean | null | undefined | PaymentWebhookDefaultArgs> = $Result.GetResult<Prisma.$PaymentWebhookPayload, S>

  type PaymentWebhookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentWebhookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentWebhookCountAggregateInputType | true
    }

  export interface PaymentWebhookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentWebhook'], meta: { name: 'PaymentWebhook' } }
    /**
     * Find zero or one PaymentWebhook that matches the filter.
     * @param {PaymentWebhookFindUniqueArgs} args - Arguments to find a PaymentWebhook
     * @example
     * // Get one PaymentWebhook
     * const paymentWebhook = await prisma.paymentWebhook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentWebhookFindUniqueArgs>(args: SelectSubset<T, PaymentWebhookFindUniqueArgs<ExtArgs>>): Prisma__PaymentWebhookClient<$Result.GetResult<Prisma.$PaymentWebhookPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentWebhook that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentWebhookFindUniqueOrThrowArgs} args - Arguments to find a PaymentWebhook
     * @example
     * // Get one PaymentWebhook
     * const paymentWebhook = await prisma.paymentWebhook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentWebhookFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentWebhookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentWebhookClient<$Result.GetResult<Prisma.$PaymentWebhookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentWebhook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentWebhookFindFirstArgs} args - Arguments to find a PaymentWebhook
     * @example
     * // Get one PaymentWebhook
     * const paymentWebhook = await prisma.paymentWebhook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentWebhookFindFirstArgs>(args?: SelectSubset<T, PaymentWebhookFindFirstArgs<ExtArgs>>): Prisma__PaymentWebhookClient<$Result.GetResult<Prisma.$PaymentWebhookPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentWebhook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentWebhookFindFirstOrThrowArgs} args - Arguments to find a PaymentWebhook
     * @example
     * // Get one PaymentWebhook
     * const paymentWebhook = await prisma.paymentWebhook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentWebhookFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentWebhookFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentWebhookClient<$Result.GetResult<Prisma.$PaymentWebhookPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentWebhooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentWebhookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentWebhooks
     * const paymentWebhooks = await prisma.paymentWebhook.findMany()
     * 
     * // Get first 10 PaymentWebhooks
     * const paymentWebhooks = await prisma.paymentWebhook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWebhookWithIdOnly = await prisma.paymentWebhook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentWebhookFindManyArgs>(args?: SelectSubset<T, PaymentWebhookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentWebhookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentWebhook.
     * @param {PaymentWebhookCreateArgs} args - Arguments to create a PaymentWebhook.
     * @example
     * // Create one PaymentWebhook
     * const PaymentWebhook = await prisma.paymentWebhook.create({
     *   data: {
     *     // ... data to create a PaymentWebhook
     *   }
     * })
     * 
     */
    create<T extends PaymentWebhookCreateArgs>(args: SelectSubset<T, PaymentWebhookCreateArgs<ExtArgs>>): Prisma__PaymentWebhookClient<$Result.GetResult<Prisma.$PaymentWebhookPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentWebhooks.
     * @param {PaymentWebhookCreateManyArgs} args - Arguments to create many PaymentWebhooks.
     * @example
     * // Create many PaymentWebhooks
     * const paymentWebhook = await prisma.paymentWebhook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentWebhookCreateManyArgs>(args?: SelectSubset<T, PaymentWebhookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentWebhooks and returns the data saved in the database.
     * @param {PaymentWebhookCreateManyAndReturnArgs} args - Arguments to create many PaymentWebhooks.
     * @example
     * // Create many PaymentWebhooks
     * const paymentWebhook = await prisma.paymentWebhook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentWebhooks and only return the `id`
     * const paymentWebhookWithIdOnly = await prisma.paymentWebhook.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentWebhookCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentWebhookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentWebhookPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentWebhook.
     * @param {PaymentWebhookDeleteArgs} args - Arguments to delete one PaymentWebhook.
     * @example
     * // Delete one PaymentWebhook
     * const PaymentWebhook = await prisma.paymentWebhook.delete({
     *   where: {
     *     // ... filter to delete one PaymentWebhook
     *   }
     * })
     * 
     */
    delete<T extends PaymentWebhookDeleteArgs>(args: SelectSubset<T, PaymentWebhookDeleteArgs<ExtArgs>>): Prisma__PaymentWebhookClient<$Result.GetResult<Prisma.$PaymentWebhookPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentWebhook.
     * @param {PaymentWebhookUpdateArgs} args - Arguments to update one PaymentWebhook.
     * @example
     * // Update one PaymentWebhook
     * const paymentWebhook = await prisma.paymentWebhook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentWebhookUpdateArgs>(args: SelectSubset<T, PaymentWebhookUpdateArgs<ExtArgs>>): Prisma__PaymentWebhookClient<$Result.GetResult<Prisma.$PaymentWebhookPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentWebhooks.
     * @param {PaymentWebhookDeleteManyArgs} args - Arguments to filter PaymentWebhooks to delete.
     * @example
     * // Delete a few PaymentWebhooks
     * const { count } = await prisma.paymentWebhook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentWebhookDeleteManyArgs>(args?: SelectSubset<T, PaymentWebhookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentWebhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentWebhookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentWebhooks
     * const paymentWebhook = await prisma.paymentWebhook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentWebhookUpdateManyArgs>(args: SelectSubset<T, PaymentWebhookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentWebhooks and returns the data updated in the database.
     * @param {PaymentWebhookUpdateManyAndReturnArgs} args - Arguments to update many PaymentWebhooks.
     * @example
     * // Update many PaymentWebhooks
     * const paymentWebhook = await prisma.paymentWebhook.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentWebhooks and only return the `id`
     * const paymentWebhookWithIdOnly = await prisma.paymentWebhook.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentWebhookUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentWebhookUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentWebhookPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentWebhook.
     * @param {PaymentWebhookUpsertArgs} args - Arguments to update or create a PaymentWebhook.
     * @example
     * // Update or create a PaymentWebhook
     * const paymentWebhook = await prisma.paymentWebhook.upsert({
     *   create: {
     *     // ... data to create a PaymentWebhook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentWebhook we want to update
     *   }
     * })
     */
    upsert<T extends PaymentWebhookUpsertArgs>(args: SelectSubset<T, PaymentWebhookUpsertArgs<ExtArgs>>): Prisma__PaymentWebhookClient<$Result.GetResult<Prisma.$PaymentWebhookPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentWebhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentWebhookCountArgs} args - Arguments to filter PaymentWebhooks to count.
     * @example
     * // Count the number of PaymentWebhooks
     * const count = await prisma.paymentWebhook.count({
     *   where: {
     *     // ... the filter for the PaymentWebhooks we want to count
     *   }
     * })
    **/
    count<T extends PaymentWebhookCountArgs>(
      args?: Subset<T, PaymentWebhookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentWebhookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentWebhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentWebhookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentWebhookAggregateArgs>(args: Subset<T, PaymentWebhookAggregateArgs>): Prisma.PrismaPromise<GetPaymentWebhookAggregateType<T>>

    /**
     * Group by PaymentWebhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentWebhookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentWebhookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentWebhookGroupByArgs['orderBy'] }
        : { orderBy?: PaymentWebhookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentWebhookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentWebhookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentWebhook model
   */
  readonly fields: PaymentWebhookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentWebhook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentWebhookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentWebhook model
   */
  interface PaymentWebhookFieldRefs {
    readonly id: FieldRef<"PaymentWebhook", 'String'>
    readonly eventId: FieldRef<"PaymentWebhook", 'String'>
    readonly eventType: FieldRef<"PaymentWebhook", 'String'>
    readonly entityType: FieldRef<"PaymentWebhook", 'String'>
    readonly entityId: FieldRef<"PaymentWebhook", 'String'>
    readonly payload: FieldRef<"PaymentWebhook", 'Json'>
    readonly signature: FieldRef<"PaymentWebhook", 'String'>
    readonly signatureVerified: FieldRef<"PaymentWebhook", 'Boolean'>
    readonly processed: FieldRef<"PaymentWebhook", 'Boolean'>
    readonly processedAt: FieldRef<"PaymentWebhook", 'DateTime'>
    readonly processingAttempts: FieldRef<"PaymentWebhook", 'Int'>
    readonly createdAt: FieldRef<"PaymentWebhook", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentWebhook findUnique
   */
  export type PaymentWebhookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentWebhook
     */
    select?: PaymentWebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentWebhook
     */
    omit?: PaymentWebhookOmit<ExtArgs> | null
    /**
     * Filter, which PaymentWebhook to fetch.
     */
    where: PaymentWebhookWhereUniqueInput
  }

  /**
   * PaymentWebhook findUniqueOrThrow
   */
  export type PaymentWebhookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentWebhook
     */
    select?: PaymentWebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentWebhook
     */
    omit?: PaymentWebhookOmit<ExtArgs> | null
    /**
     * Filter, which PaymentWebhook to fetch.
     */
    where: PaymentWebhookWhereUniqueInput
  }

  /**
   * PaymentWebhook findFirst
   */
  export type PaymentWebhookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentWebhook
     */
    select?: PaymentWebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentWebhook
     */
    omit?: PaymentWebhookOmit<ExtArgs> | null
    /**
     * Filter, which PaymentWebhook to fetch.
     */
    where?: PaymentWebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentWebhooks to fetch.
     */
    orderBy?: PaymentWebhookOrderByWithRelationInput | PaymentWebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentWebhooks.
     */
    cursor?: PaymentWebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentWebhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentWebhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentWebhooks.
     */
    distinct?: PaymentWebhookScalarFieldEnum | PaymentWebhookScalarFieldEnum[]
  }

  /**
   * PaymentWebhook findFirstOrThrow
   */
  export type PaymentWebhookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentWebhook
     */
    select?: PaymentWebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentWebhook
     */
    omit?: PaymentWebhookOmit<ExtArgs> | null
    /**
     * Filter, which PaymentWebhook to fetch.
     */
    where?: PaymentWebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentWebhooks to fetch.
     */
    orderBy?: PaymentWebhookOrderByWithRelationInput | PaymentWebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentWebhooks.
     */
    cursor?: PaymentWebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentWebhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentWebhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentWebhooks.
     */
    distinct?: PaymentWebhookScalarFieldEnum | PaymentWebhookScalarFieldEnum[]
  }

  /**
   * PaymentWebhook findMany
   */
  export type PaymentWebhookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentWebhook
     */
    select?: PaymentWebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentWebhook
     */
    omit?: PaymentWebhookOmit<ExtArgs> | null
    /**
     * Filter, which PaymentWebhooks to fetch.
     */
    where?: PaymentWebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentWebhooks to fetch.
     */
    orderBy?: PaymentWebhookOrderByWithRelationInput | PaymentWebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentWebhooks.
     */
    cursor?: PaymentWebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentWebhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentWebhooks.
     */
    skip?: number
    distinct?: PaymentWebhookScalarFieldEnum | PaymentWebhookScalarFieldEnum[]
  }

  /**
   * PaymentWebhook create
   */
  export type PaymentWebhookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentWebhook
     */
    select?: PaymentWebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentWebhook
     */
    omit?: PaymentWebhookOmit<ExtArgs> | null
    /**
     * The data needed to create a PaymentWebhook.
     */
    data: XOR<PaymentWebhookCreateInput, PaymentWebhookUncheckedCreateInput>
  }

  /**
   * PaymentWebhook createMany
   */
  export type PaymentWebhookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentWebhooks.
     */
    data: PaymentWebhookCreateManyInput | PaymentWebhookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentWebhook createManyAndReturn
   */
  export type PaymentWebhookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentWebhook
     */
    select?: PaymentWebhookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentWebhook
     */
    omit?: PaymentWebhookOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentWebhooks.
     */
    data: PaymentWebhookCreateManyInput | PaymentWebhookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentWebhook update
   */
  export type PaymentWebhookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentWebhook
     */
    select?: PaymentWebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentWebhook
     */
    omit?: PaymentWebhookOmit<ExtArgs> | null
    /**
     * The data needed to update a PaymentWebhook.
     */
    data: XOR<PaymentWebhookUpdateInput, PaymentWebhookUncheckedUpdateInput>
    /**
     * Choose, which PaymentWebhook to update.
     */
    where: PaymentWebhookWhereUniqueInput
  }

  /**
   * PaymentWebhook updateMany
   */
  export type PaymentWebhookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentWebhooks.
     */
    data: XOR<PaymentWebhookUpdateManyMutationInput, PaymentWebhookUncheckedUpdateManyInput>
    /**
     * Filter which PaymentWebhooks to update
     */
    where?: PaymentWebhookWhereInput
    /**
     * Limit how many PaymentWebhooks to update.
     */
    limit?: number
  }

  /**
   * PaymentWebhook updateManyAndReturn
   */
  export type PaymentWebhookUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentWebhook
     */
    select?: PaymentWebhookSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentWebhook
     */
    omit?: PaymentWebhookOmit<ExtArgs> | null
    /**
     * The data used to update PaymentWebhooks.
     */
    data: XOR<PaymentWebhookUpdateManyMutationInput, PaymentWebhookUncheckedUpdateManyInput>
    /**
     * Filter which PaymentWebhooks to update
     */
    where?: PaymentWebhookWhereInput
    /**
     * Limit how many PaymentWebhooks to update.
     */
    limit?: number
  }

  /**
   * PaymentWebhook upsert
   */
  export type PaymentWebhookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentWebhook
     */
    select?: PaymentWebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentWebhook
     */
    omit?: PaymentWebhookOmit<ExtArgs> | null
    /**
     * The filter to search for the PaymentWebhook to update in case it exists.
     */
    where: PaymentWebhookWhereUniqueInput
    /**
     * In case the PaymentWebhook found by the `where` argument doesn't exist, create a new PaymentWebhook with this data.
     */
    create: XOR<PaymentWebhookCreateInput, PaymentWebhookUncheckedCreateInput>
    /**
     * In case the PaymentWebhook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentWebhookUpdateInput, PaymentWebhookUncheckedUpdateInput>
  }

  /**
   * PaymentWebhook delete
   */
  export type PaymentWebhookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentWebhook
     */
    select?: PaymentWebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentWebhook
     */
    omit?: PaymentWebhookOmit<ExtArgs> | null
    /**
     * Filter which PaymentWebhook to delete.
     */
    where: PaymentWebhookWhereUniqueInput
  }

  /**
   * PaymentWebhook deleteMany
   */
  export type PaymentWebhookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentWebhooks to delete
     */
    where?: PaymentWebhookWhereInput
    /**
     * Limit how many PaymentWebhooks to delete.
     */
    limit?: number
  }

  /**
   * PaymentWebhook without action
   */
  export type PaymentWebhookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentWebhook
     */
    select?: PaymentWebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentWebhook
     */
    omit?: PaymentWebhookOmit<ExtArgs> | null
  }


  /**
   * Model PaymentEvent
   */

  export type AggregatePaymentEvent = {
    _count: PaymentEventCountAggregateOutputType | null
    _avg: PaymentEventAvgAggregateOutputType | null
    _sum: PaymentEventSumAggregateOutputType | null
    _min: PaymentEventMinAggregateOutputType | null
    _max: PaymentEventMaxAggregateOutputType | null
  }

  export type PaymentEventAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentEventSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentEventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    petId: string | null
    qrId: string | null
    amount: Decimal | null
    currency: string | null
    paymentPurpose: $Enums.PaymentPurpose | null
    status: $Enums.PaymentStatus | null
    razorpayOrderId: string | null
    razorpayPaymentId: string | null
    razorpaySignature: string | null
    paymentMethod: string | null
    failureReason: string | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type PaymentEventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    petId: string | null
    qrId: string | null
    amount: Decimal | null
    currency: string | null
    paymentPurpose: $Enums.PaymentPurpose | null
    status: $Enums.PaymentStatus | null
    razorpayOrderId: string | null
    razorpayPaymentId: string | null
    razorpaySignature: string | null
    paymentMethod: string | null
    failureReason: string | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type PaymentEventCountAggregateOutputType = {
    id: number
    userId: number
    petId: number
    qrId: number
    amount: number
    currency: number
    paymentPurpose: number
    status: number
    razorpayOrderId: number
    razorpayPaymentId: number
    razorpaySignature: number
    paymentMethod: number
    failureReason: number
    createdAt: number
    completedAt: number
    _all: number
  }


  export type PaymentEventAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentEventSumAggregateInputType = {
    amount?: true
  }

  export type PaymentEventMinAggregateInputType = {
    id?: true
    userId?: true
    petId?: true
    qrId?: true
    amount?: true
    currency?: true
    paymentPurpose?: true
    status?: true
    razorpayOrderId?: true
    razorpayPaymentId?: true
    razorpaySignature?: true
    paymentMethod?: true
    failureReason?: true
    createdAt?: true
    completedAt?: true
  }

  export type PaymentEventMaxAggregateInputType = {
    id?: true
    userId?: true
    petId?: true
    qrId?: true
    amount?: true
    currency?: true
    paymentPurpose?: true
    status?: true
    razorpayOrderId?: true
    razorpayPaymentId?: true
    razorpaySignature?: true
    paymentMethod?: true
    failureReason?: true
    createdAt?: true
    completedAt?: true
  }

  export type PaymentEventCountAggregateInputType = {
    id?: true
    userId?: true
    petId?: true
    qrId?: true
    amount?: true
    currency?: true
    paymentPurpose?: true
    status?: true
    razorpayOrderId?: true
    razorpayPaymentId?: true
    razorpaySignature?: true
    paymentMethod?: true
    failureReason?: true
    createdAt?: true
    completedAt?: true
    _all?: true
  }

  export type PaymentEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentEvent to aggregate.
     */
    where?: PaymentEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentEvents to fetch.
     */
    orderBy?: PaymentEventOrderByWithRelationInput | PaymentEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentEvents
    **/
    _count?: true | PaymentEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentEventMaxAggregateInputType
  }

  export type GetPaymentEventAggregateType<T extends PaymentEventAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentEvent[P]>
      : GetScalarType<T[P], AggregatePaymentEvent[P]>
  }




  export type PaymentEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentEventWhereInput
    orderBy?: PaymentEventOrderByWithAggregationInput | PaymentEventOrderByWithAggregationInput[]
    by: PaymentEventScalarFieldEnum[] | PaymentEventScalarFieldEnum
    having?: PaymentEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentEventCountAggregateInputType | true
    _avg?: PaymentEventAvgAggregateInputType
    _sum?: PaymentEventSumAggregateInputType
    _min?: PaymentEventMinAggregateInputType
    _max?: PaymentEventMaxAggregateInputType
  }

  export type PaymentEventGroupByOutputType = {
    id: string
    userId: string | null
    petId: string | null
    qrId: string | null
    amount: Decimal
    currency: string
    paymentPurpose: $Enums.PaymentPurpose
    status: $Enums.PaymentStatus
    razorpayOrderId: string | null
    razorpayPaymentId: string | null
    razorpaySignature: string | null
    paymentMethod: string | null
    failureReason: string | null
    createdAt: Date
    completedAt: Date | null
    _count: PaymentEventCountAggregateOutputType | null
    _avg: PaymentEventAvgAggregateOutputType | null
    _sum: PaymentEventSumAggregateOutputType | null
    _min: PaymentEventMinAggregateOutputType | null
    _max: PaymentEventMaxAggregateOutputType | null
  }

  type GetPaymentEventGroupByPayload<T extends PaymentEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentEventGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentEventGroupByOutputType[P]>
        }
      >
    >


  export type PaymentEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    petId?: boolean
    qrId?: boolean
    amount?: boolean
    currency?: boolean
    paymentPurpose?: boolean
    status?: boolean
    razorpayOrderId?: boolean
    razorpayPaymentId?: boolean
    razorpaySignature?: boolean
    paymentMethod?: boolean
    failureReason?: boolean
    createdAt?: boolean
    completedAt?: boolean
    pet?: boolean | PaymentEvent$petArgs<ExtArgs>
    qrCode?: boolean | PaymentEvent$qrCodeArgs<ExtArgs>
    user?: boolean | PaymentEvent$userArgs<ExtArgs>
    refunds?: boolean | PaymentEvent$refundsArgs<ExtArgs>
    _count?: boolean | PaymentEventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentEvent"]>

  export type PaymentEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    petId?: boolean
    qrId?: boolean
    amount?: boolean
    currency?: boolean
    paymentPurpose?: boolean
    status?: boolean
    razorpayOrderId?: boolean
    razorpayPaymentId?: boolean
    razorpaySignature?: boolean
    paymentMethod?: boolean
    failureReason?: boolean
    createdAt?: boolean
    completedAt?: boolean
    pet?: boolean | PaymentEvent$petArgs<ExtArgs>
    qrCode?: boolean | PaymentEvent$qrCodeArgs<ExtArgs>
    user?: boolean | PaymentEvent$userArgs<ExtArgs>
  }, ExtArgs["result"]["paymentEvent"]>

  export type PaymentEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    petId?: boolean
    qrId?: boolean
    amount?: boolean
    currency?: boolean
    paymentPurpose?: boolean
    status?: boolean
    razorpayOrderId?: boolean
    razorpayPaymentId?: boolean
    razorpaySignature?: boolean
    paymentMethod?: boolean
    failureReason?: boolean
    createdAt?: boolean
    completedAt?: boolean
    pet?: boolean | PaymentEvent$petArgs<ExtArgs>
    qrCode?: boolean | PaymentEvent$qrCodeArgs<ExtArgs>
    user?: boolean | PaymentEvent$userArgs<ExtArgs>
  }, ExtArgs["result"]["paymentEvent"]>

  export type PaymentEventSelectScalar = {
    id?: boolean
    userId?: boolean
    petId?: boolean
    qrId?: boolean
    amount?: boolean
    currency?: boolean
    paymentPurpose?: boolean
    status?: boolean
    razorpayOrderId?: boolean
    razorpayPaymentId?: boolean
    razorpaySignature?: boolean
    paymentMethod?: boolean
    failureReason?: boolean
    createdAt?: boolean
    completedAt?: boolean
  }

  export type PaymentEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "petId" | "qrId" | "amount" | "currency" | "paymentPurpose" | "status" | "razorpayOrderId" | "razorpayPaymentId" | "razorpaySignature" | "paymentMethod" | "failureReason" | "createdAt" | "completedAt", ExtArgs["result"]["paymentEvent"]>
  export type PaymentEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | PaymentEvent$petArgs<ExtArgs>
    qrCode?: boolean | PaymentEvent$qrCodeArgs<ExtArgs>
    user?: boolean | PaymentEvent$userArgs<ExtArgs>
    refunds?: boolean | PaymentEvent$refundsArgs<ExtArgs>
    _count?: boolean | PaymentEventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | PaymentEvent$petArgs<ExtArgs>
    qrCode?: boolean | PaymentEvent$qrCodeArgs<ExtArgs>
    user?: boolean | PaymentEvent$userArgs<ExtArgs>
  }
  export type PaymentEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | PaymentEvent$petArgs<ExtArgs>
    qrCode?: boolean | PaymentEvent$qrCodeArgs<ExtArgs>
    user?: boolean | PaymentEvent$userArgs<ExtArgs>
  }

  export type $PaymentEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentEvent"
    objects: {
      pet: Prisma.$PetPayload<ExtArgs> | null
      qrCode: Prisma.$QRCodePayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
      refunds: Prisma.$RefundPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      petId: string | null
      qrId: string | null
      amount: Prisma.Decimal
      currency: string
      paymentPurpose: $Enums.PaymentPurpose
      status: $Enums.PaymentStatus
      razorpayOrderId: string | null
      razorpayPaymentId: string | null
      razorpaySignature: string | null
      paymentMethod: string | null
      failureReason: string | null
      createdAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["paymentEvent"]>
    composites: {}
  }

  type PaymentEventGetPayload<S extends boolean | null | undefined | PaymentEventDefaultArgs> = $Result.GetResult<Prisma.$PaymentEventPayload, S>

  type PaymentEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentEventCountAggregateInputType | true
    }

  export interface PaymentEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentEvent'], meta: { name: 'PaymentEvent' } }
    /**
     * Find zero or one PaymentEvent that matches the filter.
     * @param {PaymentEventFindUniqueArgs} args - Arguments to find a PaymentEvent
     * @example
     * // Get one PaymentEvent
     * const paymentEvent = await prisma.paymentEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentEventFindUniqueArgs>(args: SelectSubset<T, PaymentEventFindUniqueArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentEventFindUniqueOrThrowArgs} args - Arguments to find a PaymentEvent
     * @example
     * // Get one PaymentEvent
     * const paymentEvent = await prisma.paymentEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentEventFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentEventFindFirstArgs} args - Arguments to find a PaymentEvent
     * @example
     * // Get one PaymentEvent
     * const paymentEvent = await prisma.paymentEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentEventFindFirstArgs>(args?: SelectSubset<T, PaymentEventFindFirstArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentEventFindFirstOrThrowArgs} args - Arguments to find a PaymentEvent
     * @example
     * // Get one PaymentEvent
     * const paymentEvent = await prisma.paymentEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentEventFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentEvents
     * const paymentEvents = await prisma.paymentEvent.findMany()
     * 
     * // Get first 10 PaymentEvents
     * const paymentEvents = await prisma.paymentEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentEventWithIdOnly = await prisma.paymentEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentEventFindManyArgs>(args?: SelectSubset<T, PaymentEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentEvent.
     * @param {PaymentEventCreateArgs} args - Arguments to create a PaymentEvent.
     * @example
     * // Create one PaymentEvent
     * const PaymentEvent = await prisma.paymentEvent.create({
     *   data: {
     *     // ... data to create a PaymentEvent
     *   }
     * })
     * 
     */
    create<T extends PaymentEventCreateArgs>(args: SelectSubset<T, PaymentEventCreateArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentEvents.
     * @param {PaymentEventCreateManyArgs} args - Arguments to create many PaymentEvents.
     * @example
     * // Create many PaymentEvents
     * const paymentEvent = await prisma.paymentEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentEventCreateManyArgs>(args?: SelectSubset<T, PaymentEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentEvents and returns the data saved in the database.
     * @param {PaymentEventCreateManyAndReturnArgs} args - Arguments to create many PaymentEvents.
     * @example
     * // Create many PaymentEvents
     * const paymentEvent = await prisma.paymentEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentEvents and only return the `id`
     * const paymentEventWithIdOnly = await prisma.paymentEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentEventCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentEvent.
     * @param {PaymentEventDeleteArgs} args - Arguments to delete one PaymentEvent.
     * @example
     * // Delete one PaymentEvent
     * const PaymentEvent = await prisma.paymentEvent.delete({
     *   where: {
     *     // ... filter to delete one PaymentEvent
     *   }
     * })
     * 
     */
    delete<T extends PaymentEventDeleteArgs>(args: SelectSubset<T, PaymentEventDeleteArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentEvent.
     * @param {PaymentEventUpdateArgs} args - Arguments to update one PaymentEvent.
     * @example
     * // Update one PaymentEvent
     * const paymentEvent = await prisma.paymentEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentEventUpdateArgs>(args: SelectSubset<T, PaymentEventUpdateArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentEvents.
     * @param {PaymentEventDeleteManyArgs} args - Arguments to filter PaymentEvents to delete.
     * @example
     * // Delete a few PaymentEvents
     * const { count } = await prisma.paymentEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentEventDeleteManyArgs>(args?: SelectSubset<T, PaymentEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentEvents
     * const paymentEvent = await prisma.paymentEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentEventUpdateManyArgs>(args: SelectSubset<T, PaymentEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentEvents and returns the data updated in the database.
     * @param {PaymentEventUpdateManyAndReturnArgs} args - Arguments to update many PaymentEvents.
     * @example
     * // Update many PaymentEvents
     * const paymentEvent = await prisma.paymentEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentEvents and only return the `id`
     * const paymentEventWithIdOnly = await prisma.paymentEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentEventUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentEvent.
     * @param {PaymentEventUpsertArgs} args - Arguments to update or create a PaymentEvent.
     * @example
     * // Update or create a PaymentEvent
     * const paymentEvent = await prisma.paymentEvent.upsert({
     *   create: {
     *     // ... data to create a PaymentEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentEvent we want to update
     *   }
     * })
     */
    upsert<T extends PaymentEventUpsertArgs>(args: SelectSubset<T, PaymentEventUpsertArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentEventCountArgs} args - Arguments to filter PaymentEvents to count.
     * @example
     * // Count the number of PaymentEvents
     * const count = await prisma.paymentEvent.count({
     *   where: {
     *     // ... the filter for the PaymentEvents we want to count
     *   }
     * })
    **/
    count<T extends PaymentEventCountArgs>(
      args?: Subset<T, PaymentEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentEventAggregateArgs>(args: Subset<T, PaymentEventAggregateArgs>): Prisma.PrismaPromise<GetPaymentEventAggregateType<T>>

    /**
     * Group by PaymentEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentEventGroupByArgs['orderBy'] }
        : { orderBy?: PaymentEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentEvent model
   */
  readonly fields: PaymentEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pet<T extends PaymentEvent$petArgs<ExtArgs> = {}>(args?: Subset<T, PaymentEvent$petArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    qrCode<T extends PaymentEvent$qrCodeArgs<ExtArgs> = {}>(args?: Subset<T, PaymentEvent$qrCodeArgs<ExtArgs>>): Prisma__QRCodeClient<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends PaymentEvent$userArgs<ExtArgs> = {}>(args?: Subset<T, PaymentEvent$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    refunds<T extends PaymentEvent$refundsArgs<ExtArgs> = {}>(args?: Subset<T, PaymentEvent$refundsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentEvent model
   */
  interface PaymentEventFieldRefs {
    readonly id: FieldRef<"PaymentEvent", 'String'>
    readonly userId: FieldRef<"PaymentEvent", 'String'>
    readonly petId: FieldRef<"PaymentEvent", 'String'>
    readonly qrId: FieldRef<"PaymentEvent", 'String'>
    readonly amount: FieldRef<"PaymentEvent", 'Decimal'>
    readonly currency: FieldRef<"PaymentEvent", 'String'>
    readonly paymentPurpose: FieldRef<"PaymentEvent", 'PaymentPurpose'>
    readonly status: FieldRef<"PaymentEvent", 'PaymentStatus'>
    readonly razorpayOrderId: FieldRef<"PaymentEvent", 'String'>
    readonly razorpayPaymentId: FieldRef<"PaymentEvent", 'String'>
    readonly razorpaySignature: FieldRef<"PaymentEvent", 'String'>
    readonly paymentMethod: FieldRef<"PaymentEvent", 'String'>
    readonly failureReason: FieldRef<"PaymentEvent", 'String'>
    readonly createdAt: FieldRef<"PaymentEvent", 'DateTime'>
    readonly completedAt: FieldRef<"PaymentEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentEvent findUnique
   */
  export type PaymentEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentEvent
     */
    omit?: PaymentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
    /**
     * Filter, which PaymentEvent to fetch.
     */
    where: PaymentEventWhereUniqueInput
  }

  /**
   * PaymentEvent findUniqueOrThrow
   */
  export type PaymentEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentEvent
     */
    omit?: PaymentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
    /**
     * Filter, which PaymentEvent to fetch.
     */
    where: PaymentEventWhereUniqueInput
  }

  /**
   * PaymentEvent findFirst
   */
  export type PaymentEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentEvent
     */
    omit?: PaymentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
    /**
     * Filter, which PaymentEvent to fetch.
     */
    where?: PaymentEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentEvents to fetch.
     */
    orderBy?: PaymentEventOrderByWithRelationInput | PaymentEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentEvents.
     */
    cursor?: PaymentEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentEvents.
     */
    distinct?: PaymentEventScalarFieldEnum | PaymentEventScalarFieldEnum[]
  }

  /**
   * PaymentEvent findFirstOrThrow
   */
  export type PaymentEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentEvent
     */
    omit?: PaymentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
    /**
     * Filter, which PaymentEvent to fetch.
     */
    where?: PaymentEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentEvents to fetch.
     */
    orderBy?: PaymentEventOrderByWithRelationInput | PaymentEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentEvents.
     */
    cursor?: PaymentEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentEvents.
     */
    distinct?: PaymentEventScalarFieldEnum | PaymentEventScalarFieldEnum[]
  }

  /**
   * PaymentEvent findMany
   */
  export type PaymentEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentEvent
     */
    omit?: PaymentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
    /**
     * Filter, which PaymentEvents to fetch.
     */
    where?: PaymentEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentEvents to fetch.
     */
    orderBy?: PaymentEventOrderByWithRelationInput | PaymentEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentEvents.
     */
    cursor?: PaymentEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentEvents.
     */
    skip?: number
    distinct?: PaymentEventScalarFieldEnum | PaymentEventScalarFieldEnum[]
  }

  /**
   * PaymentEvent create
   */
  export type PaymentEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentEvent
     */
    omit?: PaymentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentEvent.
     */
    data: XOR<PaymentEventCreateInput, PaymentEventUncheckedCreateInput>
  }

  /**
   * PaymentEvent createMany
   */
  export type PaymentEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentEvents.
     */
    data: PaymentEventCreateManyInput | PaymentEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentEvent createManyAndReturn
   */
  export type PaymentEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentEvent
     */
    omit?: PaymentEventOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentEvents.
     */
    data: PaymentEventCreateManyInput | PaymentEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentEvent update
   */
  export type PaymentEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentEvent
     */
    omit?: PaymentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentEvent.
     */
    data: XOR<PaymentEventUpdateInput, PaymentEventUncheckedUpdateInput>
    /**
     * Choose, which PaymentEvent to update.
     */
    where: PaymentEventWhereUniqueInput
  }

  /**
   * PaymentEvent updateMany
   */
  export type PaymentEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentEvents.
     */
    data: XOR<PaymentEventUpdateManyMutationInput, PaymentEventUncheckedUpdateManyInput>
    /**
     * Filter which PaymentEvents to update
     */
    where?: PaymentEventWhereInput
    /**
     * Limit how many PaymentEvents to update.
     */
    limit?: number
  }

  /**
   * PaymentEvent updateManyAndReturn
   */
  export type PaymentEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentEvent
     */
    omit?: PaymentEventOmit<ExtArgs> | null
    /**
     * The data used to update PaymentEvents.
     */
    data: XOR<PaymentEventUpdateManyMutationInput, PaymentEventUncheckedUpdateManyInput>
    /**
     * Filter which PaymentEvents to update
     */
    where?: PaymentEventWhereInput
    /**
     * Limit how many PaymentEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentEvent upsert
   */
  export type PaymentEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentEvent
     */
    omit?: PaymentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentEvent to update in case it exists.
     */
    where: PaymentEventWhereUniqueInput
    /**
     * In case the PaymentEvent found by the `where` argument doesn't exist, create a new PaymentEvent with this data.
     */
    create: XOR<PaymentEventCreateInput, PaymentEventUncheckedCreateInput>
    /**
     * In case the PaymentEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentEventUpdateInput, PaymentEventUncheckedUpdateInput>
  }

  /**
   * PaymentEvent delete
   */
  export type PaymentEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentEvent
     */
    omit?: PaymentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
    /**
     * Filter which PaymentEvent to delete.
     */
    where: PaymentEventWhereUniqueInput
  }

  /**
   * PaymentEvent deleteMany
   */
  export type PaymentEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentEvents to delete
     */
    where?: PaymentEventWhereInput
    /**
     * Limit how many PaymentEvents to delete.
     */
    limit?: number
  }

  /**
   * PaymentEvent.pet
   */
  export type PaymentEvent$petArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    where?: PetWhereInput
  }

  /**
   * PaymentEvent.qrCode
   */
  export type PaymentEvent$qrCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
    where?: QRCodeWhereInput
  }

  /**
   * PaymentEvent.user
   */
  export type PaymentEvent$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PaymentEvent.refunds
   */
  export type PaymentEvent$refundsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    where?: RefundWhereInput
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    cursor?: RefundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * PaymentEvent without action
   */
  export type PaymentEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentEvent
     */
    omit?: PaymentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
  }


  /**
   * Model LocationTrack
   */

  export type AggregateLocationTrack = {
    _count: LocationTrackCountAggregateOutputType | null
    _avg: LocationTrackAvgAggregateOutputType | null
    _sum: LocationTrackSumAggregateOutputType | null
    _min: LocationTrackMinAggregateOutputType | null
    _max: LocationTrackMaxAggregateOutputType | null
  }

  export type LocationTrackAvgAggregateOutputType = {
    accuracy: Decimal | null
  }

  export type LocationTrackSumAggregateOutputType = {
    accuracy: Decimal | null
  }

  export type LocationTrackMinAggregateOutputType = {
    id: string | null
    userId: string | null
    locationType: $Enums.LocationType | null
    position: string | null
    accuracy: Decimal | null
    locationName: string | null
    countryCode: string | null
    state: string | null
    city: string | null
    ipAddress: string | null
    timestamp: Date | null
  }

  export type LocationTrackMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    locationType: $Enums.LocationType | null
    position: string | null
    accuracy: Decimal | null
    locationName: string | null
    countryCode: string | null
    state: string | null
    city: string | null
    ipAddress: string | null
    timestamp: Date | null
  }

  export type LocationTrackCountAggregateOutputType = {
    id: number
    userId: number
    locationType: number
    position: number
    accuracy: number
    locationName: number
    countryCode: number
    state: number
    city: number
    ipAddress: number
    deviceInfo: number
    timestamp: number
    _all: number
  }


  export type LocationTrackAvgAggregateInputType = {
    accuracy?: true
  }

  export type LocationTrackSumAggregateInputType = {
    accuracy?: true
  }

  export type LocationTrackMinAggregateInputType = {
    id?: true
    userId?: true
    locationType?: true
    position?: true
    accuracy?: true
    locationName?: true
    countryCode?: true
    state?: true
    city?: true
    ipAddress?: true
    timestamp?: true
  }

  export type LocationTrackMaxAggregateInputType = {
    id?: true
    userId?: true
    locationType?: true
    position?: true
    accuracy?: true
    locationName?: true
    countryCode?: true
    state?: true
    city?: true
    ipAddress?: true
    timestamp?: true
  }

  export type LocationTrackCountAggregateInputType = {
    id?: true
    userId?: true
    locationType?: true
    position?: true
    accuracy?: true
    locationName?: true
    countryCode?: true
    state?: true
    city?: true
    ipAddress?: true
    deviceInfo?: true
    timestamp?: true
    _all?: true
  }

  export type LocationTrackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationTrack to aggregate.
     */
    where?: LocationTrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationTracks to fetch.
     */
    orderBy?: LocationTrackOrderByWithRelationInput | LocationTrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationTrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationTracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationTracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocationTracks
    **/
    _count?: true | LocationTrackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationTrackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationTrackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationTrackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationTrackMaxAggregateInputType
  }

  export type GetLocationTrackAggregateType<T extends LocationTrackAggregateArgs> = {
        [P in keyof T & keyof AggregateLocationTrack]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocationTrack[P]>
      : GetScalarType<T[P], AggregateLocationTrack[P]>
  }




  export type LocationTrackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationTrackWhereInput
    orderBy?: LocationTrackOrderByWithAggregationInput | LocationTrackOrderByWithAggregationInput[]
    by: LocationTrackScalarFieldEnum[] | LocationTrackScalarFieldEnum
    having?: LocationTrackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationTrackCountAggregateInputType | true
    _avg?: LocationTrackAvgAggregateInputType
    _sum?: LocationTrackSumAggregateInputType
    _min?: LocationTrackMinAggregateInputType
    _max?: LocationTrackMaxAggregateInputType
  }

  export type LocationTrackGroupByOutputType = {
    id: string
    userId: string | null
    locationType: $Enums.LocationType
    position: string | null
    accuracy: Decimal | null
    locationName: string | null
    countryCode: string | null
    state: string | null
    city: string | null
    ipAddress: string | null
    deviceInfo: JsonValue | null
    timestamp: Date
    _count: LocationTrackCountAggregateOutputType | null
    _avg: LocationTrackAvgAggregateOutputType | null
    _sum: LocationTrackSumAggregateOutputType | null
    _min: LocationTrackMinAggregateOutputType | null
    _max: LocationTrackMaxAggregateOutputType | null
  }

  type GetLocationTrackGroupByPayload<T extends LocationTrackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationTrackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationTrackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationTrackGroupByOutputType[P]>
            : GetScalarType<T[P], LocationTrackGroupByOutputType[P]>
        }
      >
    >


  export type LocationTrackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    locationType?: boolean
    position?: boolean
    accuracy?: boolean
    locationName?: boolean
    countryCode?: boolean
    state?: boolean
    city?: boolean
    ipAddress?: boolean
    deviceInfo?: boolean
    timestamp?: boolean
    user?: boolean | LocationTrack$userArgs<ExtArgs>
  }, ExtArgs["result"]["locationTrack"]>

  export type LocationTrackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    locationType?: boolean
    position?: boolean
    accuracy?: boolean
    locationName?: boolean
    countryCode?: boolean
    state?: boolean
    city?: boolean
    ipAddress?: boolean
    deviceInfo?: boolean
    timestamp?: boolean
    user?: boolean | LocationTrack$userArgs<ExtArgs>
  }, ExtArgs["result"]["locationTrack"]>

  export type LocationTrackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    locationType?: boolean
    position?: boolean
    accuracy?: boolean
    locationName?: boolean
    countryCode?: boolean
    state?: boolean
    city?: boolean
    ipAddress?: boolean
    deviceInfo?: boolean
    timestamp?: boolean
    user?: boolean | LocationTrack$userArgs<ExtArgs>
  }, ExtArgs["result"]["locationTrack"]>

  export type LocationTrackSelectScalar = {
    id?: boolean
    userId?: boolean
    locationType?: boolean
    position?: boolean
    accuracy?: boolean
    locationName?: boolean
    countryCode?: boolean
    state?: boolean
    city?: boolean
    ipAddress?: boolean
    deviceInfo?: boolean
    timestamp?: boolean
  }

  export type LocationTrackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "locationType" | "position" | "accuracy" | "locationName" | "countryCode" | "state" | "city" | "ipAddress" | "deviceInfo" | "timestamp", ExtArgs["result"]["locationTrack"]>
  export type LocationTrackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | LocationTrack$userArgs<ExtArgs>
  }
  export type LocationTrackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | LocationTrack$userArgs<ExtArgs>
  }
  export type LocationTrackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | LocationTrack$userArgs<ExtArgs>
  }

  export type $LocationTrackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LocationTrack"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      locationType: $Enums.LocationType
      position: string | null
      accuracy: Prisma.Decimal | null
      locationName: string | null
      countryCode: string | null
      state: string | null
      city: string | null
      ipAddress: string | null
      deviceInfo: Prisma.JsonValue | null
      timestamp: Date
    }, ExtArgs["result"]["locationTrack"]>
    composites: {}
  }

  type LocationTrackGetPayload<S extends boolean | null | undefined | LocationTrackDefaultArgs> = $Result.GetResult<Prisma.$LocationTrackPayload, S>

  type LocationTrackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationTrackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationTrackCountAggregateInputType | true
    }

  export interface LocationTrackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocationTrack'], meta: { name: 'LocationTrack' } }
    /**
     * Find zero or one LocationTrack that matches the filter.
     * @param {LocationTrackFindUniqueArgs} args - Arguments to find a LocationTrack
     * @example
     * // Get one LocationTrack
     * const locationTrack = await prisma.locationTrack.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationTrackFindUniqueArgs>(args: SelectSubset<T, LocationTrackFindUniqueArgs<ExtArgs>>): Prisma__LocationTrackClient<$Result.GetResult<Prisma.$LocationTrackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LocationTrack that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationTrackFindUniqueOrThrowArgs} args - Arguments to find a LocationTrack
     * @example
     * // Get one LocationTrack
     * const locationTrack = await prisma.locationTrack.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationTrackFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationTrackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationTrackClient<$Result.GetResult<Prisma.$LocationTrackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocationTrack that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationTrackFindFirstArgs} args - Arguments to find a LocationTrack
     * @example
     * // Get one LocationTrack
     * const locationTrack = await prisma.locationTrack.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationTrackFindFirstArgs>(args?: SelectSubset<T, LocationTrackFindFirstArgs<ExtArgs>>): Prisma__LocationTrackClient<$Result.GetResult<Prisma.$LocationTrackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocationTrack that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationTrackFindFirstOrThrowArgs} args - Arguments to find a LocationTrack
     * @example
     * // Get one LocationTrack
     * const locationTrack = await prisma.locationTrack.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationTrackFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationTrackFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationTrackClient<$Result.GetResult<Prisma.$LocationTrackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LocationTracks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationTrackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocationTracks
     * const locationTracks = await prisma.locationTrack.findMany()
     * 
     * // Get first 10 LocationTracks
     * const locationTracks = await prisma.locationTrack.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationTrackWithIdOnly = await prisma.locationTrack.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationTrackFindManyArgs>(args?: SelectSubset<T, LocationTrackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationTrackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LocationTrack.
     * @param {LocationTrackCreateArgs} args - Arguments to create a LocationTrack.
     * @example
     * // Create one LocationTrack
     * const LocationTrack = await prisma.locationTrack.create({
     *   data: {
     *     // ... data to create a LocationTrack
     *   }
     * })
     * 
     */
    create<T extends LocationTrackCreateArgs>(args: SelectSubset<T, LocationTrackCreateArgs<ExtArgs>>): Prisma__LocationTrackClient<$Result.GetResult<Prisma.$LocationTrackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LocationTracks.
     * @param {LocationTrackCreateManyArgs} args - Arguments to create many LocationTracks.
     * @example
     * // Create many LocationTracks
     * const locationTrack = await prisma.locationTrack.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationTrackCreateManyArgs>(args?: SelectSubset<T, LocationTrackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LocationTracks and returns the data saved in the database.
     * @param {LocationTrackCreateManyAndReturnArgs} args - Arguments to create many LocationTracks.
     * @example
     * // Create many LocationTracks
     * const locationTrack = await prisma.locationTrack.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LocationTracks and only return the `id`
     * const locationTrackWithIdOnly = await prisma.locationTrack.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationTrackCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationTrackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationTrackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LocationTrack.
     * @param {LocationTrackDeleteArgs} args - Arguments to delete one LocationTrack.
     * @example
     * // Delete one LocationTrack
     * const LocationTrack = await prisma.locationTrack.delete({
     *   where: {
     *     // ... filter to delete one LocationTrack
     *   }
     * })
     * 
     */
    delete<T extends LocationTrackDeleteArgs>(args: SelectSubset<T, LocationTrackDeleteArgs<ExtArgs>>): Prisma__LocationTrackClient<$Result.GetResult<Prisma.$LocationTrackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LocationTrack.
     * @param {LocationTrackUpdateArgs} args - Arguments to update one LocationTrack.
     * @example
     * // Update one LocationTrack
     * const locationTrack = await prisma.locationTrack.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationTrackUpdateArgs>(args: SelectSubset<T, LocationTrackUpdateArgs<ExtArgs>>): Prisma__LocationTrackClient<$Result.GetResult<Prisma.$LocationTrackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LocationTracks.
     * @param {LocationTrackDeleteManyArgs} args - Arguments to filter LocationTracks to delete.
     * @example
     * // Delete a few LocationTracks
     * const { count } = await prisma.locationTrack.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationTrackDeleteManyArgs>(args?: SelectSubset<T, LocationTrackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocationTracks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationTrackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocationTracks
     * const locationTrack = await prisma.locationTrack.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationTrackUpdateManyArgs>(args: SelectSubset<T, LocationTrackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocationTracks and returns the data updated in the database.
     * @param {LocationTrackUpdateManyAndReturnArgs} args - Arguments to update many LocationTracks.
     * @example
     * // Update many LocationTracks
     * const locationTrack = await prisma.locationTrack.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LocationTracks and only return the `id`
     * const locationTrackWithIdOnly = await prisma.locationTrack.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationTrackUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationTrackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationTrackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LocationTrack.
     * @param {LocationTrackUpsertArgs} args - Arguments to update or create a LocationTrack.
     * @example
     * // Update or create a LocationTrack
     * const locationTrack = await prisma.locationTrack.upsert({
     *   create: {
     *     // ... data to create a LocationTrack
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocationTrack we want to update
     *   }
     * })
     */
    upsert<T extends LocationTrackUpsertArgs>(args: SelectSubset<T, LocationTrackUpsertArgs<ExtArgs>>): Prisma__LocationTrackClient<$Result.GetResult<Prisma.$LocationTrackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LocationTracks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationTrackCountArgs} args - Arguments to filter LocationTracks to count.
     * @example
     * // Count the number of LocationTracks
     * const count = await prisma.locationTrack.count({
     *   where: {
     *     // ... the filter for the LocationTracks we want to count
     *   }
     * })
    **/
    count<T extends LocationTrackCountArgs>(
      args?: Subset<T, LocationTrackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationTrackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocationTrack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationTrackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationTrackAggregateArgs>(args: Subset<T, LocationTrackAggregateArgs>): Prisma.PrismaPromise<GetLocationTrackAggregateType<T>>

    /**
     * Group by LocationTrack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationTrackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationTrackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationTrackGroupByArgs['orderBy'] }
        : { orderBy?: LocationTrackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationTrackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationTrackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocationTrack model
   */
  readonly fields: LocationTrackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocationTrack.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationTrackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends LocationTrack$userArgs<ExtArgs> = {}>(args?: Subset<T, LocationTrack$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LocationTrack model
   */
  interface LocationTrackFieldRefs {
    readonly id: FieldRef<"LocationTrack", 'String'>
    readonly userId: FieldRef<"LocationTrack", 'String'>
    readonly locationType: FieldRef<"LocationTrack", 'LocationType'>
    readonly position: FieldRef<"LocationTrack", 'String'>
    readonly accuracy: FieldRef<"LocationTrack", 'Decimal'>
    readonly locationName: FieldRef<"LocationTrack", 'String'>
    readonly countryCode: FieldRef<"LocationTrack", 'String'>
    readonly state: FieldRef<"LocationTrack", 'String'>
    readonly city: FieldRef<"LocationTrack", 'String'>
    readonly ipAddress: FieldRef<"LocationTrack", 'String'>
    readonly deviceInfo: FieldRef<"LocationTrack", 'Json'>
    readonly timestamp: FieldRef<"LocationTrack", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LocationTrack findUnique
   */
  export type LocationTrackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationTrack
     */
    select?: LocationTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationTrack
     */
    omit?: LocationTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationTrackInclude<ExtArgs> | null
    /**
     * Filter, which LocationTrack to fetch.
     */
    where: LocationTrackWhereUniqueInput
  }

  /**
   * LocationTrack findUniqueOrThrow
   */
  export type LocationTrackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationTrack
     */
    select?: LocationTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationTrack
     */
    omit?: LocationTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationTrackInclude<ExtArgs> | null
    /**
     * Filter, which LocationTrack to fetch.
     */
    where: LocationTrackWhereUniqueInput
  }

  /**
   * LocationTrack findFirst
   */
  export type LocationTrackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationTrack
     */
    select?: LocationTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationTrack
     */
    omit?: LocationTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationTrackInclude<ExtArgs> | null
    /**
     * Filter, which LocationTrack to fetch.
     */
    where?: LocationTrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationTracks to fetch.
     */
    orderBy?: LocationTrackOrderByWithRelationInput | LocationTrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationTracks.
     */
    cursor?: LocationTrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationTracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationTracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationTracks.
     */
    distinct?: LocationTrackScalarFieldEnum | LocationTrackScalarFieldEnum[]
  }

  /**
   * LocationTrack findFirstOrThrow
   */
  export type LocationTrackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationTrack
     */
    select?: LocationTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationTrack
     */
    omit?: LocationTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationTrackInclude<ExtArgs> | null
    /**
     * Filter, which LocationTrack to fetch.
     */
    where?: LocationTrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationTracks to fetch.
     */
    orderBy?: LocationTrackOrderByWithRelationInput | LocationTrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationTracks.
     */
    cursor?: LocationTrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationTracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationTracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationTracks.
     */
    distinct?: LocationTrackScalarFieldEnum | LocationTrackScalarFieldEnum[]
  }

  /**
   * LocationTrack findMany
   */
  export type LocationTrackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationTrack
     */
    select?: LocationTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationTrack
     */
    omit?: LocationTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationTrackInclude<ExtArgs> | null
    /**
     * Filter, which LocationTracks to fetch.
     */
    where?: LocationTrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationTracks to fetch.
     */
    orderBy?: LocationTrackOrderByWithRelationInput | LocationTrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocationTracks.
     */
    cursor?: LocationTrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationTracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationTracks.
     */
    skip?: number
    distinct?: LocationTrackScalarFieldEnum | LocationTrackScalarFieldEnum[]
  }

  /**
   * LocationTrack create
   */
  export type LocationTrackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationTrack
     */
    select?: LocationTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationTrack
     */
    omit?: LocationTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationTrackInclude<ExtArgs> | null
    /**
     * The data needed to create a LocationTrack.
     */
    data: XOR<LocationTrackCreateInput, LocationTrackUncheckedCreateInput>
  }

  /**
   * LocationTrack createMany
   */
  export type LocationTrackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocationTracks.
     */
    data: LocationTrackCreateManyInput | LocationTrackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LocationTrack createManyAndReturn
   */
  export type LocationTrackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationTrack
     */
    select?: LocationTrackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LocationTrack
     */
    omit?: LocationTrackOmit<ExtArgs> | null
    /**
     * The data used to create many LocationTracks.
     */
    data: LocationTrackCreateManyInput | LocationTrackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationTrackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LocationTrack update
   */
  export type LocationTrackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationTrack
     */
    select?: LocationTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationTrack
     */
    omit?: LocationTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationTrackInclude<ExtArgs> | null
    /**
     * The data needed to update a LocationTrack.
     */
    data: XOR<LocationTrackUpdateInput, LocationTrackUncheckedUpdateInput>
    /**
     * Choose, which LocationTrack to update.
     */
    where: LocationTrackWhereUniqueInput
  }

  /**
   * LocationTrack updateMany
   */
  export type LocationTrackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocationTracks.
     */
    data: XOR<LocationTrackUpdateManyMutationInput, LocationTrackUncheckedUpdateManyInput>
    /**
     * Filter which LocationTracks to update
     */
    where?: LocationTrackWhereInput
    /**
     * Limit how many LocationTracks to update.
     */
    limit?: number
  }

  /**
   * LocationTrack updateManyAndReturn
   */
  export type LocationTrackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationTrack
     */
    select?: LocationTrackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LocationTrack
     */
    omit?: LocationTrackOmit<ExtArgs> | null
    /**
     * The data used to update LocationTracks.
     */
    data: XOR<LocationTrackUpdateManyMutationInput, LocationTrackUncheckedUpdateManyInput>
    /**
     * Filter which LocationTracks to update
     */
    where?: LocationTrackWhereInput
    /**
     * Limit how many LocationTracks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationTrackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LocationTrack upsert
   */
  export type LocationTrackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationTrack
     */
    select?: LocationTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationTrack
     */
    omit?: LocationTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationTrackInclude<ExtArgs> | null
    /**
     * The filter to search for the LocationTrack to update in case it exists.
     */
    where: LocationTrackWhereUniqueInput
    /**
     * In case the LocationTrack found by the `where` argument doesn't exist, create a new LocationTrack with this data.
     */
    create: XOR<LocationTrackCreateInput, LocationTrackUncheckedCreateInput>
    /**
     * In case the LocationTrack was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationTrackUpdateInput, LocationTrackUncheckedUpdateInput>
  }

  /**
   * LocationTrack delete
   */
  export type LocationTrackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationTrack
     */
    select?: LocationTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationTrack
     */
    omit?: LocationTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationTrackInclude<ExtArgs> | null
    /**
     * Filter which LocationTrack to delete.
     */
    where: LocationTrackWhereUniqueInput
  }

  /**
   * LocationTrack deleteMany
   */
  export type LocationTrackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationTracks to delete
     */
    where?: LocationTrackWhereInput
    /**
     * Limit how many LocationTracks to delete.
     */
    limit?: number
  }

  /**
   * LocationTrack.user
   */
  export type LocationTrack$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LocationTrack without action
   */
  export type LocationTrackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationTrack
     */
    select?: LocationTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationTrack
     */
    omit?: LocationTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationTrackInclude<ExtArgs> | null
  }


  /**
   * Model NotificationPreference
   */

  export type AggregateNotificationPreference = {
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  export type NotificationPreferenceMinAggregateOutputType = {
    userId: string | null
    pushEnabled: boolean | null
    emailEnabled: boolean | null
    smsEnabled: boolean | null
    scanNotifications: boolean | null
    marketingNotifications: boolean | null
    quietHoursStart: Date | null
    quietHoursEnd: Date | null
    timezone: string | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceMaxAggregateOutputType = {
    userId: string | null
    pushEnabled: boolean | null
    emailEnabled: boolean | null
    smsEnabled: boolean | null
    scanNotifications: boolean | null
    marketingNotifications: boolean | null
    quietHoursStart: Date | null
    quietHoursEnd: Date | null
    timezone: string | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceCountAggregateOutputType = {
    userId: number
    pushEnabled: number
    emailEnabled: number
    smsEnabled: number
    scanNotifications: number
    marketingNotifications: number
    quietHoursStart: number
    quietHoursEnd: number
    timezone: number
    updatedAt: number
    _all: number
  }


  export type NotificationPreferenceMinAggregateInputType = {
    userId?: true
    pushEnabled?: true
    emailEnabled?: true
    smsEnabled?: true
    scanNotifications?: true
    marketingNotifications?: true
    quietHoursStart?: true
    quietHoursEnd?: true
    timezone?: true
    updatedAt?: true
  }

  export type NotificationPreferenceMaxAggregateInputType = {
    userId?: true
    pushEnabled?: true
    emailEnabled?: true
    smsEnabled?: true
    scanNotifications?: true
    marketingNotifications?: true
    quietHoursStart?: true
    quietHoursEnd?: true
    timezone?: true
    updatedAt?: true
  }

  export type NotificationPreferenceCountAggregateInputType = {
    userId?: true
    pushEnabled?: true
    emailEnabled?: true
    smsEnabled?: true
    scanNotifications?: true
    marketingNotifications?: true
    quietHoursStart?: true
    quietHoursEnd?: true
    timezone?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreference to aggregate.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPreferences
    **/
    _count?: true | NotificationPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type GetNotificationPreferenceAggregateType<T extends NotificationPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPreference[P]>
      : GetScalarType<T[P], AggregateNotificationPreference[P]>
  }




  export type NotificationPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
    orderBy?: NotificationPreferenceOrderByWithAggregationInput | NotificationPreferenceOrderByWithAggregationInput[]
    by: NotificationPreferenceScalarFieldEnum[] | NotificationPreferenceScalarFieldEnum
    having?: NotificationPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPreferenceCountAggregateInputType | true
    _min?: NotificationPreferenceMinAggregateInputType
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type NotificationPreferenceGroupByOutputType = {
    userId: string
    pushEnabled: boolean
    emailEnabled: boolean
    smsEnabled: boolean
    scanNotifications: boolean
    marketingNotifications: boolean
    quietHoursStart: Date | null
    quietHoursEnd: Date | null
    timezone: string
    updatedAt: Date
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  type GetNotificationPreferenceGroupByPayload<T extends NotificationPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    pushEnabled?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    scanNotifications?: boolean
    marketingNotifications?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    timezone?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    pushEnabled?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    scanNotifications?: boolean
    marketingNotifications?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    timezone?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    pushEnabled?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    scanNotifications?: boolean
    marketingNotifications?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    timezone?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectScalar = {
    userId?: boolean
    pushEnabled?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    scanNotifications?: boolean
    marketingNotifications?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    timezone?: boolean
    updatedAt?: boolean
  }

  export type NotificationPreferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "pushEnabled" | "emailEnabled" | "smsEnabled" | "scanNotifications" | "marketingNotifications" | "quietHoursStart" | "quietHoursEnd" | "timezone" | "updatedAt", ExtArgs["result"]["notificationPreference"]>
  export type NotificationPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      pushEnabled: boolean
      emailEnabled: boolean
      smsEnabled: boolean
      scanNotifications: boolean
      marketingNotifications: boolean
      quietHoursStart: Date | null
      quietHoursEnd: Date | null
      timezone: string
      updatedAt: Date
    }, ExtArgs["result"]["notificationPreference"]>
    composites: {}
  }

  type NotificationPreferenceGetPayload<S extends boolean | null | undefined | NotificationPreferenceDefaultArgs> = $Result.GetResult<Prisma.$NotificationPreferencePayload, S>

  type NotificationPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationPreferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationPreferenceCountAggregateInputType | true
    }

  export interface NotificationPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPreference'], meta: { name: 'NotificationPreference' } }
    /**
     * Find zero or one NotificationPreference that matches the filter.
     * @param {NotificationPreferenceFindUniqueArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPreferenceFindUniqueArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationPreference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationPreferenceFindUniqueOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPreferenceFindFirstArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany()
     * 
     * // Get first 10 NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const notificationPreferenceWithUserIdOnly = await prisma.notificationPreference.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends NotificationPreferenceFindManyArgs>(args?: SelectSubset<T, NotificationPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationPreference.
     * @param {NotificationPreferenceCreateArgs} args - Arguments to create a NotificationPreference.
     * @example
     * // Create one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.create({
     *   data: {
     *     // ... data to create a NotificationPreference
     *   }
     * })
     * 
     */
    create<T extends NotificationPreferenceCreateArgs>(args: SelectSubset<T, NotificationPreferenceCreateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationPreferences.
     * @param {NotificationPreferenceCreateManyArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationPreferenceCreateManyArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPreferences and returns the data saved in the database.
     * @param {NotificationPreferenceCreateManyAndReturnArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPreferences and only return the `userId`
     * const notificationPreferenceWithUserIdOnly = await prisma.notificationPreference.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationPreference.
     * @param {NotificationPreferenceDeleteArgs} args - Arguments to delete one NotificationPreference.
     * @example
     * // Delete one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.delete({
     *   where: {
     *     // ... filter to delete one NotificationPreference
     *   }
     * })
     * 
     */
    delete<T extends NotificationPreferenceDeleteArgs>(args: SelectSubset<T, NotificationPreferenceDeleteArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationPreference.
     * @param {NotificationPreferenceUpdateArgs} args - Arguments to update one NotificationPreference.
     * @example
     * // Update one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationPreferenceUpdateArgs>(args: SelectSubset<T, NotificationPreferenceUpdateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationPreferences.
     * @param {NotificationPreferenceDeleteManyArgs} args - Arguments to filter NotificationPreferences to delete.
     * @example
     * // Delete a few NotificationPreferences
     * const { count } = await prisma.notificationPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationPreferenceDeleteManyArgs>(args?: SelectSubset<T, NotificationPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationPreferenceUpdateManyArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences and returns the data updated in the database.
     * @param {NotificationPreferenceUpdateManyAndReturnArgs} args - Arguments to update many NotificationPreferences.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationPreferences and only return the `userId`
     * const notificationPreferenceWithUserIdOnly = await prisma.notificationPreference.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationPreferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationPreference.
     * @param {NotificationPreferenceUpsertArgs} args - Arguments to update or create a NotificationPreference.
     * @example
     * // Update or create a NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.upsert({
     *   create: {
     *     // ... data to create a NotificationPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPreference we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPreferenceUpsertArgs>(args: SelectSubset<T, NotificationPreferenceUpsertArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceCountArgs} args - Arguments to filter NotificationPreferences to count.
     * @example
     * // Count the number of NotificationPreferences
     * const count = await prisma.notificationPreference.count({
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to count
     *   }
     * })
    **/
    count<T extends NotificationPreferenceCountArgs>(
      args?: Subset<T, NotificationPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPreferenceAggregateArgs>(args: Subset<T, NotificationPreferenceAggregateArgs>): Prisma.PrismaPromise<GetNotificationPreferenceAggregateType<T>>

    /**
     * Group by NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationPreference model
   */
  readonly fields: NotificationPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationPreference model
   */
  interface NotificationPreferenceFieldRefs {
    readonly userId: FieldRef<"NotificationPreference", 'String'>
    readonly pushEnabled: FieldRef<"NotificationPreference", 'Boolean'>
    readonly emailEnabled: FieldRef<"NotificationPreference", 'Boolean'>
    readonly smsEnabled: FieldRef<"NotificationPreference", 'Boolean'>
    readonly scanNotifications: FieldRef<"NotificationPreference", 'Boolean'>
    readonly marketingNotifications: FieldRef<"NotificationPreference", 'Boolean'>
    readonly quietHoursStart: FieldRef<"NotificationPreference", 'DateTime'>
    readonly quietHoursEnd: FieldRef<"NotificationPreference", 'DateTime'>
    readonly timezone: FieldRef<"NotificationPreference", 'String'>
    readonly updatedAt: FieldRef<"NotificationPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationPreference findUnique
   */
  export type NotificationPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findUniqueOrThrow
   */
  export type NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findFirst
   */
  export type NotificationPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findFirstOrThrow
   */
  export type NotificationPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findMany
   */
  export type NotificationPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference create
   */
  export type NotificationPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationPreference.
     */
    data: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
  }

  /**
   * NotificationPreference createMany
   */
  export type NotificationPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationPreference createManyAndReturn
   */
  export type NotificationPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference update
   */
  export type NotificationPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationPreference.
     */
    data: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
    /**
     * Choose, which NotificationPreference to update.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference updateMany
   */
  export type NotificationPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number
  }

  /**
   * NotificationPreference updateManyAndReturn
   */
  export type NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference upsert
   */
  export type NotificationPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationPreference to update in case it exists.
     */
    where: NotificationPreferenceWhereUniqueInput
    /**
     * In case the NotificationPreference found by the `where` argument doesn't exist, create a new NotificationPreference with this data.
     */
    create: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
    /**
     * In case the NotificationPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
  }

  /**
   * NotificationPreference delete
   */
  export type NotificationPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter which NotificationPreference to delete.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference deleteMany
   */
  export type NotificationPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreferences to delete
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to delete.
     */
    limit?: number
  }

  /**
   * NotificationPreference without action
   */
  export type NotificationPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    petId: string | null
    qrScanId: string | null
    notificationType: $Enums.NotificationType | null
    title: string | null
    message: string | null
    createdAt: Date | null
    sentAt: Date | null
    readAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    petId: string | null
    qrScanId: string | null
    notificationType: $Enums.NotificationType | null
    title: string | null
    message: string | null
    createdAt: Date | null
    sentAt: Date | null
    readAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    petId: number
    qrScanId: number
    notificationType: number
    title: number
    message: number
    channels: number
    deliveryStatus: number
    metadata: number
    createdAt: number
    sentAt: number
    readAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    petId?: true
    qrScanId?: true
    notificationType?: true
    title?: true
    message?: true
    createdAt?: true
    sentAt?: true
    readAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    petId?: true
    qrScanId?: true
    notificationType?: true
    title?: true
    message?: true
    createdAt?: true
    sentAt?: true
    readAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    petId?: true
    qrScanId?: true
    notificationType?: true
    title?: true
    message?: true
    channels?: true
    deliveryStatus?: true
    metadata?: true
    createdAt?: true
    sentAt?: true
    readAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string | null
    petId: string | null
    qrScanId: string | null
    notificationType: $Enums.NotificationType
    title: string
    message: string
    channels: string[]
    deliveryStatus: JsonValue | null
    metadata: JsonValue | null
    createdAt: Date
    sentAt: Date | null
    readAt: Date | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    petId?: boolean
    qrScanId?: boolean
    notificationType?: boolean
    title?: boolean
    message?: boolean
    channels?: boolean
    deliveryStatus?: boolean
    metadata?: boolean
    createdAt?: boolean
    sentAt?: boolean
    readAt?: boolean
    pet?: boolean | Notification$petArgs<ExtArgs>
    user?: boolean | Notification$userArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    petId?: boolean
    qrScanId?: boolean
    notificationType?: boolean
    title?: boolean
    message?: boolean
    channels?: boolean
    deliveryStatus?: boolean
    metadata?: boolean
    createdAt?: boolean
    sentAt?: boolean
    readAt?: boolean
    pet?: boolean | Notification$petArgs<ExtArgs>
    user?: boolean | Notification$userArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    petId?: boolean
    qrScanId?: boolean
    notificationType?: boolean
    title?: boolean
    message?: boolean
    channels?: boolean
    deliveryStatus?: boolean
    metadata?: boolean
    createdAt?: boolean
    sentAt?: boolean
    readAt?: boolean
    pet?: boolean | Notification$petArgs<ExtArgs>
    user?: boolean | Notification$userArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    petId?: boolean
    qrScanId?: boolean
    notificationType?: boolean
    title?: boolean
    message?: boolean
    channels?: boolean
    deliveryStatus?: boolean
    metadata?: boolean
    createdAt?: boolean
    sentAt?: boolean
    readAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "petId" | "qrScanId" | "notificationType" | "title" | "message" | "channels" | "deliveryStatus" | "metadata" | "createdAt" | "sentAt" | "readAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | Notification$petArgs<ExtArgs>
    user?: boolean | Notification$userArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | Notification$petArgs<ExtArgs>
    user?: boolean | Notification$userArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | Notification$petArgs<ExtArgs>
    user?: boolean | Notification$userArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      pet: Prisma.$PetPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      petId: string | null
      qrScanId: string | null
      notificationType: $Enums.NotificationType
      title: string
      message: string
      channels: string[]
      deliveryStatus: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      sentAt: Date | null
      readAt: Date | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pet<T extends Notification$petArgs<ExtArgs> = {}>(args?: Subset<T, Notification$petArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends Notification$userArgs<ExtArgs> = {}>(args?: Subset<T, Notification$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly petId: FieldRef<"Notification", 'String'>
    readonly qrScanId: FieldRef<"Notification", 'String'>
    readonly notificationType: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly channels: FieldRef<"Notification", 'String[]'>
    readonly deliveryStatus: FieldRef<"Notification", 'Json'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly sentAt: FieldRef<"Notification", 'DateTime'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.pet
   */
  export type Notification$petArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    where?: PetWhereInput
  }

  /**
   * Notification.user
   */
  export type Notification$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model DeviceToken
   */

  export type AggregateDeviceToken = {
    _count: DeviceTokenCountAggregateOutputType | null
    _min: DeviceTokenMinAggregateOutputType | null
    _max: DeviceTokenMaxAggregateOutputType | null
  }

  export type DeviceTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    deviceToken: string | null
    platform: $Enums.Platform | null
    isActive: boolean | null
    createdAt: Date | null
    lastUsedAt: Date | null
  }

  export type DeviceTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    deviceToken: string | null
    platform: $Enums.Platform | null
    isActive: boolean | null
    createdAt: Date | null
    lastUsedAt: Date | null
  }

  export type DeviceTokenCountAggregateOutputType = {
    id: number
    userId: number
    deviceToken: number
    platform: number
    deviceInfo: number
    isActive: number
    createdAt: number
    lastUsedAt: number
    _all: number
  }


  export type DeviceTokenMinAggregateInputType = {
    id?: true
    userId?: true
    deviceToken?: true
    platform?: true
    isActive?: true
    createdAt?: true
    lastUsedAt?: true
  }

  export type DeviceTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    deviceToken?: true
    platform?: true
    isActive?: true
    createdAt?: true
    lastUsedAt?: true
  }

  export type DeviceTokenCountAggregateInputType = {
    id?: true
    userId?: true
    deviceToken?: true
    platform?: true
    deviceInfo?: true
    isActive?: true
    createdAt?: true
    lastUsedAt?: true
    _all?: true
  }

  export type DeviceTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceToken to aggregate.
     */
    where?: DeviceTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTokens to fetch.
     */
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceTokens
    **/
    _count?: true | DeviceTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceTokenMaxAggregateInputType
  }

  export type GetDeviceTokenAggregateType<T extends DeviceTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceToken[P]>
      : GetScalarType<T[P], AggregateDeviceToken[P]>
  }




  export type DeviceTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceTokenWhereInput
    orderBy?: DeviceTokenOrderByWithAggregationInput | DeviceTokenOrderByWithAggregationInput[]
    by: DeviceTokenScalarFieldEnum[] | DeviceTokenScalarFieldEnum
    having?: DeviceTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceTokenCountAggregateInputType | true
    _min?: DeviceTokenMinAggregateInputType
    _max?: DeviceTokenMaxAggregateInputType
  }

  export type DeviceTokenGroupByOutputType = {
    id: string
    userId: string
    deviceToken: string
    platform: $Enums.Platform
    deviceInfo: JsonValue | null
    isActive: boolean
    createdAt: Date
    lastUsedAt: Date
    _count: DeviceTokenCountAggregateOutputType | null
    _min: DeviceTokenMinAggregateOutputType | null
    _max: DeviceTokenMaxAggregateOutputType | null
  }

  type GetDeviceTokenGroupByPayload<T extends DeviceTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceTokenGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceTokenGroupByOutputType[P]>
        }
      >
    >


  export type DeviceTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceToken?: boolean
    platform?: boolean
    deviceInfo?: boolean
    isActive?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceToken"]>

  export type DeviceTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceToken?: boolean
    platform?: boolean
    deviceInfo?: boolean
    isActive?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceToken"]>

  export type DeviceTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceToken?: boolean
    platform?: boolean
    deviceInfo?: boolean
    isActive?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceToken"]>

  export type DeviceTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    deviceToken?: boolean
    platform?: boolean
    deviceInfo?: boolean
    isActive?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
  }

  export type DeviceTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "deviceToken" | "platform" | "deviceInfo" | "isActive" | "createdAt" | "lastUsedAt", ExtArgs["result"]["deviceToken"]>
  export type DeviceTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeviceTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeviceTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DeviceTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      deviceToken: string
      platform: $Enums.Platform
      deviceInfo: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
      lastUsedAt: Date
    }, ExtArgs["result"]["deviceToken"]>
    composites: {}
  }

  type DeviceTokenGetPayload<S extends boolean | null | undefined | DeviceTokenDefaultArgs> = $Result.GetResult<Prisma.$DeviceTokenPayload, S>

  type DeviceTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceTokenCountAggregateInputType | true
    }

  export interface DeviceTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceToken'], meta: { name: 'DeviceToken' } }
    /**
     * Find zero or one DeviceToken that matches the filter.
     * @param {DeviceTokenFindUniqueArgs} args - Arguments to find a DeviceToken
     * @example
     * // Get one DeviceToken
     * const deviceToken = await prisma.deviceToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceTokenFindUniqueArgs>(args: SelectSubset<T, DeviceTokenFindUniqueArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceTokenFindUniqueOrThrowArgs} args - Arguments to find a DeviceToken
     * @example
     * // Get one DeviceToken
     * const deviceToken = await prisma.deviceToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenFindFirstArgs} args - Arguments to find a DeviceToken
     * @example
     * // Get one DeviceToken
     * const deviceToken = await prisma.deviceToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceTokenFindFirstArgs>(args?: SelectSubset<T, DeviceTokenFindFirstArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenFindFirstOrThrowArgs} args - Arguments to find a DeviceToken
     * @example
     * // Get one DeviceToken
     * const deviceToken = await prisma.deviceToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceTokens
     * const deviceTokens = await prisma.deviceToken.findMany()
     * 
     * // Get first 10 DeviceTokens
     * const deviceTokens = await prisma.deviceToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceTokenWithIdOnly = await prisma.deviceToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceTokenFindManyArgs>(args?: SelectSubset<T, DeviceTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceToken.
     * @param {DeviceTokenCreateArgs} args - Arguments to create a DeviceToken.
     * @example
     * // Create one DeviceToken
     * const DeviceToken = await prisma.deviceToken.create({
     *   data: {
     *     // ... data to create a DeviceToken
     *   }
     * })
     * 
     */
    create<T extends DeviceTokenCreateArgs>(args: SelectSubset<T, DeviceTokenCreateArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceTokens.
     * @param {DeviceTokenCreateManyArgs} args - Arguments to create many DeviceTokens.
     * @example
     * // Create many DeviceTokens
     * const deviceToken = await prisma.deviceToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceTokenCreateManyArgs>(args?: SelectSubset<T, DeviceTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceTokens and returns the data saved in the database.
     * @param {DeviceTokenCreateManyAndReturnArgs} args - Arguments to create many DeviceTokens.
     * @example
     * // Create many DeviceTokens
     * const deviceToken = await prisma.deviceToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceTokens and only return the `id`
     * const deviceTokenWithIdOnly = await prisma.deviceToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceToken.
     * @param {DeviceTokenDeleteArgs} args - Arguments to delete one DeviceToken.
     * @example
     * // Delete one DeviceToken
     * const DeviceToken = await prisma.deviceToken.delete({
     *   where: {
     *     // ... filter to delete one DeviceToken
     *   }
     * })
     * 
     */
    delete<T extends DeviceTokenDeleteArgs>(args: SelectSubset<T, DeviceTokenDeleteArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceToken.
     * @param {DeviceTokenUpdateArgs} args - Arguments to update one DeviceToken.
     * @example
     * // Update one DeviceToken
     * const deviceToken = await prisma.deviceToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceTokenUpdateArgs>(args: SelectSubset<T, DeviceTokenUpdateArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceTokens.
     * @param {DeviceTokenDeleteManyArgs} args - Arguments to filter DeviceTokens to delete.
     * @example
     * // Delete a few DeviceTokens
     * const { count } = await prisma.deviceToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceTokenDeleteManyArgs>(args?: SelectSubset<T, DeviceTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceTokens
     * const deviceToken = await prisma.deviceToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceTokenUpdateManyArgs>(args: SelectSubset<T, DeviceTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceTokens and returns the data updated in the database.
     * @param {DeviceTokenUpdateManyAndReturnArgs} args - Arguments to update many DeviceTokens.
     * @example
     * // Update many DeviceTokens
     * const deviceToken = await prisma.deviceToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceTokens and only return the `id`
     * const deviceTokenWithIdOnly = await prisma.deviceToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceToken.
     * @param {DeviceTokenUpsertArgs} args - Arguments to update or create a DeviceToken.
     * @example
     * // Update or create a DeviceToken
     * const deviceToken = await prisma.deviceToken.upsert({
     *   create: {
     *     // ... data to create a DeviceToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceToken we want to update
     *   }
     * })
     */
    upsert<T extends DeviceTokenUpsertArgs>(args: SelectSubset<T, DeviceTokenUpsertArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenCountArgs} args - Arguments to filter DeviceTokens to count.
     * @example
     * // Count the number of DeviceTokens
     * const count = await prisma.deviceToken.count({
     *   where: {
     *     // ... the filter for the DeviceTokens we want to count
     *   }
     * })
    **/
    count<T extends DeviceTokenCountArgs>(
      args?: Subset<T, DeviceTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceTokenAggregateArgs>(args: Subset<T, DeviceTokenAggregateArgs>): Prisma.PrismaPromise<GetDeviceTokenAggregateType<T>>

    /**
     * Group by DeviceToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceTokenGroupByArgs['orderBy'] }
        : { orderBy?: DeviceTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceToken model
   */
  readonly fields: DeviceTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceToken model
   */
  interface DeviceTokenFieldRefs {
    readonly id: FieldRef<"DeviceToken", 'String'>
    readonly userId: FieldRef<"DeviceToken", 'String'>
    readonly deviceToken: FieldRef<"DeviceToken", 'String'>
    readonly platform: FieldRef<"DeviceToken", 'Platform'>
    readonly deviceInfo: FieldRef<"DeviceToken", 'Json'>
    readonly isActive: FieldRef<"DeviceToken", 'Boolean'>
    readonly createdAt: FieldRef<"DeviceToken", 'DateTime'>
    readonly lastUsedAt: FieldRef<"DeviceToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeviceToken findUnique
   */
  export type DeviceTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceToken to fetch.
     */
    where: DeviceTokenWhereUniqueInput
  }

  /**
   * DeviceToken findUniqueOrThrow
   */
  export type DeviceTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceToken to fetch.
     */
    where: DeviceTokenWhereUniqueInput
  }

  /**
   * DeviceToken findFirst
   */
  export type DeviceTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceToken to fetch.
     */
    where?: DeviceTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTokens to fetch.
     */
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceTokens.
     */
    cursor?: DeviceTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceTokens.
     */
    distinct?: DeviceTokenScalarFieldEnum | DeviceTokenScalarFieldEnum[]
  }

  /**
   * DeviceToken findFirstOrThrow
   */
  export type DeviceTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceToken to fetch.
     */
    where?: DeviceTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTokens to fetch.
     */
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceTokens.
     */
    cursor?: DeviceTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceTokens.
     */
    distinct?: DeviceTokenScalarFieldEnum | DeviceTokenScalarFieldEnum[]
  }

  /**
   * DeviceToken findMany
   */
  export type DeviceTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTokens to fetch.
     */
    where?: DeviceTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTokens to fetch.
     */
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceTokens.
     */
    cursor?: DeviceTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTokens.
     */
    skip?: number
    distinct?: DeviceTokenScalarFieldEnum | DeviceTokenScalarFieldEnum[]
  }

  /**
   * DeviceToken create
   */
  export type DeviceTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceToken.
     */
    data: XOR<DeviceTokenCreateInput, DeviceTokenUncheckedCreateInput>
  }

  /**
   * DeviceToken createMany
   */
  export type DeviceTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceTokens.
     */
    data: DeviceTokenCreateManyInput | DeviceTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceToken createManyAndReturn
   */
  export type DeviceTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceTokens.
     */
    data: DeviceTokenCreateManyInput | DeviceTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceToken update
   */
  export type DeviceTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceToken.
     */
    data: XOR<DeviceTokenUpdateInput, DeviceTokenUncheckedUpdateInput>
    /**
     * Choose, which DeviceToken to update.
     */
    where: DeviceTokenWhereUniqueInput
  }

  /**
   * DeviceToken updateMany
   */
  export type DeviceTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceTokens.
     */
    data: XOR<DeviceTokenUpdateManyMutationInput, DeviceTokenUncheckedUpdateManyInput>
    /**
     * Filter which DeviceTokens to update
     */
    where?: DeviceTokenWhereInput
    /**
     * Limit how many DeviceTokens to update.
     */
    limit?: number
  }

  /**
   * DeviceToken updateManyAndReturn
   */
  export type DeviceTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * The data used to update DeviceTokens.
     */
    data: XOR<DeviceTokenUpdateManyMutationInput, DeviceTokenUncheckedUpdateManyInput>
    /**
     * Filter which DeviceTokens to update
     */
    where?: DeviceTokenWhereInput
    /**
     * Limit how many DeviceTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceToken upsert
   */
  export type DeviceTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceToken to update in case it exists.
     */
    where: DeviceTokenWhereUniqueInput
    /**
     * In case the DeviceToken found by the `where` argument doesn't exist, create a new DeviceToken with this data.
     */
    create: XOR<DeviceTokenCreateInput, DeviceTokenUncheckedCreateInput>
    /**
     * In case the DeviceToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceTokenUpdateInput, DeviceTokenUncheckedUpdateInput>
  }

  /**
   * DeviceToken delete
   */
  export type DeviceTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter which DeviceToken to delete.
     */
    where: DeviceTokenWhereUniqueInput
  }

  /**
   * DeviceToken deleteMany
   */
  export type DeviceTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceTokens to delete
     */
    where?: DeviceTokenWhereInput
    /**
     * Limit how many DeviceTokens to delete.
     */
    limit?: number
  }

  /**
   * DeviceToken without action
   */
  export type DeviceTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
  }


  /**
   * Model SupportTicket
   */

  export type AggregateSupportTicket = {
    _count: SupportTicketCountAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  export type SupportTicketMinAggregateOutputType = {
    id: string | null
    ticketNumber: string | null
    userId: string | null
    petId: string | null
    subject: string | null
    description: string | null
    category: $Enums.TicketCategory | null
    priority: $Enums.TicketPriority | null
    status: $Enums.TicketStatus | null
    assignedTo: string | null
    resolution: string | null
    createdAt: Date | null
    updatedAt: Date | null
    resolvedAt: Date | null
  }

  export type SupportTicketMaxAggregateOutputType = {
    id: string | null
    ticketNumber: string | null
    userId: string | null
    petId: string | null
    subject: string | null
    description: string | null
    category: $Enums.TicketCategory | null
    priority: $Enums.TicketPriority | null
    status: $Enums.TicketStatus | null
    assignedTo: string | null
    resolution: string | null
    createdAt: Date | null
    updatedAt: Date | null
    resolvedAt: Date | null
  }

  export type SupportTicketCountAggregateOutputType = {
    id: number
    ticketNumber: number
    userId: number
    petId: number
    subject: number
    description: number
    category: number
    priority: number
    status: number
    assignedTo: number
    resolution: number
    createdAt: number
    updatedAt: number
    resolvedAt: number
    _all: number
  }


  export type SupportTicketMinAggregateInputType = {
    id?: true
    ticketNumber?: true
    userId?: true
    petId?: true
    subject?: true
    description?: true
    category?: true
    priority?: true
    status?: true
    assignedTo?: true
    resolution?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
  }

  export type SupportTicketMaxAggregateInputType = {
    id?: true
    ticketNumber?: true
    userId?: true
    petId?: true
    subject?: true
    description?: true
    category?: true
    priority?: true
    status?: true
    assignedTo?: true
    resolution?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
  }

  export type SupportTicketCountAggregateInputType = {
    id?: true
    ticketNumber?: true
    userId?: true
    petId?: true
    subject?: true
    description?: true
    category?: true
    priority?: true
    status?: true
    assignedTo?: true
    resolution?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
    _all?: true
  }

  export type SupportTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTicket to aggregate.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupportTickets
    **/
    _count?: true | SupportTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupportTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupportTicketMaxAggregateInputType
  }

  export type GetSupportTicketAggregateType<T extends SupportTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateSupportTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupportTicket[P]>
      : GetScalarType<T[P], AggregateSupportTicket[P]>
  }




  export type SupportTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithAggregationInput | SupportTicketOrderByWithAggregationInput[]
    by: SupportTicketScalarFieldEnum[] | SupportTicketScalarFieldEnum
    having?: SupportTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupportTicketCountAggregateInputType | true
    _min?: SupportTicketMinAggregateInputType
    _max?: SupportTicketMaxAggregateInputType
  }

  export type SupportTicketGroupByOutputType = {
    id: string
    ticketNumber: string
    userId: string | null
    petId: string | null
    subject: string
    description: string
    category: $Enums.TicketCategory
    priority: $Enums.TicketPriority
    status: $Enums.TicketStatus
    assignedTo: string | null
    resolution: string | null
    createdAt: Date
    updatedAt: Date
    resolvedAt: Date | null
    _count: SupportTicketCountAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  type GetSupportTicketGroupByPayload<T extends SupportTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupportTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupportTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
            : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
        }
      >
    >


  export type SupportTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketNumber?: boolean
    userId?: boolean
    petId?: boolean
    subject?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    assignedTo?: boolean
    resolution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
    messages?: boolean | SupportTicket$messagesArgs<ExtArgs>
    assignedToUser?: boolean | SupportTicket$assignedToUserArgs<ExtArgs>
    pet?: boolean | SupportTicket$petArgs<ExtArgs>
    user?: boolean | SupportTicket$userArgs<ExtArgs>
    _count?: boolean | SupportTicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketNumber?: boolean
    userId?: boolean
    petId?: boolean
    subject?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    assignedTo?: boolean
    resolution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
    assignedToUser?: boolean | SupportTicket$assignedToUserArgs<ExtArgs>
    pet?: boolean | SupportTicket$petArgs<ExtArgs>
    user?: boolean | SupportTicket$userArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketNumber?: boolean
    userId?: boolean
    petId?: boolean
    subject?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    assignedTo?: boolean
    resolution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
    assignedToUser?: boolean | SupportTicket$assignedToUserArgs<ExtArgs>
    pet?: boolean | SupportTicket$petArgs<ExtArgs>
    user?: boolean | SupportTicket$userArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectScalar = {
    id?: boolean
    ticketNumber?: boolean
    userId?: boolean
    petId?: boolean
    subject?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    assignedTo?: boolean
    resolution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
  }

  export type SupportTicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticketNumber" | "userId" | "petId" | "subject" | "description" | "category" | "priority" | "status" | "assignedTo" | "resolution" | "createdAt" | "updatedAt" | "resolvedAt", ExtArgs["result"]["supportTicket"]>
  export type SupportTicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | SupportTicket$messagesArgs<ExtArgs>
    assignedToUser?: boolean | SupportTicket$assignedToUserArgs<ExtArgs>
    pet?: boolean | SupportTicket$petArgs<ExtArgs>
    user?: boolean | SupportTicket$userArgs<ExtArgs>
    _count?: boolean | SupportTicketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupportTicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedToUser?: boolean | SupportTicket$assignedToUserArgs<ExtArgs>
    pet?: boolean | SupportTicket$petArgs<ExtArgs>
    user?: boolean | SupportTicket$userArgs<ExtArgs>
  }
  export type SupportTicketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedToUser?: boolean | SupportTicket$assignedToUserArgs<ExtArgs>
    pet?: boolean | SupportTicket$petArgs<ExtArgs>
    user?: boolean | SupportTicket$userArgs<ExtArgs>
  }

  export type $SupportTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupportTicket"
    objects: {
      messages: Prisma.$SupportMessagePayload<ExtArgs>[]
      assignedToUser: Prisma.$UserPayload<ExtArgs> | null
      pet: Prisma.$PetPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ticketNumber: string
      userId: string | null
      petId: string | null
      subject: string
      description: string
      category: $Enums.TicketCategory
      priority: $Enums.TicketPriority
      status: $Enums.TicketStatus
      assignedTo: string | null
      resolution: string | null
      createdAt: Date
      updatedAt: Date
      resolvedAt: Date | null
    }, ExtArgs["result"]["supportTicket"]>
    composites: {}
  }

  type SupportTicketGetPayload<S extends boolean | null | undefined | SupportTicketDefaultArgs> = $Result.GetResult<Prisma.$SupportTicketPayload, S>

  type SupportTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupportTicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupportTicketCountAggregateInputType | true
    }

  export interface SupportTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupportTicket'], meta: { name: 'SupportTicket' } }
    /**
     * Find zero or one SupportTicket that matches the filter.
     * @param {SupportTicketFindUniqueArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupportTicketFindUniqueArgs>(args: SelectSubset<T, SupportTicketFindUniqueArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupportTicket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupportTicketFindUniqueOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupportTicketFindUniqueOrThrowArgs>(args: SelectSubset<T, SupportTicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupportTicketFindFirstArgs>(args?: SelectSubset<T, SupportTicketFindFirstArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupportTicketFindFirstOrThrowArgs>(args?: SelectSubset<T, SupportTicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupportTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany()
     * 
     * // Get first 10 SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupportTicketFindManyArgs>(args?: SelectSubset<T, SupportTicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupportTicket.
     * @param {SupportTicketCreateArgs} args - Arguments to create a SupportTicket.
     * @example
     * // Create one SupportTicket
     * const SupportTicket = await prisma.supportTicket.create({
     *   data: {
     *     // ... data to create a SupportTicket
     *   }
     * })
     * 
     */
    create<T extends SupportTicketCreateArgs>(args: SelectSubset<T, SupportTicketCreateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupportTickets.
     * @param {SupportTicketCreateManyArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupportTicketCreateManyArgs>(args?: SelectSubset<T, SupportTicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupportTickets and returns the data saved in the database.
     * @param {SupportTicketCreateManyAndReturnArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupportTickets and only return the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupportTicketCreateManyAndReturnArgs>(args?: SelectSubset<T, SupportTicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupportTicket.
     * @param {SupportTicketDeleteArgs} args - Arguments to delete one SupportTicket.
     * @example
     * // Delete one SupportTicket
     * const SupportTicket = await prisma.supportTicket.delete({
     *   where: {
     *     // ... filter to delete one SupportTicket
     *   }
     * })
     * 
     */
    delete<T extends SupportTicketDeleteArgs>(args: SelectSubset<T, SupportTicketDeleteArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupportTicket.
     * @param {SupportTicketUpdateArgs} args - Arguments to update one SupportTicket.
     * @example
     * // Update one SupportTicket
     * const supportTicket = await prisma.supportTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupportTicketUpdateArgs>(args: SelectSubset<T, SupportTicketUpdateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupportTickets.
     * @param {SupportTicketDeleteManyArgs} args - Arguments to filter SupportTickets to delete.
     * @example
     * // Delete a few SupportTickets
     * const { count } = await prisma.supportTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupportTicketDeleteManyArgs>(args?: SelectSubset<T, SupportTicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupportTickets
     * const supportTicket = await prisma.supportTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupportTicketUpdateManyArgs>(args: SelectSubset<T, SupportTicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTickets and returns the data updated in the database.
     * @param {SupportTicketUpdateManyAndReturnArgs} args - Arguments to update many SupportTickets.
     * @example
     * // Update many SupportTickets
     * const supportTicket = await prisma.supportTicket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupportTickets and only return the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupportTicketUpdateManyAndReturnArgs>(args: SelectSubset<T, SupportTicketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupportTicket.
     * @param {SupportTicketUpsertArgs} args - Arguments to update or create a SupportTicket.
     * @example
     * // Update or create a SupportTicket
     * const supportTicket = await prisma.supportTicket.upsert({
     *   create: {
     *     // ... data to create a SupportTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupportTicket we want to update
     *   }
     * })
     */
    upsert<T extends SupportTicketUpsertArgs>(args: SelectSubset<T, SupportTicketUpsertArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketCountArgs} args - Arguments to filter SupportTickets to count.
     * @example
     * // Count the number of SupportTickets
     * const count = await prisma.supportTicket.count({
     *   where: {
     *     // ... the filter for the SupportTickets we want to count
     *   }
     * })
    **/
    count<T extends SupportTicketCountArgs>(
      args?: Subset<T, SupportTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupportTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupportTicketAggregateArgs>(args: Subset<T, SupportTicketAggregateArgs>): Prisma.PrismaPromise<GetSupportTicketAggregateType<T>>

    /**
     * Group by SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupportTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupportTicketGroupByArgs['orderBy'] }
        : { orderBy?: SupportTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupportTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupportTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupportTicket model
   */
  readonly fields: SupportTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupportTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupportTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends SupportTicket$messagesArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedToUser<T extends SupportTicket$assignedToUserArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$assignedToUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pet<T extends SupportTicket$petArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$petArgs<ExtArgs>>): Prisma__PetClient<$Result.GetResult<Prisma.$PetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends SupportTicket$userArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupportTicket model
   */
  interface SupportTicketFieldRefs {
    readonly id: FieldRef<"SupportTicket", 'String'>
    readonly ticketNumber: FieldRef<"SupportTicket", 'String'>
    readonly userId: FieldRef<"SupportTicket", 'String'>
    readonly petId: FieldRef<"SupportTicket", 'String'>
    readonly subject: FieldRef<"SupportTicket", 'String'>
    readonly description: FieldRef<"SupportTicket", 'String'>
    readonly category: FieldRef<"SupportTicket", 'TicketCategory'>
    readonly priority: FieldRef<"SupportTicket", 'TicketPriority'>
    readonly status: FieldRef<"SupportTicket", 'TicketStatus'>
    readonly assignedTo: FieldRef<"SupportTicket", 'String'>
    readonly resolution: FieldRef<"SupportTicket", 'String'>
    readonly createdAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly updatedAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly resolvedAt: FieldRef<"SupportTicket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupportTicket findUnique
   */
  export type SupportTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findUniqueOrThrow
   */
  export type SupportTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findFirst
   */
  export type SupportTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findFirstOrThrow
   */
  export type SupportTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findMany
   */
  export type SupportTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTickets to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket create
   */
  export type SupportTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to create a SupportTicket.
     */
    data: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
  }

  /**
   * SupportTicket createMany
   */
  export type SupportTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupportTicket createManyAndReturn
   */
  export type SupportTicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportTicket update
   */
  export type SupportTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to update a SupportTicket.
     */
    data: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
    /**
     * Choose, which SupportTicket to update.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket updateMany
   */
  export type SupportTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupportTickets.
     */
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyInput>
    /**
     * Filter which SupportTickets to update
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to update.
     */
    limit?: number
  }

  /**
   * SupportTicket updateManyAndReturn
   */
  export type SupportTicketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * The data used to update SupportTickets.
     */
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyInput>
    /**
     * Filter which SupportTickets to update
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportTicket upsert
   */
  export type SupportTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The filter to search for the SupportTicket to update in case it exists.
     */
    where: SupportTicketWhereUniqueInput
    /**
     * In case the SupportTicket found by the `where` argument doesn't exist, create a new SupportTicket with this data.
     */
    create: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
    /**
     * In case the SupportTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
  }

  /**
   * SupportTicket delete
   */
  export type SupportTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter which SupportTicket to delete.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket deleteMany
   */
  export type SupportTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTickets to delete
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to delete.
     */
    limit?: number
  }

  /**
   * SupportTicket.messages
   */
  export type SupportTicket$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    where?: SupportMessageWhereInput
    orderBy?: SupportMessageOrderByWithRelationInput | SupportMessageOrderByWithRelationInput[]
    cursor?: SupportMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportMessageScalarFieldEnum | SupportMessageScalarFieldEnum[]
  }

  /**
   * SupportTicket.assignedToUser
   */
  export type SupportTicket$assignedToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SupportTicket.pet
   */
  export type SupportTicket$petArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pet
     */
    omit?: PetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetInclude<ExtArgs> | null
    where?: PetWhereInput
  }

  /**
   * SupportTicket.user
   */
  export type SupportTicket$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SupportTicket without action
   */
  export type SupportTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
  }


  /**
   * Model SupportMessage
   */

  export type AggregateSupportMessage = {
    _count: SupportMessageCountAggregateOutputType | null
    _min: SupportMessageMinAggregateOutputType | null
    _max: SupportMessageMaxAggregateOutputType | null
  }

  export type SupportMessageMinAggregateOutputType = {
    id: string | null
    ticketId: string | null
    senderId: string | null
    senderType: $Enums.SenderType | null
    message: string | null
    isInternal: boolean | null
    createdAt: Date | null
  }

  export type SupportMessageMaxAggregateOutputType = {
    id: string | null
    ticketId: string | null
    senderId: string | null
    senderType: $Enums.SenderType | null
    message: string | null
    isInternal: boolean | null
    createdAt: Date | null
  }

  export type SupportMessageCountAggregateOutputType = {
    id: number
    ticketId: number
    senderId: number
    senderType: number
    message: number
    attachments: number
    isInternal: number
    createdAt: number
    _all: number
  }


  export type SupportMessageMinAggregateInputType = {
    id?: true
    ticketId?: true
    senderId?: true
    senderType?: true
    message?: true
    isInternal?: true
    createdAt?: true
  }

  export type SupportMessageMaxAggregateInputType = {
    id?: true
    ticketId?: true
    senderId?: true
    senderType?: true
    message?: true
    isInternal?: true
    createdAt?: true
  }

  export type SupportMessageCountAggregateInputType = {
    id?: true
    ticketId?: true
    senderId?: true
    senderType?: true
    message?: true
    attachments?: true
    isInternal?: true
    createdAt?: true
    _all?: true
  }

  export type SupportMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportMessage to aggregate.
     */
    where?: SupportMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportMessages to fetch.
     */
    orderBy?: SupportMessageOrderByWithRelationInput | SupportMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupportMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupportMessages
    **/
    _count?: true | SupportMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupportMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupportMessageMaxAggregateInputType
  }

  export type GetSupportMessageAggregateType<T extends SupportMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateSupportMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupportMessage[P]>
      : GetScalarType<T[P], AggregateSupportMessage[P]>
  }




  export type SupportMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportMessageWhereInput
    orderBy?: SupportMessageOrderByWithAggregationInput | SupportMessageOrderByWithAggregationInput[]
    by: SupportMessageScalarFieldEnum[] | SupportMessageScalarFieldEnum
    having?: SupportMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupportMessageCountAggregateInputType | true
    _min?: SupportMessageMinAggregateInputType
    _max?: SupportMessageMaxAggregateInputType
  }

  export type SupportMessageGroupByOutputType = {
    id: string
    ticketId: string
    senderId: string | null
    senderType: $Enums.SenderType
    message: string
    attachments: string[]
    isInternal: boolean
    createdAt: Date
    _count: SupportMessageCountAggregateOutputType | null
    _min: SupportMessageMinAggregateOutputType | null
    _max: SupportMessageMaxAggregateOutputType | null
  }

  type GetSupportMessageGroupByPayload<T extends SupportMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupportMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupportMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupportMessageGroupByOutputType[P]>
            : GetScalarType<T[P], SupportMessageGroupByOutputType[P]>
        }
      >
    >


  export type SupportMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    senderId?: boolean
    senderType?: boolean
    message?: boolean
    attachments?: boolean
    isInternal?: boolean
    createdAt?: boolean
    sender?: boolean | SupportMessage$senderArgs<ExtArgs>
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportMessage"]>

  export type SupportMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    senderId?: boolean
    senderType?: boolean
    message?: boolean
    attachments?: boolean
    isInternal?: boolean
    createdAt?: boolean
    sender?: boolean | SupportMessage$senderArgs<ExtArgs>
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportMessage"]>

  export type SupportMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    senderId?: boolean
    senderType?: boolean
    message?: boolean
    attachments?: boolean
    isInternal?: boolean
    createdAt?: boolean
    sender?: boolean | SupportMessage$senderArgs<ExtArgs>
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportMessage"]>

  export type SupportMessageSelectScalar = {
    id?: boolean
    ticketId?: boolean
    senderId?: boolean
    senderType?: boolean
    message?: boolean
    attachments?: boolean
    isInternal?: boolean
    createdAt?: boolean
  }

  export type SupportMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticketId" | "senderId" | "senderType" | "message" | "attachments" | "isInternal" | "createdAt", ExtArgs["result"]["supportMessage"]>
  export type SupportMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | SupportMessage$senderArgs<ExtArgs>
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
  }
  export type SupportMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | SupportMessage$senderArgs<ExtArgs>
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
  }
  export type SupportMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | SupportMessage$senderArgs<ExtArgs>
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
  }

  export type $SupportMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupportMessage"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs> | null
      ticket: Prisma.$SupportTicketPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ticketId: string
      senderId: string | null
      senderType: $Enums.SenderType
      message: string
      attachments: string[]
      isInternal: boolean
      createdAt: Date
    }, ExtArgs["result"]["supportMessage"]>
    composites: {}
  }

  type SupportMessageGetPayload<S extends boolean | null | undefined | SupportMessageDefaultArgs> = $Result.GetResult<Prisma.$SupportMessagePayload, S>

  type SupportMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupportMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupportMessageCountAggregateInputType | true
    }

  export interface SupportMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupportMessage'], meta: { name: 'SupportMessage' } }
    /**
     * Find zero or one SupportMessage that matches the filter.
     * @param {SupportMessageFindUniqueArgs} args - Arguments to find a SupportMessage
     * @example
     * // Get one SupportMessage
     * const supportMessage = await prisma.supportMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupportMessageFindUniqueArgs>(args: SelectSubset<T, SupportMessageFindUniqueArgs<ExtArgs>>): Prisma__SupportMessageClient<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupportMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupportMessageFindUniqueOrThrowArgs} args - Arguments to find a SupportMessage
     * @example
     * // Get one SupportMessage
     * const supportMessage = await prisma.supportMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupportMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, SupportMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupportMessageClient<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportMessageFindFirstArgs} args - Arguments to find a SupportMessage
     * @example
     * // Get one SupportMessage
     * const supportMessage = await prisma.supportMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupportMessageFindFirstArgs>(args?: SelectSubset<T, SupportMessageFindFirstArgs<ExtArgs>>): Prisma__SupportMessageClient<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportMessageFindFirstOrThrowArgs} args - Arguments to find a SupportMessage
     * @example
     * // Get one SupportMessage
     * const supportMessage = await prisma.supportMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupportMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, SupportMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupportMessageClient<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupportMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupportMessages
     * const supportMessages = await prisma.supportMessage.findMany()
     * 
     * // Get first 10 SupportMessages
     * const supportMessages = await prisma.supportMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supportMessageWithIdOnly = await prisma.supportMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupportMessageFindManyArgs>(args?: SelectSubset<T, SupportMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupportMessage.
     * @param {SupportMessageCreateArgs} args - Arguments to create a SupportMessage.
     * @example
     * // Create one SupportMessage
     * const SupportMessage = await prisma.supportMessage.create({
     *   data: {
     *     // ... data to create a SupportMessage
     *   }
     * })
     * 
     */
    create<T extends SupportMessageCreateArgs>(args: SelectSubset<T, SupportMessageCreateArgs<ExtArgs>>): Prisma__SupportMessageClient<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupportMessages.
     * @param {SupportMessageCreateManyArgs} args - Arguments to create many SupportMessages.
     * @example
     * // Create many SupportMessages
     * const supportMessage = await prisma.supportMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupportMessageCreateManyArgs>(args?: SelectSubset<T, SupportMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupportMessages and returns the data saved in the database.
     * @param {SupportMessageCreateManyAndReturnArgs} args - Arguments to create many SupportMessages.
     * @example
     * // Create many SupportMessages
     * const supportMessage = await prisma.supportMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupportMessages and only return the `id`
     * const supportMessageWithIdOnly = await prisma.supportMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupportMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, SupportMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupportMessage.
     * @param {SupportMessageDeleteArgs} args - Arguments to delete one SupportMessage.
     * @example
     * // Delete one SupportMessage
     * const SupportMessage = await prisma.supportMessage.delete({
     *   where: {
     *     // ... filter to delete one SupportMessage
     *   }
     * })
     * 
     */
    delete<T extends SupportMessageDeleteArgs>(args: SelectSubset<T, SupportMessageDeleteArgs<ExtArgs>>): Prisma__SupportMessageClient<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupportMessage.
     * @param {SupportMessageUpdateArgs} args - Arguments to update one SupportMessage.
     * @example
     * // Update one SupportMessage
     * const supportMessage = await prisma.supportMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupportMessageUpdateArgs>(args: SelectSubset<T, SupportMessageUpdateArgs<ExtArgs>>): Prisma__SupportMessageClient<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupportMessages.
     * @param {SupportMessageDeleteManyArgs} args - Arguments to filter SupportMessages to delete.
     * @example
     * // Delete a few SupportMessages
     * const { count } = await prisma.supportMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupportMessageDeleteManyArgs>(args?: SelectSubset<T, SupportMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupportMessages
     * const supportMessage = await prisma.supportMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupportMessageUpdateManyArgs>(args: SelectSubset<T, SupportMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportMessages and returns the data updated in the database.
     * @param {SupportMessageUpdateManyAndReturnArgs} args - Arguments to update many SupportMessages.
     * @example
     * // Update many SupportMessages
     * const supportMessage = await prisma.supportMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupportMessages and only return the `id`
     * const supportMessageWithIdOnly = await prisma.supportMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupportMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, SupportMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupportMessage.
     * @param {SupportMessageUpsertArgs} args - Arguments to update or create a SupportMessage.
     * @example
     * // Update or create a SupportMessage
     * const supportMessage = await prisma.supportMessage.upsert({
     *   create: {
     *     // ... data to create a SupportMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupportMessage we want to update
     *   }
     * })
     */
    upsert<T extends SupportMessageUpsertArgs>(args: SelectSubset<T, SupportMessageUpsertArgs<ExtArgs>>): Prisma__SupportMessageClient<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupportMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportMessageCountArgs} args - Arguments to filter SupportMessages to count.
     * @example
     * // Count the number of SupportMessages
     * const count = await prisma.supportMessage.count({
     *   where: {
     *     // ... the filter for the SupportMessages we want to count
     *   }
     * })
    **/
    count<T extends SupportMessageCountArgs>(
      args?: Subset<T, SupportMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupportMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupportMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupportMessageAggregateArgs>(args: Subset<T, SupportMessageAggregateArgs>): Prisma.PrismaPromise<GetSupportMessageAggregateType<T>>

    /**
     * Group by SupportMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupportMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupportMessageGroupByArgs['orderBy'] }
        : { orderBy?: SupportMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupportMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupportMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupportMessage model
   */
  readonly fields: SupportMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupportMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupportMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends SupportMessage$senderArgs<ExtArgs> = {}>(args?: Subset<T, SupportMessage$senderArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ticket<T extends SupportTicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicketDefaultArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupportMessage model
   */
  interface SupportMessageFieldRefs {
    readonly id: FieldRef<"SupportMessage", 'String'>
    readonly ticketId: FieldRef<"SupportMessage", 'String'>
    readonly senderId: FieldRef<"SupportMessage", 'String'>
    readonly senderType: FieldRef<"SupportMessage", 'SenderType'>
    readonly message: FieldRef<"SupportMessage", 'String'>
    readonly attachments: FieldRef<"SupportMessage", 'String[]'>
    readonly isInternal: FieldRef<"SupportMessage", 'Boolean'>
    readonly createdAt: FieldRef<"SupportMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupportMessage findUnique
   */
  export type SupportMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * Filter, which SupportMessage to fetch.
     */
    where: SupportMessageWhereUniqueInput
  }

  /**
   * SupportMessage findUniqueOrThrow
   */
  export type SupportMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * Filter, which SupportMessage to fetch.
     */
    where: SupportMessageWhereUniqueInput
  }

  /**
   * SupportMessage findFirst
   */
  export type SupportMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * Filter, which SupportMessage to fetch.
     */
    where?: SupportMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportMessages to fetch.
     */
    orderBy?: SupportMessageOrderByWithRelationInput | SupportMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportMessages.
     */
    cursor?: SupportMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportMessages.
     */
    distinct?: SupportMessageScalarFieldEnum | SupportMessageScalarFieldEnum[]
  }

  /**
   * SupportMessage findFirstOrThrow
   */
  export type SupportMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * Filter, which SupportMessage to fetch.
     */
    where?: SupportMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportMessages to fetch.
     */
    orderBy?: SupportMessageOrderByWithRelationInput | SupportMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportMessages.
     */
    cursor?: SupportMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportMessages.
     */
    distinct?: SupportMessageScalarFieldEnum | SupportMessageScalarFieldEnum[]
  }

  /**
   * SupportMessage findMany
   */
  export type SupportMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * Filter, which SupportMessages to fetch.
     */
    where?: SupportMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportMessages to fetch.
     */
    orderBy?: SupportMessageOrderByWithRelationInput | SupportMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupportMessages.
     */
    cursor?: SupportMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportMessages.
     */
    skip?: number
    distinct?: SupportMessageScalarFieldEnum | SupportMessageScalarFieldEnum[]
  }

  /**
   * SupportMessage create
   */
  export type SupportMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a SupportMessage.
     */
    data: XOR<SupportMessageCreateInput, SupportMessageUncheckedCreateInput>
  }

  /**
   * SupportMessage createMany
   */
  export type SupportMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupportMessages.
     */
    data: SupportMessageCreateManyInput | SupportMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupportMessage createManyAndReturn
   */
  export type SupportMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * The data used to create many SupportMessages.
     */
    data: SupportMessageCreateManyInput | SupportMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportMessage update
   */
  export type SupportMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a SupportMessage.
     */
    data: XOR<SupportMessageUpdateInput, SupportMessageUncheckedUpdateInput>
    /**
     * Choose, which SupportMessage to update.
     */
    where: SupportMessageWhereUniqueInput
  }

  /**
   * SupportMessage updateMany
   */
  export type SupportMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupportMessages.
     */
    data: XOR<SupportMessageUpdateManyMutationInput, SupportMessageUncheckedUpdateManyInput>
    /**
     * Filter which SupportMessages to update
     */
    where?: SupportMessageWhereInput
    /**
     * Limit how many SupportMessages to update.
     */
    limit?: number
  }

  /**
   * SupportMessage updateManyAndReturn
   */
  export type SupportMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * The data used to update SupportMessages.
     */
    data: XOR<SupportMessageUpdateManyMutationInput, SupportMessageUncheckedUpdateManyInput>
    /**
     * Filter which SupportMessages to update
     */
    where?: SupportMessageWhereInput
    /**
     * Limit how many SupportMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportMessage upsert
   */
  export type SupportMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the SupportMessage to update in case it exists.
     */
    where: SupportMessageWhereUniqueInput
    /**
     * In case the SupportMessage found by the `where` argument doesn't exist, create a new SupportMessage with this data.
     */
    create: XOR<SupportMessageCreateInput, SupportMessageUncheckedCreateInput>
    /**
     * In case the SupportMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupportMessageUpdateInput, SupportMessageUncheckedUpdateInput>
  }

  /**
   * SupportMessage delete
   */
  export type SupportMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * Filter which SupportMessage to delete.
     */
    where: SupportMessageWhereUniqueInput
  }

  /**
   * SupportMessage deleteMany
   */
  export type SupportMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportMessages to delete
     */
    where?: SupportMessageWhereInput
    /**
     * Limit how many SupportMessages to delete.
     */
    limit?: number
  }

  /**
   * SupportMessage.sender
   */
  export type SupportMessage$senderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SupportMessage without action
   */
  export type SupportMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    tableName: string | null
    recordId: string | null
    operationType: $Enums.OperationType | null
    userId: string | null
    ipAddress: string | null
    userAgent: string | null
    timestamp: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    tableName: string | null
    recordId: string | null
    operationType: $Enums.OperationType | null
    userId: string | null
    ipAddress: string | null
    userAgent: string | null
    timestamp: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    tableName: number
    recordId: number
    operationType: number
    oldValues: number
    newValues: number
    changedColumns: number
    userId: number
    ipAddress: number
    userAgent: number
    timestamp: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    operationType?: true
    userId?: true
    ipAddress?: true
    userAgent?: true
    timestamp?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    operationType?: true
    userId?: true
    ipAddress?: true
    userAgent?: true
    timestamp?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    operationType?: true
    oldValues?: true
    newValues?: true
    changedColumns?: true
    userId?: true
    ipAddress?: true
    userAgent?: true
    timestamp?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    tableName: string
    recordId: string
    operationType: $Enums.OperationType
    oldValues: JsonValue | null
    newValues: JsonValue | null
    changedColumns: string[]
    userId: string | null
    ipAddress: string | null
    userAgent: string | null
    timestamp: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    operationType?: boolean
    oldValues?: boolean
    newValues?: boolean
    changedColumns?: boolean
    userId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    timestamp?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    operationType?: boolean
    oldValues?: boolean
    newValues?: boolean
    changedColumns?: boolean
    userId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    timestamp?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    operationType?: boolean
    oldValues?: boolean
    newValues?: boolean
    changedColumns?: boolean
    userId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    timestamp?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    operationType?: boolean
    oldValues?: boolean
    newValues?: boolean
    changedColumns?: boolean
    userId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    timestamp?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tableName" | "recordId" | "operationType" | "oldValues" | "newValues" | "changedColumns" | "userId" | "ipAddress" | "userAgent" | "timestamp", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tableName: string
      recordId: string
      operationType: $Enums.OperationType
      oldValues: Prisma.JsonValue | null
      newValues: Prisma.JsonValue | null
      changedColumns: string[]
      userId: string | null
      ipAddress: string | null
      userAgent: string | null
      timestamp: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly tableName: FieldRef<"AuditLog", 'String'>
    readonly recordId: FieldRef<"AuditLog", 'String'>
    readonly operationType: FieldRef<"AuditLog", 'OperationType'>
    readonly oldValues: FieldRef<"AuditLog", 'Json'>
    readonly newValues: FieldRef<"AuditLog", 'Json'>
    readonly changedColumns: FieldRef<"AuditLog", 'String[]'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model SystemAnalytics
   */

  export type AggregateSystemAnalytics = {
    _count: SystemAnalyticsCountAggregateOutputType | null
    _avg: SystemAnalyticsAvgAggregateOutputType | null
    _sum: SystemAnalyticsSumAggregateOutputType | null
    _min: SystemAnalyticsMinAggregateOutputType | null
    _max: SystemAnalyticsMaxAggregateOutputType | null
  }

  export type SystemAnalyticsAvgAggregateOutputType = {
    metricValue: Decimal | null
  }

  export type SystemAnalyticsSumAggregateOutputType = {
    metricValue: Decimal | null
  }

  export type SystemAnalyticsMinAggregateOutputType = {
    id: string | null
    metricName: string | null
    metricValue: Decimal | null
    metricUnit: string | null
    timestamp: Date | null
  }

  export type SystemAnalyticsMaxAggregateOutputType = {
    id: string | null
    metricName: string | null
    metricValue: Decimal | null
    metricUnit: string | null
    timestamp: Date | null
  }

  export type SystemAnalyticsCountAggregateOutputType = {
    id: number
    metricName: number
    metricValue: number
    metricUnit: number
    dimensions: number
    timestamp: number
    _all: number
  }


  export type SystemAnalyticsAvgAggregateInputType = {
    metricValue?: true
  }

  export type SystemAnalyticsSumAggregateInputType = {
    metricValue?: true
  }

  export type SystemAnalyticsMinAggregateInputType = {
    id?: true
    metricName?: true
    metricValue?: true
    metricUnit?: true
    timestamp?: true
  }

  export type SystemAnalyticsMaxAggregateInputType = {
    id?: true
    metricName?: true
    metricValue?: true
    metricUnit?: true
    timestamp?: true
  }

  export type SystemAnalyticsCountAggregateInputType = {
    id?: true
    metricName?: true
    metricValue?: true
    metricUnit?: true
    dimensions?: true
    timestamp?: true
    _all?: true
  }

  export type SystemAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemAnalytics to aggregate.
     */
    where?: SystemAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemAnalytics to fetch.
     */
    orderBy?: SystemAnalyticsOrderByWithRelationInput | SystemAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemAnalytics
    **/
    _count?: true | SystemAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemAnalyticsMaxAggregateInputType
  }

  export type GetSystemAnalyticsAggregateType<T extends SystemAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemAnalytics[P]>
      : GetScalarType<T[P], AggregateSystemAnalytics[P]>
  }




  export type SystemAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemAnalyticsWhereInput
    orderBy?: SystemAnalyticsOrderByWithAggregationInput | SystemAnalyticsOrderByWithAggregationInput[]
    by: SystemAnalyticsScalarFieldEnum[] | SystemAnalyticsScalarFieldEnum
    having?: SystemAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemAnalyticsCountAggregateInputType | true
    _avg?: SystemAnalyticsAvgAggregateInputType
    _sum?: SystemAnalyticsSumAggregateInputType
    _min?: SystemAnalyticsMinAggregateInputType
    _max?: SystemAnalyticsMaxAggregateInputType
  }

  export type SystemAnalyticsGroupByOutputType = {
    id: string
    metricName: string
    metricValue: Decimal | null
    metricUnit: string | null
    dimensions: JsonValue | null
    timestamp: Date
    _count: SystemAnalyticsCountAggregateOutputType | null
    _avg: SystemAnalyticsAvgAggregateOutputType | null
    _sum: SystemAnalyticsSumAggregateOutputType | null
    _min: SystemAnalyticsMinAggregateOutputType | null
    _max: SystemAnalyticsMaxAggregateOutputType | null
  }

  type GetSystemAnalyticsGroupByPayload<T extends SystemAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], SystemAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type SystemAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metricName?: boolean
    metricValue?: boolean
    metricUnit?: boolean
    dimensions?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["systemAnalytics"]>

  export type SystemAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metricName?: boolean
    metricValue?: boolean
    metricUnit?: boolean
    dimensions?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["systemAnalytics"]>

  export type SystemAnalyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metricName?: boolean
    metricValue?: boolean
    metricUnit?: boolean
    dimensions?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["systemAnalytics"]>

  export type SystemAnalyticsSelectScalar = {
    id?: boolean
    metricName?: boolean
    metricValue?: boolean
    metricUnit?: boolean
    dimensions?: boolean
    timestamp?: boolean
  }

  export type SystemAnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "metricName" | "metricValue" | "metricUnit" | "dimensions" | "timestamp", ExtArgs["result"]["systemAnalytics"]>

  export type $SystemAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemAnalytics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      metricName: string
      metricValue: Prisma.Decimal | null
      metricUnit: string | null
      dimensions: Prisma.JsonValue | null
      timestamp: Date
    }, ExtArgs["result"]["systemAnalytics"]>
    composites: {}
  }

  type SystemAnalyticsGetPayload<S extends boolean | null | undefined | SystemAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$SystemAnalyticsPayload, S>

  type SystemAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemAnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemAnalyticsCountAggregateInputType | true
    }

  export interface SystemAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemAnalytics'], meta: { name: 'SystemAnalytics' } }
    /**
     * Find zero or one SystemAnalytics that matches the filter.
     * @param {SystemAnalyticsFindUniqueArgs} args - Arguments to find a SystemAnalytics
     * @example
     * // Get one SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemAnalyticsFindUniqueArgs>(args: SelectSubset<T, SystemAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__SystemAnalyticsClient<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemAnalytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a SystemAnalytics
     * @example
     * // Get one SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemAnalyticsClient<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAnalyticsFindFirstArgs} args - Arguments to find a SystemAnalytics
     * @example
     * // Get one SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemAnalyticsFindFirstArgs>(args?: SelectSubset<T, SystemAnalyticsFindFirstArgs<ExtArgs>>): Prisma__SystemAnalyticsClient<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAnalyticsFindFirstOrThrowArgs} args - Arguments to find a SystemAnalytics
     * @example
     * // Get one SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemAnalyticsClient<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.findMany()
     * 
     * // Get first 10 SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemAnalyticsWithIdOnly = await prisma.systemAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemAnalyticsFindManyArgs>(args?: SelectSubset<T, SystemAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemAnalytics.
     * @param {SystemAnalyticsCreateArgs} args - Arguments to create a SystemAnalytics.
     * @example
     * // Create one SystemAnalytics
     * const SystemAnalytics = await prisma.systemAnalytics.create({
     *   data: {
     *     // ... data to create a SystemAnalytics
     *   }
     * })
     * 
     */
    create<T extends SystemAnalyticsCreateArgs>(args: SelectSubset<T, SystemAnalyticsCreateArgs<ExtArgs>>): Prisma__SystemAnalyticsClient<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemAnalytics.
     * @param {SystemAnalyticsCreateManyArgs} args - Arguments to create many SystemAnalytics.
     * @example
     * // Create many SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemAnalyticsCreateManyArgs>(args?: SelectSubset<T, SystemAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemAnalytics and returns the data saved in the database.
     * @param {SystemAnalyticsCreateManyAndReturnArgs} args - Arguments to create many SystemAnalytics.
     * @example
     * // Create many SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemAnalytics and only return the `id`
     * const systemAnalyticsWithIdOnly = await prisma.systemAnalytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemAnalytics.
     * @param {SystemAnalyticsDeleteArgs} args - Arguments to delete one SystemAnalytics.
     * @example
     * // Delete one SystemAnalytics
     * const SystemAnalytics = await prisma.systemAnalytics.delete({
     *   where: {
     *     // ... filter to delete one SystemAnalytics
     *   }
     * })
     * 
     */
    delete<T extends SystemAnalyticsDeleteArgs>(args: SelectSubset<T, SystemAnalyticsDeleteArgs<ExtArgs>>): Prisma__SystemAnalyticsClient<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemAnalytics.
     * @param {SystemAnalyticsUpdateArgs} args - Arguments to update one SystemAnalytics.
     * @example
     * // Update one SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemAnalyticsUpdateArgs>(args: SelectSubset<T, SystemAnalyticsUpdateArgs<ExtArgs>>): Prisma__SystemAnalyticsClient<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemAnalytics.
     * @param {SystemAnalyticsDeleteManyArgs} args - Arguments to filter SystemAnalytics to delete.
     * @example
     * // Delete a few SystemAnalytics
     * const { count } = await prisma.systemAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemAnalyticsDeleteManyArgs>(args?: SelectSubset<T, SystemAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemAnalyticsUpdateManyArgs>(args: SelectSubset<T, SystemAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemAnalytics and returns the data updated in the database.
     * @param {SystemAnalyticsUpdateManyAndReturnArgs} args - Arguments to update many SystemAnalytics.
     * @example
     * // Update many SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemAnalytics and only return the `id`
     * const systemAnalyticsWithIdOnly = await prisma.systemAnalytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemAnalyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemAnalyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemAnalytics.
     * @param {SystemAnalyticsUpsertArgs} args - Arguments to update or create a SystemAnalytics.
     * @example
     * // Update or create a SystemAnalytics
     * const systemAnalytics = await prisma.systemAnalytics.upsert({
     *   create: {
     *     // ... data to create a SystemAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends SystemAnalyticsUpsertArgs>(args: SelectSubset<T, SystemAnalyticsUpsertArgs<ExtArgs>>): Prisma__SystemAnalyticsClient<$Result.GetResult<Prisma.$SystemAnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAnalyticsCountArgs} args - Arguments to filter SystemAnalytics to count.
     * @example
     * // Count the number of SystemAnalytics
     * const count = await prisma.systemAnalytics.count({
     *   where: {
     *     // ... the filter for the SystemAnalytics we want to count
     *   }
     * })
    **/
    count<T extends SystemAnalyticsCountArgs>(
      args?: Subset<T, SystemAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemAnalyticsAggregateArgs>(args: Subset<T, SystemAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetSystemAnalyticsAggregateType<T>>

    /**
     * Group by SystemAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: SystemAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemAnalytics model
   */
  readonly fields: SystemAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemAnalytics model
   */
  interface SystemAnalyticsFieldRefs {
    readonly id: FieldRef<"SystemAnalytics", 'String'>
    readonly metricName: FieldRef<"SystemAnalytics", 'String'>
    readonly metricValue: FieldRef<"SystemAnalytics", 'Decimal'>
    readonly metricUnit: FieldRef<"SystemAnalytics", 'String'>
    readonly dimensions: FieldRef<"SystemAnalytics", 'Json'>
    readonly timestamp: FieldRef<"SystemAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemAnalytics findUnique
   */
  export type SystemAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAnalytics
     */
    omit?: SystemAnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which SystemAnalytics to fetch.
     */
    where: SystemAnalyticsWhereUniqueInput
  }

  /**
   * SystemAnalytics findUniqueOrThrow
   */
  export type SystemAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAnalytics
     */
    omit?: SystemAnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which SystemAnalytics to fetch.
     */
    where: SystemAnalyticsWhereUniqueInput
  }

  /**
   * SystemAnalytics findFirst
   */
  export type SystemAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAnalytics
     */
    omit?: SystemAnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which SystemAnalytics to fetch.
     */
    where?: SystemAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemAnalytics to fetch.
     */
    orderBy?: SystemAnalyticsOrderByWithRelationInput | SystemAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemAnalytics.
     */
    cursor?: SystemAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemAnalytics.
     */
    distinct?: SystemAnalyticsScalarFieldEnum | SystemAnalyticsScalarFieldEnum[]
  }

  /**
   * SystemAnalytics findFirstOrThrow
   */
  export type SystemAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAnalytics
     */
    omit?: SystemAnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which SystemAnalytics to fetch.
     */
    where?: SystemAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemAnalytics to fetch.
     */
    orderBy?: SystemAnalyticsOrderByWithRelationInput | SystemAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemAnalytics.
     */
    cursor?: SystemAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemAnalytics.
     */
    distinct?: SystemAnalyticsScalarFieldEnum | SystemAnalyticsScalarFieldEnum[]
  }

  /**
   * SystemAnalytics findMany
   */
  export type SystemAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAnalytics
     */
    omit?: SystemAnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which SystemAnalytics to fetch.
     */
    where?: SystemAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemAnalytics to fetch.
     */
    orderBy?: SystemAnalyticsOrderByWithRelationInput | SystemAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemAnalytics.
     */
    cursor?: SystemAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemAnalytics.
     */
    skip?: number
    distinct?: SystemAnalyticsScalarFieldEnum | SystemAnalyticsScalarFieldEnum[]
  }

  /**
   * SystemAnalytics create
   */
  export type SystemAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAnalytics
     */
    omit?: SystemAnalyticsOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemAnalytics.
     */
    data: XOR<SystemAnalyticsCreateInput, SystemAnalyticsUncheckedCreateInput>
  }

  /**
   * SystemAnalytics createMany
   */
  export type SystemAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemAnalytics.
     */
    data: SystemAnalyticsCreateManyInput | SystemAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemAnalytics createManyAndReturn
   */
  export type SystemAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAnalytics
     */
    omit?: SystemAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to create many SystemAnalytics.
     */
    data: SystemAnalyticsCreateManyInput | SystemAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemAnalytics update
   */
  export type SystemAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAnalytics
     */
    omit?: SystemAnalyticsOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemAnalytics.
     */
    data: XOR<SystemAnalyticsUpdateInput, SystemAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which SystemAnalytics to update.
     */
    where: SystemAnalyticsWhereUniqueInput
  }

  /**
   * SystemAnalytics updateMany
   */
  export type SystemAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemAnalytics.
     */
    data: XOR<SystemAnalyticsUpdateManyMutationInput, SystemAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which SystemAnalytics to update
     */
    where?: SystemAnalyticsWhereInput
    /**
     * Limit how many SystemAnalytics to update.
     */
    limit?: number
  }

  /**
   * SystemAnalytics updateManyAndReturn
   */
  export type SystemAnalyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAnalytics
     */
    omit?: SystemAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to update SystemAnalytics.
     */
    data: XOR<SystemAnalyticsUpdateManyMutationInput, SystemAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which SystemAnalytics to update
     */
    where?: SystemAnalyticsWhereInput
    /**
     * Limit how many SystemAnalytics to update.
     */
    limit?: number
  }

  /**
   * SystemAnalytics upsert
   */
  export type SystemAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAnalytics
     */
    omit?: SystemAnalyticsOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemAnalytics to update in case it exists.
     */
    where: SystemAnalyticsWhereUniqueInput
    /**
     * In case the SystemAnalytics found by the `where` argument doesn't exist, create a new SystemAnalytics with this data.
     */
    create: XOR<SystemAnalyticsCreateInput, SystemAnalyticsUncheckedCreateInput>
    /**
     * In case the SystemAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemAnalyticsUpdateInput, SystemAnalyticsUncheckedUpdateInput>
  }

  /**
   * SystemAnalytics delete
   */
  export type SystemAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAnalytics
     */
    omit?: SystemAnalyticsOmit<ExtArgs> | null
    /**
     * Filter which SystemAnalytics to delete.
     */
    where: SystemAnalyticsWhereUniqueInput
  }

  /**
   * SystemAnalytics deleteMany
   */
  export type SystemAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemAnalytics to delete
     */
    where?: SystemAnalyticsWhereInput
    /**
     * Limit how many SystemAnalytics to delete.
     */
    limit?: number
  }

  /**
   * SystemAnalytics without action
   */
  export type SystemAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAnalytics
     */
    select?: SystemAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAnalytics
     */
    omit?: SystemAnalyticsOmit<ExtArgs> | null
  }


  /**
   * Model PetRegistrationApplication
   */

  export type AggregatePetRegistrationApplication = {
    _count: PetRegistrationApplicationCountAggregateOutputType | null
    _avg: PetRegistrationApplicationAvgAggregateOutputType | null
    _sum: PetRegistrationApplicationSumAggregateOutputType | null
    _min: PetRegistrationApplicationMinAggregateOutputType | null
    _max: PetRegistrationApplicationMaxAggregateOutputType | null
  }

  export type PetRegistrationApplicationAvgAggregateOutputType = {
    registrationFee: Decimal | null
    convenienceFee: Decimal | null
    gst: Decimal | null
    totalAmount: Decimal | null
  }

  export type PetRegistrationApplicationSumAggregateOutputType = {
    registrationFee: Decimal | null
    convenienceFee: Decimal | null
    gst: Decimal | null
    totalAmount: Decimal | null
  }

  export type PetRegistrationApplicationMinAggregateOutputType = {
    id: string | null
    applicationType: $Enums.ApplicationType | null
    identifierType: $Enums.IdentifierType | null
    identifierNumber: string | null
    submittedAt: Date | null
    city: string | null
    state: string | null
    country: string | null
    applicantType: $Enums.ApplicantType | null
    applicantName: string | null
    fatherOrHusbandName: string | null
    applicantEmail: string | null
    applicantPhone: string | null
    aadhaarNumber: string | null
    pincode: string | null
    address: string | null
    hasTokenNumber: boolean | null
    declarationAcknowledgement: string | null
    acceptedTerms: boolean | null
    registrationFee: Decimal | null
    convenienceFee: Decimal | null
    gst: Decimal | null
    totalAmount: Decimal | null
    currency: string | null
    deliveryAddressLine: string | null
    deliveryCity: string | null
    deliveryState: string | null
    deliveryPincode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PetRegistrationApplicationMaxAggregateOutputType = {
    id: string | null
    applicationType: $Enums.ApplicationType | null
    identifierType: $Enums.IdentifierType | null
    identifierNumber: string | null
    submittedAt: Date | null
    city: string | null
    state: string | null
    country: string | null
    applicantType: $Enums.ApplicantType | null
    applicantName: string | null
    fatherOrHusbandName: string | null
    applicantEmail: string | null
    applicantPhone: string | null
    aadhaarNumber: string | null
    pincode: string | null
    address: string | null
    hasTokenNumber: boolean | null
    declarationAcknowledgement: string | null
    acceptedTerms: boolean | null
    registrationFee: Decimal | null
    convenienceFee: Decimal | null
    gst: Decimal | null
    totalAmount: Decimal | null
    currency: string | null
    deliveryAddressLine: string | null
    deliveryCity: string | null
    deliveryState: string | null
    deliveryPincode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PetRegistrationApplicationCountAggregateOutputType = {
    id: number
    applicationType: number
    identifierType: number
    identifierNumber: number
    submittedAt: number
    city: number
    state: number
    country: number
    applicantType: number
    applicantName: number
    fatherOrHusbandName: number
    applicantEmail: number
    applicantPhone: number
    aadhaarNumber: number
    pincode: number
    address: number
    hasTokenNumber: number
    declarationAcknowledgement: number
    acceptedTerms: number
    registrationFee: number
    convenienceFee: number
    gst: number
    totalAmount: number
    currency: number
    deliveryAddressLine: number
    deliveryCity: number
    deliveryState: number
    deliveryPincode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PetRegistrationApplicationAvgAggregateInputType = {
    registrationFee?: true
    convenienceFee?: true
    gst?: true
    totalAmount?: true
  }

  export type PetRegistrationApplicationSumAggregateInputType = {
    registrationFee?: true
    convenienceFee?: true
    gst?: true
    totalAmount?: true
  }

  export type PetRegistrationApplicationMinAggregateInputType = {
    id?: true
    applicationType?: true
    identifierType?: true
    identifierNumber?: true
    submittedAt?: true
    city?: true
    state?: true
    country?: true
    applicantType?: true
    applicantName?: true
    fatherOrHusbandName?: true
    applicantEmail?: true
    applicantPhone?: true
    aadhaarNumber?: true
    pincode?: true
    address?: true
    hasTokenNumber?: true
    declarationAcknowledgement?: true
    acceptedTerms?: true
    registrationFee?: true
    convenienceFee?: true
    gst?: true
    totalAmount?: true
    currency?: true
    deliveryAddressLine?: true
    deliveryCity?: true
    deliveryState?: true
    deliveryPincode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PetRegistrationApplicationMaxAggregateInputType = {
    id?: true
    applicationType?: true
    identifierType?: true
    identifierNumber?: true
    submittedAt?: true
    city?: true
    state?: true
    country?: true
    applicantType?: true
    applicantName?: true
    fatherOrHusbandName?: true
    applicantEmail?: true
    applicantPhone?: true
    aadhaarNumber?: true
    pincode?: true
    address?: true
    hasTokenNumber?: true
    declarationAcknowledgement?: true
    acceptedTerms?: true
    registrationFee?: true
    convenienceFee?: true
    gst?: true
    totalAmount?: true
    currency?: true
    deliveryAddressLine?: true
    deliveryCity?: true
    deliveryState?: true
    deliveryPincode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PetRegistrationApplicationCountAggregateInputType = {
    id?: true
    applicationType?: true
    identifierType?: true
    identifierNumber?: true
    submittedAt?: true
    city?: true
    state?: true
    country?: true
    applicantType?: true
    applicantName?: true
    fatherOrHusbandName?: true
    applicantEmail?: true
    applicantPhone?: true
    aadhaarNumber?: true
    pincode?: true
    address?: true
    hasTokenNumber?: true
    declarationAcknowledgement?: true
    acceptedTerms?: true
    registrationFee?: true
    convenienceFee?: true
    gst?: true
    totalAmount?: true
    currency?: true
    deliveryAddressLine?: true
    deliveryCity?: true
    deliveryState?: true
    deliveryPincode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PetRegistrationApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PetRegistrationApplication to aggregate.
     */
    where?: PetRegistrationApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetRegistrationApplications to fetch.
     */
    orderBy?: PetRegistrationApplicationOrderByWithRelationInput | PetRegistrationApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PetRegistrationApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetRegistrationApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetRegistrationApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PetRegistrationApplications
    **/
    _count?: true | PetRegistrationApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PetRegistrationApplicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PetRegistrationApplicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PetRegistrationApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PetRegistrationApplicationMaxAggregateInputType
  }

  export type GetPetRegistrationApplicationAggregateType<T extends PetRegistrationApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregatePetRegistrationApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePetRegistrationApplication[P]>
      : GetScalarType<T[P], AggregatePetRegistrationApplication[P]>
  }




  export type PetRegistrationApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PetRegistrationApplicationWhereInput
    orderBy?: PetRegistrationApplicationOrderByWithAggregationInput | PetRegistrationApplicationOrderByWithAggregationInput[]
    by: PetRegistrationApplicationScalarFieldEnum[] | PetRegistrationApplicationScalarFieldEnum
    having?: PetRegistrationApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PetRegistrationApplicationCountAggregateInputType | true
    _avg?: PetRegistrationApplicationAvgAggregateInputType
    _sum?: PetRegistrationApplicationSumAggregateInputType
    _min?: PetRegistrationApplicationMinAggregateInputType
    _max?: PetRegistrationApplicationMaxAggregateInputType
  }

  export type PetRegistrationApplicationGroupByOutputType = {
    id: string
    applicationType: $Enums.ApplicationType
    identifierType: $Enums.IdentifierType
    identifierNumber: string | null
    submittedAt: Date
    city: string
    state: string
    country: string
    applicantType: $Enums.ApplicantType
    applicantName: string
    fatherOrHusbandName: string | null
    applicantEmail: string
    applicantPhone: string
    aadhaarNumber: string | null
    pincode: string
    address: string
    hasTokenNumber: boolean
    declarationAcknowledgement: string
    acceptedTerms: boolean
    registrationFee: Decimal
    convenienceFee: Decimal
    gst: Decimal
    totalAmount: Decimal
    currency: string
    deliveryAddressLine: string
    deliveryCity: string
    deliveryState: string
    deliveryPincode: string
    createdAt: Date
    updatedAt: Date
    _count: PetRegistrationApplicationCountAggregateOutputType | null
    _avg: PetRegistrationApplicationAvgAggregateOutputType | null
    _sum: PetRegistrationApplicationSumAggregateOutputType | null
    _min: PetRegistrationApplicationMinAggregateOutputType | null
    _max: PetRegistrationApplicationMaxAggregateOutputType | null
  }

  type GetPetRegistrationApplicationGroupByPayload<T extends PetRegistrationApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PetRegistrationApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PetRegistrationApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PetRegistrationApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], PetRegistrationApplicationGroupByOutputType[P]>
        }
      >
    >


  export type PetRegistrationApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationType?: boolean
    identifierType?: boolean
    identifierNumber?: boolean
    submittedAt?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    applicantType?: boolean
    applicantName?: boolean
    fatherOrHusbandName?: boolean
    applicantEmail?: boolean
    applicantPhone?: boolean
    aadhaarNumber?: boolean
    pincode?: boolean
    address?: boolean
    hasTokenNumber?: boolean
    declarationAcknowledgement?: boolean
    acceptedTerms?: boolean
    registrationFee?: boolean
    convenienceFee?: boolean
    gst?: boolean
    totalAmount?: boolean
    currency?: boolean
    deliveryAddressLine?: boolean
    deliveryCity?: boolean
    deliveryState?: boolean
    deliveryPincode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    documents?: boolean | PetRegistrationApplication$documentsArgs<ExtArgs>
    checkoutItems?: boolean | PetRegistrationApplication$checkoutItemsArgs<ExtArgs>
    pets?: boolean | PetRegistrationApplication$petsArgs<ExtArgs>
    _count?: boolean | PetRegistrationApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["petRegistrationApplication"]>

  export type PetRegistrationApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationType?: boolean
    identifierType?: boolean
    identifierNumber?: boolean
    submittedAt?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    applicantType?: boolean
    applicantName?: boolean
    fatherOrHusbandName?: boolean
    applicantEmail?: boolean
    applicantPhone?: boolean
    aadhaarNumber?: boolean
    pincode?: boolean
    address?: boolean
    hasTokenNumber?: boolean
    declarationAcknowledgement?: boolean
    acceptedTerms?: boolean
    registrationFee?: boolean
    convenienceFee?: boolean
    gst?: boolean
    totalAmount?: boolean
    currency?: boolean
    deliveryAddressLine?: boolean
    deliveryCity?: boolean
    deliveryState?: boolean
    deliveryPincode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["petRegistrationApplication"]>

  export type PetRegistrationApplicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationType?: boolean
    identifierType?: boolean
    identifierNumber?: boolean
    submittedAt?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    applicantType?: boolean
    applicantName?: boolean
    fatherOrHusbandName?: boolean
    applicantEmail?: boolean
    applicantPhone?: boolean
    aadhaarNumber?: boolean
    pincode?: boolean
    address?: boolean
    hasTokenNumber?: boolean
    declarationAcknowledgement?: boolean
    acceptedTerms?: boolean
    registrationFee?: boolean
    convenienceFee?: boolean
    gst?: boolean
    totalAmount?: boolean
    currency?: boolean
    deliveryAddressLine?: boolean
    deliveryCity?: boolean
    deliveryState?: boolean
    deliveryPincode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["petRegistrationApplication"]>

  export type PetRegistrationApplicationSelectScalar = {
    id?: boolean
    applicationType?: boolean
    identifierType?: boolean
    identifierNumber?: boolean
    submittedAt?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    applicantType?: boolean
    applicantName?: boolean
    fatherOrHusbandName?: boolean
    applicantEmail?: boolean
    applicantPhone?: boolean
    aadhaarNumber?: boolean
    pincode?: boolean
    address?: boolean
    hasTokenNumber?: boolean
    declarationAcknowledgement?: boolean
    acceptedTerms?: boolean
    registrationFee?: boolean
    convenienceFee?: boolean
    gst?: boolean
    totalAmount?: boolean
    currency?: boolean
    deliveryAddressLine?: boolean
    deliveryCity?: boolean
    deliveryState?: boolean
    deliveryPincode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PetRegistrationApplicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "applicationType" | "identifierType" | "identifierNumber" | "submittedAt" | "city" | "state" | "country" | "applicantType" | "applicantName" | "fatherOrHusbandName" | "applicantEmail" | "applicantPhone" | "aadhaarNumber" | "pincode" | "address" | "hasTokenNumber" | "declarationAcknowledgement" | "acceptedTerms" | "registrationFee" | "convenienceFee" | "gst" | "totalAmount" | "currency" | "deliveryAddressLine" | "deliveryCity" | "deliveryState" | "deliveryPincode" | "createdAt" | "updatedAt", ExtArgs["result"]["petRegistrationApplication"]>
  export type PetRegistrationApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | PetRegistrationApplication$documentsArgs<ExtArgs>
    checkoutItems?: boolean | PetRegistrationApplication$checkoutItemsArgs<ExtArgs>
    pets?: boolean | PetRegistrationApplication$petsArgs<ExtArgs>
    _count?: boolean | PetRegistrationApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PetRegistrationApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PetRegistrationApplicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PetRegistrationApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PetRegistrationApplication"
    objects: {
      documents: Prisma.$ApplicationDocumentPayload<ExtArgs>[]
      checkoutItems: Prisma.$CheckoutItemPayload<ExtArgs>[]
      pets: Prisma.$RegisteredPetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicationType: $Enums.ApplicationType
      identifierType: $Enums.IdentifierType
      identifierNumber: string | null
      submittedAt: Date
      city: string
      state: string
      country: string
      applicantType: $Enums.ApplicantType
      applicantName: string
      fatherOrHusbandName: string | null
      applicantEmail: string
      applicantPhone: string
      aadhaarNumber: string | null
      pincode: string
      address: string
      hasTokenNumber: boolean
      declarationAcknowledgement: string
      acceptedTerms: boolean
      registrationFee: Prisma.Decimal
      convenienceFee: Prisma.Decimal
      gst: Prisma.Decimal
      totalAmount: Prisma.Decimal
      currency: string
      deliveryAddressLine: string
      deliveryCity: string
      deliveryState: string
      deliveryPincode: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["petRegistrationApplication"]>
    composites: {}
  }

  type PetRegistrationApplicationGetPayload<S extends boolean | null | undefined | PetRegistrationApplicationDefaultArgs> = $Result.GetResult<Prisma.$PetRegistrationApplicationPayload, S>

  type PetRegistrationApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PetRegistrationApplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PetRegistrationApplicationCountAggregateInputType | true
    }

  export interface PetRegistrationApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PetRegistrationApplication'], meta: { name: 'PetRegistrationApplication' } }
    /**
     * Find zero or one PetRegistrationApplication that matches the filter.
     * @param {PetRegistrationApplicationFindUniqueArgs} args - Arguments to find a PetRegistrationApplication
     * @example
     * // Get one PetRegistrationApplication
     * const petRegistrationApplication = await prisma.petRegistrationApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PetRegistrationApplicationFindUniqueArgs>(args: SelectSubset<T, PetRegistrationApplicationFindUniqueArgs<ExtArgs>>): Prisma__PetRegistrationApplicationClient<$Result.GetResult<Prisma.$PetRegistrationApplicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PetRegistrationApplication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PetRegistrationApplicationFindUniqueOrThrowArgs} args - Arguments to find a PetRegistrationApplication
     * @example
     * // Get one PetRegistrationApplication
     * const petRegistrationApplication = await prisma.petRegistrationApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PetRegistrationApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, PetRegistrationApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PetRegistrationApplicationClient<$Result.GetResult<Prisma.$PetRegistrationApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PetRegistrationApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetRegistrationApplicationFindFirstArgs} args - Arguments to find a PetRegistrationApplication
     * @example
     * // Get one PetRegistrationApplication
     * const petRegistrationApplication = await prisma.petRegistrationApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PetRegistrationApplicationFindFirstArgs>(args?: SelectSubset<T, PetRegistrationApplicationFindFirstArgs<ExtArgs>>): Prisma__PetRegistrationApplicationClient<$Result.GetResult<Prisma.$PetRegistrationApplicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PetRegistrationApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetRegistrationApplicationFindFirstOrThrowArgs} args - Arguments to find a PetRegistrationApplication
     * @example
     * // Get one PetRegistrationApplication
     * const petRegistrationApplication = await prisma.petRegistrationApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PetRegistrationApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, PetRegistrationApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PetRegistrationApplicationClient<$Result.GetResult<Prisma.$PetRegistrationApplicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PetRegistrationApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetRegistrationApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PetRegistrationApplications
     * const petRegistrationApplications = await prisma.petRegistrationApplication.findMany()
     * 
     * // Get first 10 PetRegistrationApplications
     * const petRegistrationApplications = await prisma.petRegistrationApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const petRegistrationApplicationWithIdOnly = await prisma.petRegistrationApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PetRegistrationApplicationFindManyArgs>(args?: SelectSubset<T, PetRegistrationApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetRegistrationApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PetRegistrationApplication.
     * @param {PetRegistrationApplicationCreateArgs} args - Arguments to create a PetRegistrationApplication.
     * @example
     * // Create one PetRegistrationApplication
     * const PetRegistrationApplication = await prisma.petRegistrationApplication.create({
     *   data: {
     *     // ... data to create a PetRegistrationApplication
     *   }
     * })
     * 
     */
    create<T extends PetRegistrationApplicationCreateArgs>(args: SelectSubset<T, PetRegistrationApplicationCreateArgs<ExtArgs>>): Prisma__PetRegistrationApplicationClient<$Result.GetResult<Prisma.$PetRegistrationApplicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PetRegistrationApplications.
     * @param {PetRegistrationApplicationCreateManyArgs} args - Arguments to create many PetRegistrationApplications.
     * @example
     * // Create many PetRegistrationApplications
     * const petRegistrationApplication = await prisma.petRegistrationApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PetRegistrationApplicationCreateManyArgs>(args?: SelectSubset<T, PetRegistrationApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PetRegistrationApplications and returns the data saved in the database.
     * @param {PetRegistrationApplicationCreateManyAndReturnArgs} args - Arguments to create many PetRegistrationApplications.
     * @example
     * // Create many PetRegistrationApplications
     * const petRegistrationApplication = await prisma.petRegistrationApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PetRegistrationApplications and only return the `id`
     * const petRegistrationApplicationWithIdOnly = await prisma.petRegistrationApplication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PetRegistrationApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, PetRegistrationApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetRegistrationApplicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PetRegistrationApplication.
     * @param {PetRegistrationApplicationDeleteArgs} args - Arguments to delete one PetRegistrationApplication.
     * @example
     * // Delete one PetRegistrationApplication
     * const PetRegistrationApplication = await prisma.petRegistrationApplication.delete({
     *   where: {
     *     // ... filter to delete one PetRegistrationApplication
     *   }
     * })
     * 
     */
    delete<T extends PetRegistrationApplicationDeleteArgs>(args: SelectSubset<T, PetRegistrationApplicationDeleteArgs<ExtArgs>>): Prisma__PetRegistrationApplicationClient<$Result.GetResult<Prisma.$PetRegistrationApplicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PetRegistrationApplication.
     * @param {PetRegistrationApplicationUpdateArgs} args - Arguments to update one PetRegistrationApplication.
     * @example
     * // Update one PetRegistrationApplication
     * const petRegistrationApplication = await prisma.petRegistrationApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PetRegistrationApplicationUpdateArgs>(args: SelectSubset<T, PetRegistrationApplicationUpdateArgs<ExtArgs>>): Prisma__PetRegistrationApplicationClient<$Result.GetResult<Prisma.$PetRegistrationApplicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PetRegistrationApplications.
     * @param {PetRegistrationApplicationDeleteManyArgs} args - Arguments to filter PetRegistrationApplications to delete.
     * @example
     * // Delete a few PetRegistrationApplications
     * const { count } = await prisma.petRegistrationApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PetRegistrationApplicationDeleteManyArgs>(args?: SelectSubset<T, PetRegistrationApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PetRegistrationApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetRegistrationApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PetRegistrationApplications
     * const petRegistrationApplication = await prisma.petRegistrationApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PetRegistrationApplicationUpdateManyArgs>(args: SelectSubset<T, PetRegistrationApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PetRegistrationApplications and returns the data updated in the database.
     * @param {PetRegistrationApplicationUpdateManyAndReturnArgs} args - Arguments to update many PetRegistrationApplications.
     * @example
     * // Update many PetRegistrationApplications
     * const petRegistrationApplication = await prisma.petRegistrationApplication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PetRegistrationApplications and only return the `id`
     * const petRegistrationApplicationWithIdOnly = await prisma.petRegistrationApplication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PetRegistrationApplicationUpdateManyAndReturnArgs>(args: SelectSubset<T, PetRegistrationApplicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetRegistrationApplicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PetRegistrationApplication.
     * @param {PetRegistrationApplicationUpsertArgs} args - Arguments to update or create a PetRegistrationApplication.
     * @example
     * // Update or create a PetRegistrationApplication
     * const petRegistrationApplication = await prisma.petRegistrationApplication.upsert({
     *   create: {
     *     // ... data to create a PetRegistrationApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PetRegistrationApplication we want to update
     *   }
     * })
     */
    upsert<T extends PetRegistrationApplicationUpsertArgs>(args: SelectSubset<T, PetRegistrationApplicationUpsertArgs<ExtArgs>>): Prisma__PetRegistrationApplicationClient<$Result.GetResult<Prisma.$PetRegistrationApplicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PetRegistrationApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetRegistrationApplicationCountArgs} args - Arguments to filter PetRegistrationApplications to count.
     * @example
     * // Count the number of PetRegistrationApplications
     * const count = await prisma.petRegistrationApplication.count({
     *   where: {
     *     // ... the filter for the PetRegistrationApplications we want to count
     *   }
     * })
    **/
    count<T extends PetRegistrationApplicationCountArgs>(
      args?: Subset<T, PetRegistrationApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PetRegistrationApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PetRegistrationApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetRegistrationApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PetRegistrationApplicationAggregateArgs>(args: Subset<T, PetRegistrationApplicationAggregateArgs>): Prisma.PrismaPromise<GetPetRegistrationApplicationAggregateType<T>>

    /**
     * Group by PetRegistrationApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetRegistrationApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PetRegistrationApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PetRegistrationApplicationGroupByArgs['orderBy'] }
        : { orderBy?: PetRegistrationApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PetRegistrationApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPetRegistrationApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PetRegistrationApplication model
   */
  readonly fields: PetRegistrationApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PetRegistrationApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PetRegistrationApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    documents<T extends PetRegistrationApplication$documentsArgs<ExtArgs> = {}>(args?: Subset<T, PetRegistrationApplication$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    checkoutItems<T extends PetRegistrationApplication$checkoutItemsArgs<ExtArgs> = {}>(args?: Subset<T, PetRegistrationApplication$checkoutItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckoutItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pets<T extends PetRegistrationApplication$petsArgs<ExtArgs> = {}>(args?: Subset<T, PetRegistrationApplication$petsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegisteredPetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PetRegistrationApplication model
   */
  interface PetRegistrationApplicationFieldRefs {
    readonly id: FieldRef<"PetRegistrationApplication", 'String'>
    readonly applicationType: FieldRef<"PetRegistrationApplication", 'ApplicationType'>
    readonly identifierType: FieldRef<"PetRegistrationApplication", 'IdentifierType'>
    readonly identifierNumber: FieldRef<"PetRegistrationApplication", 'String'>
    readonly submittedAt: FieldRef<"PetRegistrationApplication", 'DateTime'>
    readonly city: FieldRef<"PetRegistrationApplication", 'String'>
    readonly state: FieldRef<"PetRegistrationApplication", 'String'>
    readonly country: FieldRef<"PetRegistrationApplication", 'String'>
    readonly applicantType: FieldRef<"PetRegistrationApplication", 'ApplicantType'>
    readonly applicantName: FieldRef<"PetRegistrationApplication", 'String'>
    readonly fatherOrHusbandName: FieldRef<"PetRegistrationApplication", 'String'>
    readonly applicantEmail: FieldRef<"PetRegistrationApplication", 'String'>
    readonly applicantPhone: FieldRef<"PetRegistrationApplication", 'String'>
    readonly aadhaarNumber: FieldRef<"PetRegistrationApplication", 'String'>
    readonly pincode: FieldRef<"PetRegistrationApplication", 'String'>
    readonly address: FieldRef<"PetRegistrationApplication", 'String'>
    readonly hasTokenNumber: FieldRef<"PetRegistrationApplication", 'Boolean'>
    readonly declarationAcknowledgement: FieldRef<"PetRegistrationApplication", 'String'>
    readonly acceptedTerms: FieldRef<"PetRegistrationApplication", 'Boolean'>
    readonly registrationFee: FieldRef<"PetRegistrationApplication", 'Decimal'>
    readonly convenienceFee: FieldRef<"PetRegistrationApplication", 'Decimal'>
    readonly gst: FieldRef<"PetRegistrationApplication", 'Decimal'>
    readonly totalAmount: FieldRef<"PetRegistrationApplication", 'Decimal'>
    readonly currency: FieldRef<"PetRegistrationApplication", 'String'>
    readonly deliveryAddressLine: FieldRef<"PetRegistrationApplication", 'String'>
    readonly deliveryCity: FieldRef<"PetRegistrationApplication", 'String'>
    readonly deliveryState: FieldRef<"PetRegistrationApplication", 'String'>
    readonly deliveryPincode: FieldRef<"PetRegistrationApplication", 'String'>
    readonly createdAt: FieldRef<"PetRegistrationApplication", 'DateTime'>
    readonly updatedAt: FieldRef<"PetRegistrationApplication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PetRegistrationApplication findUnique
   */
  export type PetRegistrationApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetRegistrationApplication
     */
    select?: PetRegistrationApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetRegistrationApplication
     */
    omit?: PetRegistrationApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetRegistrationApplicationInclude<ExtArgs> | null
    /**
     * Filter, which PetRegistrationApplication to fetch.
     */
    where: PetRegistrationApplicationWhereUniqueInput
  }

  /**
   * PetRegistrationApplication findUniqueOrThrow
   */
  export type PetRegistrationApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetRegistrationApplication
     */
    select?: PetRegistrationApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetRegistrationApplication
     */
    omit?: PetRegistrationApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetRegistrationApplicationInclude<ExtArgs> | null
    /**
     * Filter, which PetRegistrationApplication to fetch.
     */
    where: PetRegistrationApplicationWhereUniqueInput
  }

  /**
   * PetRegistrationApplication findFirst
   */
  export type PetRegistrationApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetRegistrationApplication
     */
    select?: PetRegistrationApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetRegistrationApplication
     */
    omit?: PetRegistrationApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetRegistrationApplicationInclude<ExtArgs> | null
    /**
     * Filter, which PetRegistrationApplication to fetch.
     */
    where?: PetRegistrationApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetRegistrationApplications to fetch.
     */
    orderBy?: PetRegistrationApplicationOrderByWithRelationInput | PetRegistrationApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PetRegistrationApplications.
     */
    cursor?: PetRegistrationApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetRegistrationApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetRegistrationApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PetRegistrationApplications.
     */
    distinct?: PetRegistrationApplicationScalarFieldEnum | PetRegistrationApplicationScalarFieldEnum[]
  }

  /**
   * PetRegistrationApplication findFirstOrThrow
   */
  export type PetRegistrationApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetRegistrationApplication
     */
    select?: PetRegistrationApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetRegistrationApplication
     */
    omit?: PetRegistrationApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetRegistrationApplicationInclude<ExtArgs> | null
    /**
     * Filter, which PetRegistrationApplication to fetch.
     */
    where?: PetRegistrationApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetRegistrationApplications to fetch.
     */
    orderBy?: PetRegistrationApplicationOrderByWithRelationInput | PetRegistrationApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PetRegistrationApplications.
     */
    cursor?: PetRegistrationApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetRegistrationApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetRegistrationApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PetRegistrationApplications.
     */
    distinct?: PetRegistrationApplicationScalarFieldEnum | PetRegistrationApplicationScalarFieldEnum[]
  }

  /**
   * PetRegistrationApplication findMany
   */
  export type PetRegistrationApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetRegistrationApplication
     */
    select?: PetRegistrationApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetRegistrationApplication
     */
    omit?: PetRegistrationApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetRegistrationApplicationInclude<ExtArgs> | null
    /**
     * Filter, which PetRegistrationApplications to fetch.
     */
    where?: PetRegistrationApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetRegistrationApplications to fetch.
     */
    orderBy?: PetRegistrationApplicationOrderByWithRelationInput | PetRegistrationApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PetRegistrationApplications.
     */
    cursor?: PetRegistrationApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetRegistrationApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetRegistrationApplications.
     */
    skip?: number
    distinct?: PetRegistrationApplicationScalarFieldEnum | PetRegistrationApplicationScalarFieldEnum[]
  }

  /**
   * PetRegistrationApplication create
   */
  export type PetRegistrationApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetRegistrationApplication
     */
    select?: PetRegistrationApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetRegistrationApplication
     */
    omit?: PetRegistrationApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetRegistrationApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a PetRegistrationApplication.
     */
    data: XOR<PetRegistrationApplicationCreateInput, PetRegistrationApplicationUncheckedCreateInput>
  }

  /**
   * PetRegistrationApplication createMany
   */
  export type PetRegistrationApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PetRegistrationApplications.
     */
    data: PetRegistrationApplicationCreateManyInput | PetRegistrationApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PetRegistrationApplication createManyAndReturn
   */
  export type PetRegistrationApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetRegistrationApplication
     */
    select?: PetRegistrationApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PetRegistrationApplication
     */
    omit?: PetRegistrationApplicationOmit<ExtArgs> | null
    /**
     * The data used to create many PetRegistrationApplications.
     */
    data: PetRegistrationApplicationCreateManyInput | PetRegistrationApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PetRegistrationApplication update
   */
  export type PetRegistrationApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetRegistrationApplication
     */
    select?: PetRegistrationApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetRegistrationApplication
     */
    omit?: PetRegistrationApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetRegistrationApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a PetRegistrationApplication.
     */
    data: XOR<PetRegistrationApplicationUpdateInput, PetRegistrationApplicationUncheckedUpdateInput>
    /**
     * Choose, which PetRegistrationApplication to update.
     */
    where: PetRegistrationApplicationWhereUniqueInput
  }

  /**
   * PetRegistrationApplication updateMany
   */
  export type PetRegistrationApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PetRegistrationApplications.
     */
    data: XOR<PetRegistrationApplicationUpdateManyMutationInput, PetRegistrationApplicationUncheckedUpdateManyInput>
    /**
     * Filter which PetRegistrationApplications to update
     */
    where?: PetRegistrationApplicationWhereInput
    /**
     * Limit how many PetRegistrationApplications to update.
     */
    limit?: number
  }

  /**
   * PetRegistrationApplication updateManyAndReturn
   */
  export type PetRegistrationApplicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetRegistrationApplication
     */
    select?: PetRegistrationApplicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PetRegistrationApplication
     */
    omit?: PetRegistrationApplicationOmit<ExtArgs> | null
    /**
     * The data used to update PetRegistrationApplications.
     */
    data: XOR<PetRegistrationApplicationUpdateManyMutationInput, PetRegistrationApplicationUncheckedUpdateManyInput>
    /**
     * Filter which PetRegistrationApplications to update
     */
    where?: PetRegistrationApplicationWhereInput
    /**
     * Limit how many PetRegistrationApplications to update.
     */
    limit?: number
  }

  /**
   * PetRegistrationApplication upsert
   */
  export type PetRegistrationApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetRegistrationApplication
     */
    select?: PetRegistrationApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetRegistrationApplication
     */
    omit?: PetRegistrationApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetRegistrationApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the PetRegistrationApplication to update in case it exists.
     */
    where: PetRegistrationApplicationWhereUniqueInput
    /**
     * In case the PetRegistrationApplication found by the `where` argument doesn't exist, create a new PetRegistrationApplication with this data.
     */
    create: XOR<PetRegistrationApplicationCreateInput, PetRegistrationApplicationUncheckedCreateInput>
    /**
     * In case the PetRegistrationApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PetRegistrationApplicationUpdateInput, PetRegistrationApplicationUncheckedUpdateInput>
  }

  /**
   * PetRegistrationApplication delete
   */
  export type PetRegistrationApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetRegistrationApplication
     */
    select?: PetRegistrationApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetRegistrationApplication
     */
    omit?: PetRegistrationApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetRegistrationApplicationInclude<ExtArgs> | null
    /**
     * Filter which PetRegistrationApplication to delete.
     */
    where: PetRegistrationApplicationWhereUniqueInput
  }

  /**
   * PetRegistrationApplication deleteMany
   */
  export type PetRegistrationApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PetRegistrationApplications to delete
     */
    where?: PetRegistrationApplicationWhereInput
    /**
     * Limit how many PetRegistrationApplications to delete.
     */
    limit?: number
  }

  /**
   * PetRegistrationApplication.documents
   */
  export type PetRegistrationApplication$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentInclude<ExtArgs> | null
    where?: ApplicationDocumentWhereInput
    orderBy?: ApplicationDocumentOrderByWithRelationInput | ApplicationDocumentOrderByWithRelationInput[]
    cursor?: ApplicationDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationDocumentScalarFieldEnum | ApplicationDocumentScalarFieldEnum[]
  }

  /**
   * PetRegistrationApplication.checkoutItems
   */
  export type PetRegistrationApplication$checkoutItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutItem
     */
    select?: CheckoutItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutItem
     */
    omit?: CheckoutItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutItemInclude<ExtArgs> | null
    where?: CheckoutItemWhereInput
    orderBy?: CheckoutItemOrderByWithRelationInput | CheckoutItemOrderByWithRelationInput[]
    cursor?: CheckoutItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckoutItemScalarFieldEnum | CheckoutItemScalarFieldEnum[]
  }

  /**
   * PetRegistrationApplication.pets
   */
  export type PetRegistrationApplication$petsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredPet
     */
    select?: RegisteredPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredPet
     */
    omit?: RegisteredPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisteredPetInclude<ExtArgs> | null
    where?: RegisteredPetWhereInput
    orderBy?: RegisteredPetOrderByWithRelationInput | RegisteredPetOrderByWithRelationInput[]
    cursor?: RegisteredPetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegisteredPetScalarFieldEnum | RegisteredPetScalarFieldEnum[]
  }

  /**
   * PetRegistrationApplication without action
   */
  export type PetRegistrationApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetRegistrationApplication
     */
    select?: PetRegistrationApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetRegistrationApplication
     */
    omit?: PetRegistrationApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetRegistrationApplicationInclude<ExtArgs> | null
  }


  /**
   * Model RegisteredPet
   */

  export type AggregateRegisteredPet = {
    _count: RegisteredPetCountAggregateOutputType | null
    _min: RegisteredPetMinAggregateOutputType | null
    _max: RegisteredPetMaxAggregateOutputType | null
  }

  export type RegisteredPetMinAggregateOutputType = {
    id: string | null
    applicationId: string | null
    petName: string | null
    breed: string | null
    dateOfBirth: Date | null
    ageOnRegistration: string | null
    lastRabiesVaccinationDate: Date | null
    veterinaryDoctorName: string | null
    veterinaryDoctorRegNumber: string | null
    veterinaryClinicOrHospitalName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    gender: $Enums.Gender | null
  }

  export type RegisteredPetMaxAggregateOutputType = {
    id: string | null
    applicationId: string | null
    petName: string | null
    breed: string | null
    dateOfBirth: Date | null
    ageOnRegistration: string | null
    lastRabiesVaccinationDate: Date | null
    veterinaryDoctorName: string | null
    veterinaryDoctorRegNumber: string | null
    veterinaryClinicOrHospitalName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    gender: $Enums.Gender | null
  }

  export type RegisteredPetCountAggregateOutputType = {
    id: number
    applicationId: number
    petName: number
    breed: number
    dateOfBirth: number
    ageOnRegistration: number
    lastRabiesVaccinationDate: number
    veterinaryDoctorName: number
    veterinaryDoctorRegNumber: number
    veterinaryClinicOrHospitalName: number
    createdAt: number
    updatedAt: number
    gender: number
    _all: number
  }


  export type RegisteredPetMinAggregateInputType = {
    id?: true
    applicationId?: true
    petName?: true
    breed?: true
    dateOfBirth?: true
    ageOnRegistration?: true
    lastRabiesVaccinationDate?: true
    veterinaryDoctorName?: true
    veterinaryDoctorRegNumber?: true
    veterinaryClinicOrHospitalName?: true
    createdAt?: true
    updatedAt?: true
    gender?: true
  }

  export type RegisteredPetMaxAggregateInputType = {
    id?: true
    applicationId?: true
    petName?: true
    breed?: true
    dateOfBirth?: true
    ageOnRegistration?: true
    lastRabiesVaccinationDate?: true
    veterinaryDoctorName?: true
    veterinaryDoctorRegNumber?: true
    veterinaryClinicOrHospitalName?: true
    createdAt?: true
    updatedAt?: true
    gender?: true
  }

  export type RegisteredPetCountAggregateInputType = {
    id?: true
    applicationId?: true
    petName?: true
    breed?: true
    dateOfBirth?: true
    ageOnRegistration?: true
    lastRabiesVaccinationDate?: true
    veterinaryDoctorName?: true
    veterinaryDoctorRegNumber?: true
    veterinaryClinicOrHospitalName?: true
    createdAt?: true
    updatedAt?: true
    gender?: true
    _all?: true
  }

  export type RegisteredPetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegisteredPet to aggregate.
     */
    where?: RegisteredPetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegisteredPets to fetch.
     */
    orderBy?: RegisteredPetOrderByWithRelationInput | RegisteredPetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegisteredPetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegisteredPets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegisteredPets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RegisteredPets
    **/
    _count?: true | RegisteredPetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegisteredPetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegisteredPetMaxAggregateInputType
  }

  export type GetRegisteredPetAggregateType<T extends RegisteredPetAggregateArgs> = {
        [P in keyof T & keyof AggregateRegisteredPet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegisteredPet[P]>
      : GetScalarType<T[P], AggregateRegisteredPet[P]>
  }




  export type RegisteredPetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegisteredPetWhereInput
    orderBy?: RegisteredPetOrderByWithAggregationInput | RegisteredPetOrderByWithAggregationInput[]
    by: RegisteredPetScalarFieldEnum[] | RegisteredPetScalarFieldEnum
    having?: RegisteredPetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegisteredPetCountAggregateInputType | true
    _min?: RegisteredPetMinAggregateInputType
    _max?: RegisteredPetMaxAggregateInputType
  }

  export type RegisteredPetGroupByOutputType = {
    id: string
    applicationId: string
    petName: string
    breed: string
    dateOfBirth: Date
    ageOnRegistration: string
    lastRabiesVaccinationDate: Date
    veterinaryDoctorName: string
    veterinaryDoctorRegNumber: string
    veterinaryClinicOrHospitalName: string
    createdAt: Date
    updatedAt: Date
    gender: $Enums.Gender
    _count: RegisteredPetCountAggregateOutputType | null
    _min: RegisteredPetMinAggregateOutputType | null
    _max: RegisteredPetMaxAggregateOutputType | null
  }

  type GetRegisteredPetGroupByPayload<T extends RegisteredPetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegisteredPetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegisteredPetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegisteredPetGroupByOutputType[P]>
            : GetScalarType<T[P], RegisteredPetGroupByOutputType[P]>
        }
      >
    >


  export type RegisteredPetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    petName?: boolean
    breed?: boolean
    dateOfBirth?: boolean
    ageOnRegistration?: boolean
    lastRabiesVaccinationDate?: boolean
    veterinaryDoctorName?: boolean
    veterinaryDoctorRegNumber?: boolean
    veterinaryClinicOrHospitalName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gender?: boolean
    documents?: boolean | RegisteredPet$documentsArgs<ExtArgs>
    application?: boolean | PetRegistrationApplicationDefaultArgs<ExtArgs>
    _count?: boolean | RegisteredPetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["registeredPet"]>

  export type RegisteredPetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    petName?: boolean
    breed?: boolean
    dateOfBirth?: boolean
    ageOnRegistration?: boolean
    lastRabiesVaccinationDate?: boolean
    veterinaryDoctorName?: boolean
    veterinaryDoctorRegNumber?: boolean
    veterinaryClinicOrHospitalName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gender?: boolean
    application?: boolean | PetRegistrationApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["registeredPet"]>

  export type RegisteredPetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    petName?: boolean
    breed?: boolean
    dateOfBirth?: boolean
    ageOnRegistration?: boolean
    lastRabiesVaccinationDate?: boolean
    veterinaryDoctorName?: boolean
    veterinaryDoctorRegNumber?: boolean
    veterinaryClinicOrHospitalName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gender?: boolean
    application?: boolean | PetRegistrationApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["registeredPet"]>

  export type RegisteredPetSelectScalar = {
    id?: boolean
    applicationId?: boolean
    petName?: boolean
    breed?: boolean
    dateOfBirth?: boolean
    ageOnRegistration?: boolean
    lastRabiesVaccinationDate?: boolean
    veterinaryDoctorName?: boolean
    veterinaryDoctorRegNumber?: boolean
    veterinaryClinicOrHospitalName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gender?: boolean
  }

  export type RegisteredPetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "applicationId" | "petName" | "breed" | "dateOfBirth" | "ageOnRegistration" | "lastRabiesVaccinationDate" | "veterinaryDoctorName" | "veterinaryDoctorRegNumber" | "veterinaryClinicOrHospitalName" | "createdAt" | "updatedAt" | "gender", ExtArgs["result"]["registeredPet"]>
  export type RegisteredPetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | RegisteredPet$documentsArgs<ExtArgs>
    application?: boolean | PetRegistrationApplicationDefaultArgs<ExtArgs>
    _count?: boolean | RegisteredPetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RegisteredPetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | PetRegistrationApplicationDefaultArgs<ExtArgs>
  }
  export type RegisteredPetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | PetRegistrationApplicationDefaultArgs<ExtArgs>
  }

  export type $RegisteredPetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RegisteredPet"
    objects: {
      documents: Prisma.$PetDocumentPayload<ExtArgs>[]
      application: Prisma.$PetRegistrationApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicationId: string
      petName: string
      breed: string
      dateOfBirth: Date
      ageOnRegistration: string
      lastRabiesVaccinationDate: Date
      veterinaryDoctorName: string
      veterinaryDoctorRegNumber: string
      veterinaryClinicOrHospitalName: string
      createdAt: Date
      updatedAt: Date
      gender: $Enums.Gender
    }, ExtArgs["result"]["registeredPet"]>
    composites: {}
  }

  type RegisteredPetGetPayload<S extends boolean | null | undefined | RegisteredPetDefaultArgs> = $Result.GetResult<Prisma.$RegisteredPetPayload, S>

  type RegisteredPetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegisteredPetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegisteredPetCountAggregateInputType | true
    }

  export interface RegisteredPetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RegisteredPet'], meta: { name: 'RegisteredPet' } }
    /**
     * Find zero or one RegisteredPet that matches the filter.
     * @param {RegisteredPetFindUniqueArgs} args - Arguments to find a RegisteredPet
     * @example
     * // Get one RegisteredPet
     * const registeredPet = await prisma.registeredPet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegisteredPetFindUniqueArgs>(args: SelectSubset<T, RegisteredPetFindUniqueArgs<ExtArgs>>): Prisma__RegisteredPetClient<$Result.GetResult<Prisma.$RegisteredPetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RegisteredPet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegisteredPetFindUniqueOrThrowArgs} args - Arguments to find a RegisteredPet
     * @example
     * // Get one RegisteredPet
     * const registeredPet = await prisma.registeredPet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegisteredPetFindUniqueOrThrowArgs>(args: SelectSubset<T, RegisteredPetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegisteredPetClient<$Result.GetResult<Prisma.$RegisteredPetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegisteredPet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisteredPetFindFirstArgs} args - Arguments to find a RegisteredPet
     * @example
     * // Get one RegisteredPet
     * const registeredPet = await prisma.registeredPet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegisteredPetFindFirstArgs>(args?: SelectSubset<T, RegisteredPetFindFirstArgs<ExtArgs>>): Prisma__RegisteredPetClient<$Result.GetResult<Prisma.$RegisteredPetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegisteredPet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisteredPetFindFirstOrThrowArgs} args - Arguments to find a RegisteredPet
     * @example
     * // Get one RegisteredPet
     * const registeredPet = await prisma.registeredPet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegisteredPetFindFirstOrThrowArgs>(args?: SelectSubset<T, RegisteredPetFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegisteredPetClient<$Result.GetResult<Prisma.$RegisteredPetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RegisteredPets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisteredPetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RegisteredPets
     * const registeredPets = await prisma.registeredPet.findMany()
     * 
     * // Get first 10 RegisteredPets
     * const registeredPets = await prisma.registeredPet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const registeredPetWithIdOnly = await prisma.registeredPet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegisteredPetFindManyArgs>(args?: SelectSubset<T, RegisteredPetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegisteredPetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RegisteredPet.
     * @param {RegisteredPetCreateArgs} args - Arguments to create a RegisteredPet.
     * @example
     * // Create one RegisteredPet
     * const RegisteredPet = await prisma.registeredPet.create({
     *   data: {
     *     // ... data to create a RegisteredPet
     *   }
     * })
     * 
     */
    create<T extends RegisteredPetCreateArgs>(args: SelectSubset<T, RegisteredPetCreateArgs<ExtArgs>>): Prisma__RegisteredPetClient<$Result.GetResult<Prisma.$RegisteredPetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RegisteredPets.
     * @param {RegisteredPetCreateManyArgs} args - Arguments to create many RegisteredPets.
     * @example
     * // Create many RegisteredPets
     * const registeredPet = await prisma.registeredPet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegisteredPetCreateManyArgs>(args?: SelectSubset<T, RegisteredPetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RegisteredPets and returns the data saved in the database.
     * @param {RegisteredPetCreateManyAndReturnArgs} args - Arguments to create many RegisteredPets.
     * @example
     * // Create many RegisteredPets
     * const registeredPet = await prisma.registeredPet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RegisteredPets and only return the `id`
     * const registeredPetWithIdOnly = await prisma.registeredPet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RegisteredPetCreateManyAndReturnArgs>(args?: SelectSubset<T, RegisteredPetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegisteredPetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RegisteredPet.
     * @param {RegisteredPetDeleteArgs} args - Arguments to delete one RegisteredPet.
     * @example
     * // Delete one RegisteredPet
     * const RegisteredPet = await prisma.registeredPet.delete({
     *   where: {
     *     // ... filter to delete one RegisteredPet
     *   }
     * })
     * 
     */
    delete<T extends RegisteredPetDeleteArgs>(args: SelectSubset<T, RegisteredPetDeleteArgs<ExtArgs>>): Prisma__RegisteredPetClient<$Result.GetResult<Prisma.$RegisteredPetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RegisteredPet.
     * @param {RegisteredPetUpdateArgs} args - Arguments to update one RegisteredPet.
     * @example
     * // Update one RegisteredPet
     * const registeredPet = await prisma.registeredPet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegisteredPetUpdateArgs>(args: SelectSubset<T, RegisteredPetUpdateArgs<ExtArgs>>): Prisma__RegisteredPetClient<$Result.GetResult<Prisma.$RegisteredPetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RegisteredPets.
     * @param {RegisteredPetDeleteManyArgs} args - Arguments to filter RegisteredPets to delete.
     * @example
     * // Delete a few RegisteredPets
     * const { count } = await prisma.registeredPet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegisteredPetDeleteManyArgs>(args?: SelectSubset<T, RegisteredPetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegisteredPets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisteredPetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RegisteredPets
     * const registeredPet = await prisma.registeredPet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegisteredPetUpdateManyArgs>(args: SelectSubset<T, RegisteredPetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegisteredPets and returns the data updated in the database.
     * @param {RegisteredPetUpdateManyAndReturnArgs} args - Arguments to update many RegisteredPets.
     * @example
     * // Update many RegisteredPets
     * const registeredPet = await prisma.registeredPet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RegisteredPets and only return the `id`
     * const registeredPetWithIdOnly = await prisma.registeredPet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RegisteredPetUpdateManyAndReturnArgs>(args: SelectSubset<T, RegisteredPetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegisteredPetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RegisteredPet.
     * @param {RegisteredPetUpsertArgs} args - Arguments to update or create a RegisteredPet.
     * @example
     * // Update or create a RegisteredPet
     * const registeredPet = await prisma.registeredPet.upsert({
     *   create: {
     *     // ... data to create a RegisteredPet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RegisteredPet we want to update
     *   }
     * })
     */
    upsert<T extends RegisteredPetUpsertArgs>(args: SelectSubset<T, RegisteredPetUpsertArgs<ExtArgs>>): Prisma__RegisteredPetClient<$Result.GetResult<Prisma.$RegisteredPetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RegisteredPets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisteredPetCountArgs} args - Arguments to filter RegisteredPets to count.
     * @example
     * // Count the number of RegisteredPets
     * const count = await prisma.registeredPet.count({
     *   where: {
     *     // ... the filter for the RegisteredPets we want to count
     *   }
     * })
    **/
    count<T extends RegisteredPetCountArgs>(
      args?: Subset<T, RegisteredPetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegisteredPetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RegisteredPet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisteredPetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegisteredPetAggregateArgs>(args: Subset<T, RegisteredPetAggregateArgs>): Prisma.PrismaPromise<GetRegisteredPetAggregateType<T>>

    /**
     * Group by RegisteredPet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisteredPetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegisteredPetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegisteredPetGroupByArgs['orderBy'] }
        : { orderBy?: RegisteredPetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegisteredPetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegisteredPetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RegisteredPet model
   */
  readonly fields: RegisteredPetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RegisteredPet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegisteredPetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    documents<T extends RegisteredPet$documentsArgs<ExtArgs> = {}>(args?: Subset<T, RegisteredPet$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    application<T extends PetRegistrationApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PetRegistrationApplicationDefaultArgs<ExtArgs>>): Prisma__PetRegistrationApplicationClient<$Result.GetResult<Prisma.$PetRegistrationApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RegisteredPet model
   */
  interface RegisteredPetFieldRefs {
    readonly id: FieldRef<"RegisteredPet", 'String'>
    readonly applicationId: FieldRef<"RegisteredPet", 'String'>
    readonly petName: FieldRef<"RegisteredPet", 'String'>
    readonly breed: FieldRef<"RegisteredPet", 'String'>
    readonly dateOfBirth: FieldRef<"RegisteredPet", 'DateTime'>
    readonly ageOnRegistration: FieldRef<"RegisteredPet", 'String'>
    readonly lastRabiesVaccinationDate: FieldRef<"RegisteredPet", 'DateTime'>
    readonly veterinaryDoctorName: FieldRef<"RegisteredPet", 'String'>
    readonly veterinaryDoctorRegNumber: FieldRef<"RegisteredPet", 'String'>
    readonly veterinaryClinicOrHospitalName: FieldRef<"RegisteredPet", 'String'>
    readonly createdAt: FieldRef<"RegisteredPet", 'DateTime'>
    readonly updatedAt: FieldRef<"RegisteredPet", 'DateTime'>
    readonly gender: FieldRef<"RegisteredPet", 'Gender'>
  }
    

  // Custom InputTypes
  /**
   * RegisteredPet findUnique
   */
  export type RegisteredPetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredPet
     */
    select?: RegisteredPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredPet
     */
    omit?: RegisteredPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisteredPetInclude<ExtArgs> | null
    /**
     * Filter, which RegisteredPet to fetch.
     */
    where: RegisteredPetWhereUniqueInput
  }

  /**
   * RegisteredPet findUniqueOrThrow
   */
  export type RegisteredPetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredPet
     */
    select?: RegisteredPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredPet
     */
    omit?: RegisteredPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisteredPetInclude<ExtArgs> | null
    /**
     * Filter, which RegisteredPet to fetch.
     */
    where: RegisteredPetWhereUniqueInput
  }

  /**
   * RegisteredPet findFirst
   */
  export type RegisteredPetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredPet
     */
    select?: RegisteredPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredPet
     */
    omit?: RegisteredPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisteredPetInclude<ExtArgs> | null
    /**
     * Filter, which RegisteredPet to fetch.
     */
    where?: RegisteredPetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegisteredPets to fetch.
     */
    orderBy?: RegisteredPetOrderByWithRelationInput | RegisteredPetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegisteredPets.
     */
    cursor?: RegisteredPetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegisteredPets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegisteredPets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegisteredPets.
     */
    distinct?: RegisteredPetScalarFieldEnum | RegisteredPetScalarFieldEnum[]
  }

  /**
   * RegisteredPet findFirstOrThrow
   */
  export type RegisteredPetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredPet
     */
    select?: RegisteredPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredPet
     */
    omit?: RegisteredPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisteredPetInclude<ExtArgs> | null
    /**
     * Filter, which RegisteredPet to fetch.
     */
    where?: RegisteredPetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegisteredPets to fetch.
     */
    orderBy?: RegisteredPetOrderByWithRelationInput | RegisteredPetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegisteredPets.
     */
    cursor?: RegisteredPetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegisteredPets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegisteredPets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegisteredPets.
     */
    distinct?: RegisteredPetScalarFieldEnum | RegisteredPetScalarFieldEnum[]
  }

  /**
   * RegisteredPet findMany
   */
  export type RegisteredPetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredPet
     */
    select?: RegisteredPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredPet
     */
    omit?: RegisteredPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisteredPetInclude<ExtArgs> | null
    /**
     * Filter, which RegisteredPets to fetch.
     */
    where?: RegisteredPetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegisteredPets to fetch.
     */
    orderBy?: RegisteredPetOrderByWithRelationInput | RegisteredPetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RegisteredPets.
     */
    cursor?: RegisteredPetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegisteredPets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegisteredPets.
     */
    skip?: number
    distinct?: RegisteredPetScalarFieldEnum | RegisteredPetScalarFieldEnum[]
  }

  /**
   * RegisteredPet create
   */
  export type RegisteredPetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredPet
     */
    select?: RegisteredPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredPet
     */
    omit?: RegisteredPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisteredPetInclude<ExtArgs> | null
    /**
     * The data needed to create a RegisteredPet.
     */
    data: XOR<RegisteredPetCreateInput, RegisteredPetUncheckedCreateInput>
  }

  /**
   * RegisteredPet createMany
   */
  export type RegisteredPetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RegisteredPets.
     */
    data: RegisteredPetCreateManyInput | RegisteredPetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RegisteredPet createManyAndReturn
   */
  export type RegisteredPetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredPet
     */
    select?: RegisteredPetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredPet
     */
    omit?: RegisteredPetOmit<ExtArgs> | null
    /**
     * The data used to create many RegisteredPets.
     */
    data: RegisteredPetCreateManyInput | RegisteredPetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisteredPetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RegisteredPet update
   */
  export type RegisteredPetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredPet
     */
    select?: RegisteredPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredPet
     */
    omit?: RegisteredPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisteredPetInclude<ExtArgs> | null
    /**
     * The data needed to update a RegisteredPet.
     */
    data: XOR<RegisteredPetUpdateInput, RegisteredPetUncheckedUpdateInput>
    /**
     * Choose, which RegisteredPet to update.
     */
    where: RegisteredPetWhereUniqueInput
  }

  /**
   * RegisteredPet updateMany
   */
  export type RegisteredPetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RegisteredPets.
     */
    data: XOR<RegisteredPetUpdateManyMutationInput, RegisteredPetUncheckedUpdateManyInput>
    /**
     * Filter which RegisteredPets to update
     */
    where?: RegisteredPetWhereInput
    /**
     * Limit how many RegisteredPets to update.
     */
    limit?: number
  }

  /**
   * RegisteredPet updateManyAndReturn
   */
  export type RegisteredPetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredPet
     */
    select?: RegisteredPetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredPet
     */
    omit?: RegisteredPetOmit<ExtArgs> | null
    /**
     * The data used to update RegisteredPets.
     */
    data: XOR<RegisteredPetUpdateManyMutationInput, RegisteredPetUncheckedUpdateManyInput>
    /**
     * Filter which RegisteredPets to update
     */
    where?: RegisteredPetWhereInput
    /**
     * Limit how many RegisteredPets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisteredPetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RegisteredPet upsert
   */
  export type RegisteredPetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredPet
     */
    select?: RegisteredPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredPet
     */
    omit?: RegisteredPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisteredPetInclude<ExtArgs> | null
    /**
     * The filter to search for the RegisteredPet to update in case it exists.
     */
    where: RegisteredPetWhereUniqueInput
    /**
     * In case the RegisteredPet found by the `where` argument doesn't exist, create a new RegisteredPet with this data.
     */
    create: XOR<RegisteredPetCreateInput, RegisteredPetUncheckedCreateInput>
    /**
     * In case the RegisteredPet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegisteredPetUpdateInput, RegisteredPetUncheckedUpdateInput>
  }

  /**
   * RegisteredPet delete
   */
  export type RegisteredPetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredPet
     */
    select?: RegisteredPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredPet
     */
    omit?: RegisteredPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisteredPetInclude<ExtArgs> | null
    /**
     * Filter which RegisteredPet to delete.
     */
    where: RegisteredPetWhereUniqueInput
  }

  /**
   * RegisteredPet deleteMany
   */
  export type RegisteredPetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegisteredPets to delete
     */
    where?: RegisteredPetWhereInput
    /**
     * Limit how many RegisteredPets to delete.
     */
    limit?: number
  }

  /**
   * RegisteredPet.documents
   */
  export type RegisteredPet$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetDocument
     */
    select?: PetDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetDocument
     */
    omit?: PetDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetDocumentInclude<ExtArgs> | null
    where?: PetDocumentWhereInput
    orderBy?: PetDocumentOrderByWithRelationInput | PetDocumentOrderByWithRelationInput[]
    cursor?: PetDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PetDocumentScalarFieldEnum | PetDocumentScalarFieldEnum[]
  }

  /**
   * RegisteredPet without action
   */
  export type RegisteredPetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredPet
     */
    select?: RegisteredPetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredPet
     */
    omit?: RegisteredPetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegisteredPetInclude<ExtArgs> | null
  }


  /**
   * Model ApplicationDocument
   */

  export type AggregateApplicationDocument = {
    _count: ApplicationDocumentCountAggregateOutputType | null
    _avg: ApplicationDocumentAvgAggregateOutputType | null
    _sum: ApplicationDocumentSumAggregateOutputType | null
    _min: ApplicationDocumentMinAggregateOutputType | null
    _max: ApplicationDocumentMaxAggregateOutputType | null
  }

  export type ApplicationDocumentAvgAggregateOutputType = {
    sizeBytes: number | null
  }

  export type ApplicationDocumentSumAggregateOutputType = {
    sizeBytes: bigint | null
  }

  export type ApplicationDocumentMinAggregateOutputType = {
    id: string | null
    applicationId: string | null
    documentType: $Enums.DocumentType | null
    fileName: string | null
    filePath: string | null
    mimeType: string | null
    sizeBytes: bigint | null
    createdAt: Date | null
  }

  export type ApplicationDocumentMaxAggregateOutputType = {
    id: string | null
    applicationId: string | null
    documentType: $Enums.DocumentType | null
    fileName: string | null
    filePath: string | null
    mimeType: string | null
    sizeBytes: bigint | null
    createdAt: Date | null
  }

  export type ApplicationDocumentCountAggregateOutputType = {
    id: number
    applicationId: number
    documentType: number
    fileName: number
    filePath: number
    mimeType: number
    sizeBytes: number
    createdAt: number
    _all: number
  }


  export type ApplicationDocumentAvgAggregateInputType = {
    sizeBytes?: true
  }

  export type ApplicationDocumentSumAggregateInputType = {
    sizeBytes?: true
  }

  export type ApplicationDocumentMinAggregateInputType = {
    id?: true
    applicationId?: true
    documentType?: true
    fileName?: true
    filePath?: true
    mimeType?: true
    sizeBytes?: true
    createdAt?: true
  }

  export type ApplicationDocumentMaxAggregateInputType = {
    id?: true
    applicationId?: true
    documentType?: true
    fileName?: true
    filePath?: true
    mimeType?: true
    sizeBytes?: true
    createdAt?: true
  }

  export type ApplicationDocumentCountAggregateInputType = {
    id?: true
    applicationId?: true
    documentType?: true
    fileName?: true
    filePath?: true
    mimeType?: true
    sizeBytes?: true
    createdAt?: true
    _all?: true
  }

  export type ApplicationDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApplicationDocument to aggregate.
     */
    where?: ApplicationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApplicationDocuments to fetch.
     */
    orderBy?: ApplicationDocumentOrderByWithRelationInput | ApplicationDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApplicationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApplicationDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApplicationDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApplicationDocuments
    **/
    _count?: true | ApplicationDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApplicationDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApplicationDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationDocumentMaxAggregateInputType
  }

  export type GetApplicationDocumentAggregateType<T extends ApplicationDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateApplicationDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplicationDocument[P]>
      : GetScalarType<T[P], AggregateApplicationDocument[P]>
  }




  export type ApplicationDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationDocumentWhereInput
    orderBy?: ApplicationDocumentOrderByWithAggregationInput | ApplicationDocumentOrderByWithAggregationInput[]
    by: ApplicationDocumentScalarFieldEnum[] | ApplicationDocumentScalarFieldEnum
    having?: ApplicationDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationDocumentCountAggregateInputType | true
    _avg?: ApplicationDocumentAvgAggregateInputType
    _sum?: ApplicationDocumentSumAggregateInputType
    _min?: ApplicationDocumentMinAggregateInputType
    _max?: ApplicationDocumentMaxAggregateInputType
  }

  export type ApplicationDocumentGroupByOutputType = {
    id: string
    applicationId: string
    documentType: $Enums.DocumentType
    fileName: string
    filePath: string
    mimeType: string
    sizeBytes: bigint
    createdAt: Date
    _count: ApplicationDocumentCountAggregateOutputType | null
    _avg: ApplicationDocumentAvgAggregateOutputType | null
    _sum: ApplicationDocumentSumAggregateOutputType | null
    _min: ApplicationDocumentMinAggregateOutputType | null
    _max: ApplicationDocumentMaxAggregateOutputType | null
  }

  type GetApplicationDocumentGroupByPayload<T extends ApplicationDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationDocumentGroupByOutputType[P]>
        }
      >
    >


  export type ApplicationDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    documentType?: boolean
    fileName?: boolean
    filePath?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    createdAt?: boolean
    application?: boolean | PetRegistrationApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applicationDocument"]>

  export type ApplicationDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    documentType?: boolean
    fileName?: boolean
    filePath?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    createdAt?: boolean
    application?: boolean | PetRegistrationApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applicationDocument"]>

  export type ApplicationDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    documentType?: boolean
    fileName?: boolean
    filePath?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    createdAt?: boolean
    application?: boolean | PetRegistrationApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applicationDocument"]>

  export type ApplicationDocumentSelectScalar = {
    id?: boolean
    applicationId?: boolean
    documentType?: boolean
    fileName?: boolean
    filePath?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    createdAt?: boolean
  }

  export type ApplicationDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "applicationId" | "documentType" | "fileName" | "filePath" | "mimeType" | "sizeBytes" | "createdAt", ExtArgs["result"]["applicationDocument"]>
  export type ApplicationDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | PetRegistrationApplicationDefaultArgs<ExtArgs>
  }
  export type ApplicationDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | PetRegistrationApplicationDefaultArgs<ExtArgs>
  }
  export type ApplicationDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | PetRegistrationApplicationDefaultArgs<ExtArgs>
  }

  export type $ApplicationDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApplicationDocument"
    objects: {
      application: Prisma.$PetRegistrationApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicationId: string
      documentType: $Enums.DocumentType
      fileName: string
      filePath: string
      mimeType: string
      sizeBytes: bigint
      createdAt: Date
    }, ExtArgs["result"]["applicationDocument"]>
    composites: {}
  }

  type ApplicationDocumentGetPayload<S extends boolean | null | undefined | ApplicationDocumentDefaultArgs> = $Result.GetResult<Prisma.$ApplicationDocumentPayload, S>

  type ApplicationDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApplicationDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApplicationDocumentCountAggregateInputType | true
    }

  export interface ApplicationDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApplicationDocument'], meta: { name: 'ApplicationDocument' } }
    /**
     * Find zero or one ApplicationDocument that matches the filter.
     * @param {ApplicationDocumentFindUniqueArgs} args - Arguments to find a ApplicationDocument
     * @example
     * // Get one ApplicationDocument
     * const applicationDocument = await prisma.applicationDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApplicationDocumentFindUniqueArgs>(args: SelectSubset<T, ApplicationDocumentFindUniqueArgs<ExtArgs>>): Prisma__ApplicationDocumentClient<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApplicationDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApplicationDocumentFindUniqueOrThrowArgs} args - Arguments to find a ApplicationDocument
     * @example
     * // Get one ApplicationDocument
     * const applicationDocument = await prisma.applicationDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApplicationDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, ApplicationDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApplicationDocumentClient<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApplicationDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDocumentFindFirstArgs} args - Arguments to find a ApplicationDocument
     * @example
     * // Get one ApplicationDocument
     * const applicationDocument = await prisma.applicationDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApplicationDocumentFindFirstArgs>(args?: SelectSubset<T, ApplicationDocumentFindFirstArgs<ExtArgs>>): Prisma__ApplicationDocumentClient<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApplicationDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDocumentFindFirstOrThrowArgs} args - Arguments to find a ApplicationDocument
     * @example
     * // Get one ApplicationDocument
     * const applicationDocument = await prisma.applicationDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApplicationDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, ApplicationDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApplicationDocumentClient<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApplicationDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApplicationDocuments
     * const applicationDocuments = await prisma.applicationDocument.findMany()
     * 
     * // Get first 10 ApplicationDocuments
     * const applicationDocuments = await prisma.applicationDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const applicationDocumentWithIdOnly = await prisma.applicationDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApplicationDocumentFindManyArgs>(args?: SelectSubset<T, ApplicationDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApplicationDocument.
     * @param {ApplicationDocumentCreateArgs} args - Arguments to create a ApplicationDocument.
     * @example
     * // Create one ApplicationDocument
     * const ApplicationDocument = await prisma.applicationDocument.create({
     *   data: {
     *     // ... data to create a ApplicationDocument
     *   }
     * })
     * 
     */
    create<T extends ApplicationDocumentCreateArgs>(args: SelectSubset<T, ApplicationDocumentCreateArgs<ExtArgs>>): Prisma__ApplicationDocumentClient<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApplicationDocuments.
     * @param {ApplicationDocumentCreateManyArgs} args - Arguments to create many ApplicationDocuments.
     * @example
     * // Create many ApplicationDocuments
     * const applicationDocument = await prisma.applicationDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApplicationDocumentCreateManyArgs>(args?: SelectSubset<T, ApplicationDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApplicationDocuments and returns the data saved in the database.
     * @param {ApplicationDocumentCreateManyAndReturnArgs} args - Arguments to create many ApplicationDocuments.
     * @example
     * // Create many ApplicationDocuments
     * const applicationDocument = await prisma.applicationDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApplicationDocuments and only return the `id`
     * const applicationDocumentWithIdOnly = await prisma.applicationDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApplicationDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, ApplicationDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApplicationDocument.
     * @param {ApplicationDocumentDeleteArgs} args - Arguments to delete one ApplicationDocument.
     * @example
     * // Delete one ApplicationDocument
     * const ApplicationDocument = await prisma.applicationDocument.delete({
     *   where: {
     *     // ... filter to delete one ApplicationDocument
     *   }
     * })
     * 
     */
    delete<T extends ApplicationDocumentDeleteArgs>(args: SelectSubset<T, ApplicationDocumentDeleteArgs<ExtArgs>>): Prisma__ApplicationDocumentClient<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApplicationDocument.
     * @param {ApplicationDocumentUpdateArgs} args - Arguments to update one ApplicationDocument.
     * @example
     * // Update one ApplicationDocument
     * const applicationDocument = await prisma.applicationDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApplicationDocumentUpdateArgs>(args: SelectSubset<T, ApplicationDocumentUpdateArgs<ExtArgs>>): Prisma__ApplicationDocumentClient<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApplicationDocuments.
     * @param {ApplicationDocumentDeleteManyArgs} args - Arguments to filter ApplicationDocuments to delete.
     * @example
     * // Delete a few ApplicationDocuments
     * const { count } = await prisma.applicationDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApplicationDocumentDeleteManyArgs>(args?: SelectSubset<T, ApplicationDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApplicationDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApplicationDocuments
     * const applicationDocument = await prisma.applicationDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApplicationDocumentUpdateManyArgs>(args: SelectSubset<T, ApplicationDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApplicationDocuments and returns the data updated in the database.
     * @param {ApplicationDocumentUpdateManyAndReturnArgs} args - Arguments to update many ApplicationDocuments.
     * @example
     * // Update many ApplicationDocuments
     * const applicationDocument = await prisma.applicationDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApplicationDocuments and only return the `id`
     * const applicationDocumentWithIdOnly = await prisma.applicationDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApplicationDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, ApplicationDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApplicationDocument.
     * @param {ApplicationDocumentUpsertArgs} args - Arguments to update or create a ApplicationDocument.
     * @example
     * // Update or create a ApplicationDocument
     * const applicationDocument = await prisma.applicationDocument.upsert({
     *   create: {
     *     // ... data to create a ApplicationDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApplicationDocument we want to update
     *   }
     * })
     */
    upsert<T extends ApplicationDocumentUpsertArgs>(args: SelectSubset<T, ApplicationDocumentUpsertArgs<ExtArgs>>): Prisma__ApplicationDocumentClient<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApplicationDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDocumentCountArgs} args - Arguments to filter ApplicationDocuments to count.
     * @example
     * // Count the number of ApplicationDocuments
     * const count = await prisma.applicationDocument.count({
     *   where: {
     *     // ... the filter for the ApplicationDocuments we want to count
     *   }
     * })
    **/
    count<T extends ApplicationDocumentCountArgs>(
      args?: Subset<T, ApplicationDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApplicationDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationDocumentAggregateArgs>(args: Subset<T, ApplicationDocumentAggregateArgs>): Prisma.PrismaPromise<GetApplicationDocumentAggregateType<T>>

    /**
     * Group by ApplicationDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApplicationDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApplicationDocumentGroupByArgs['orderBy'] }
        : { orderBy?: ApplicationDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApplicationDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApplicationDocument model
   */
  readonly fields: ApplicationDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApplicationDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApplicationDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends PetRegistrationApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PetRegistrationApplicationDefaultArgs<ExtArgs>>): Prisma__PetRegistrationApplicationClient<$Result.GetResult<Prisma.$PetRegistrationApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApplicationDocument model
   */
  interface ApplicationDocumentFieldRefs {
    readonly id: FieldRef<"ApplicationDocument", 'String'>
    readonly applicationId: FieldRef<"ApplicationDocument", 'String'>
    readonly documentType: FieldRef<"ApplicationDocument", 'DocumentType'>
    readonly fileName: FieldRef<"ApplicationDocument", 'String'>
    readonly filePath: FieldRef<"ApplicationDocument", 'String'>
    readonly mimeType: FieldRef<"ApplicationDocument", 'String'>
    readonly sizeBytes: FieldRef<"ApplicationDocument", 'BigInt'>
    readonly createdAt: FieldRef<"ApplicationDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApplicationDocument findUnique
   */
  export type ApplicationDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationDocument to fetch.
     */
    where: ApplicationDocumentWhereUniqueInput
  }

  /**
   * ApplicationDocument findUniqueOrThrow
   */
  export type ApplicationDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationDocument to fetch.
     */
    where: ApplicationDocumentWhereUniqueInput
  }

  /**
   * ApplicationDocument findFirst
   */
  export type ApplicationDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationDocument to fetch.
     */
    where?: ApplicationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApplicationDocuments to fetch.
     */
    orderBy?: ApplicationDocumentOrderByWithRelationInput | ApplicationDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApplicationDocuments.
     */
    cursor?: ApplicationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApplicationDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApplicationDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApplicationDocuments.
     */
    distinct?: ApplicationDocumentScalarFieldEnum | ApplicationDocumentScalarFieldEnum[]
  }

  /**
   * ApplicationDocument findFirstOrThrow
   */
  export type ApplicationDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationDocument to fetch.
     */
    where?: ApplicationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApplicationDocuments to fetch.
     */
    orderBy?: ApplicationDocumentOrderByWithRelationInput | ApplicationDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApplicationDocuments.
     */
    cursor?: ApplicationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApplicationDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApplicationDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApplicationDocuments.
     */
    distinct?: ApplicationDocumentScalarFieldEnum | ApplicationDocumentScalarFieldEnum[]
  }

  /**
   * ApplicationDocument findMany
   */
  export type ApplicationDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationDocuments to fetch.
     */
    where?: ApplicationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApplicationDocuments to fetch.
     */
    orderBy?: ApplicationDocumentOrderByWithRelationInput | ApplicationDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApplicationDocuments.
     */
    cursor?: ApplicationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApplicationDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApplicationDocuments.
     */
    skip?: number
    distinct?: ApplicationDocumentScalarFieldEnum | ApplicationDocumentScalarFieldEnum[]
  }

  /**
   * ApplicationDocument create
   */
  export type ApplicationDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a ApplicationDocument.
     */
    data: XOR<ApplicationDocumentCreateInput, ApplicationDocumentUncheckedCreateInput>
  }

  /**
   * ApplicationDocument createMany
   */
  export type ApplicationDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApplicationDocuments.
     */
    data: ApplicationDocumentCreateManyInput | ApplicationDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApplicationDocument createManyAndReturn
   */
  export type ApplicationDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many ApplicationDocuments.
     */
    data: ApplicationDocumentCreateManyInput | ApplicationDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApplicationDocument update
   */
  export type ApplicationDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a ApplicationDocument.
     */
    data: XOR<ApplicationDocumentUpdateInput, ApplicationDocumentUncheckedUpdateInput>
    /**
     * Choose, which ApplicationDocument to update.
     */
    where: ApplicationDocumentWhereUniqueInput
  }

  /**
   * ApplicationDocument updateMany
   */
  export type ApplicationDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApplicationDocuments.
     */
    data: XOR<ApplicationDocumentUpdateManyMutationInput, ApplicationDocumentUncheckedUpdateManyInput>
    /**
     * Filter which ApplicationDocuments to update
     */
    where?: ApplicationDocumentWhereInput
    /**
     * Limit how many ApplicationDocuments to update.
     */
    limit?: number
  }

  /**
   * ApplicationDocument updateManyAndReturn
   */
  export type ApplicationDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * The data used to update ApplicationDocuments.
     */
    data: XOR<ApplicationDocumentUpdateManyMutationInput, ApplicationDocumentUncheckedUpdateManyInput>
    /**
     * Filter which ApplicationDocuments to update
     */
    where?: ApplicationDocumentWhereInput
    /**
     * Limit how many ApplicationDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApplicationDocument upsert
   */
  export type ApplicationDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the ApplicationDocument to update in case it exists.
     */
    where: ApplicationDocumentWhereUniqueInput
    /**
     * In case the ApplicationDocument found by the `where` argument doesn't exist, create a new ApplicationDocument with this data.
     */
    create: XOR<ApplicationDocumentCreateInput, ApplicationDocumentUncheckedCreateInput>
    /**
     * In case the ApplicationDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApplicationDocumentUpdateInput, ApplicationDocumentUncheckedUpdateInput>
  }

  /**
   * ApplicationDocument delete
   */
  export type ApplicationDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentInclude<ExtArgs> | null
    /**
     * Filter which ApplicationDocument to delete.
     */
    where: ApplicationDocumentWhereUniqueInput
  }

  /**
   * ApplicationDocument deleteMany
   */
  export type ApplicationDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApplicationDocuments to delete
     */
    where?: ApplicationDocumentWhereInput
    /**
     * Limit how many ApplicationDocuments to delete.
     */
    limit?: number
  }

  /**
   * ApplicationDocument without action
   */
  export type ApplicationDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentInclude<ExtArgs> | null
  }


  /**
   * Model PetDocument
   */

  export type AggregatePetDocument = {
    _count: PetDocumentCountAggregateOutputType | null
    _avg: PetDocumentAvgAggregateOutputType | null
    _sum: PetDocumentSumAggregateOutputType | null
    _min: PetDocumentMinAggregateOutputType | null
    _max: PetDocumentMaxAggregateOutputType | null
  }

  export type PetDocumentAvgAggregateOutputType = {
    sizeBytes: number | null
  }

  export type PetDocumentSumAggregateOutputType = {
    sizeBytes: bigint | null
  }

  export type PetDocumentMinAggregateOutputType = {
    id: string | null
    petId: string | null
    documentType: $Enums.DocumentType | null
    fileName: string | null
    filePath: string | null
    mimeType: string | null
    sizeBytes: bigint | null
    createdAt: Date | null
  }

  export type PetDocumentMaxAggregateOutputType = {
    id: string | null
    petId: string | null
    documentType: $Enums.DocumentType | null
    fileName: string | null
    filePath: string | null
    mimeType: string | null
    sizeBytes: bigint | null
    createdAt: Date | null
  }

  export type PetDocumentCountAggregateOutputType = {
    id: number
    petId: number
    documentType: number
    fileName: number
    filePath: number
    mimeType: number
    sizeBytes: number
    createdAt: number
    _all: number
  }


  export type PetDocumentAvgAggregateInputType = {
    sizeBytes?: true
  }

  export type PetDocumentSumAggregateInputType = {
    sizeBytes?: true
  }

  export type PetDocumentMinAggregateInputType = {
    id?: true
    petId?: true
    documentType?: true
    fileName?: true
    filePath?: true
    mimeType?: true
    sizeBytes?: true
    createdAt?: true
  }

  export type PetDocumentMaxAggregateInputType = {
    id?: true
    petId?: true
    documentType?: true
    fileName?: true
    filePath?: true
    mimeType?: true
    sizeBytes?: true
    createdAt?: true
  }

  export type PetDocumentCountAggregateInputType = {
    id?: true
    petId?: true
    documentType?: true
    fileName?: true
    filePath?: true
    mimeType?: true
    sizeBytes?: true
    createdAt?: true
    _all?: true
  }

  export type PetDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PetDocument to aggregate.
     */
    where?: PetDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetDocuments to fetch.
     */
    orderBy?: PetDocumentOrderByWithRelationInput | PetDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PetDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PetDocuments
    **/
    _count?: true | PetDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PetDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PetDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PetDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PetDocumentMaxAggregateInputType
  }

  export type GetPetDocumentAggregateType<T extends PetDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregatePetDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePetDocument[P]>
      : GetScalarType<T[P], AggregatePetDocument[P]>
  }




  export type PetDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PetDocumentWhereInput
    orderBy?: PetDocumentOrderByWithAggregationInput | PetDocumentOrderByWithAggregationInput[]
    by: PetDocumentScalarFieldEnum[] | PetDocumentScalarFieldEnum
    having?: PetDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PetDocumentCountAggregateInputType | true
    _avg?: PetDocumentAvgAggregateInputType
    _sum?: PetDocumentSumAggregateInputType
    _min?: PetDocumentMinAggregateInputType
    _max?: PetDocumentMaxAggregateInputType
  }

  export type PetDocumentGroupByOutputType = {
    id: string
    petId: string
    documentType: $Enums.DocumentType
    fileName: string
    filePath: string
    mimeType: string
    sizeBytes: bigint
    createdAt: Date
    _count: PetDocumentCountAggregateOutputType | null
    _avg: PetDocumentAvgAggregateOutputType | null
    _sum: PetDocumentSumAggregateOutputType | null
    _min: PetDocumentMinAggregateOutputType | null
    _max: PetDocumentMaxAggregateOutputType | null
  }

  type GetPetDocumentGroupByPayload<T extends PetDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PetDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PetDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PetDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], PetDocumentGroupByOutputType[P]>
        }
      >
    >


  export type PetDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    petId?: boolean
    documentType?: boolean
    fileName?: boolean
    filePath?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    createdAt?: boolean
    pet?: boolean | RegisteredPetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["petDocument"]>

  export type PetDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    petId?: boolean
    documentType?: boolean
    fileName?: boolean
    filePath?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    createdAt?: boolean
    pet?: boolean | RegisteredPetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["petDocument"]>

  export type PetDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    petId?: boolean
    documentType?: boolean
    fileName?: boolean
    filePath?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    createdAt?: boolean
    pet?: boolean | RegisteredPetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["petDocument"]>

  export type PetDocumentSelectScalar = {
    id?: boolean
    petId?: boolean
    documentType?: boolean
    fileName?: boolean
    filePath?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    createdAt?: boolean
  }

  export type PetDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "petId" | "documentType" | "fileName" | "filePath" | "mimeType" | "sizeBytes" | "createdAt", ExtArgs["result"]["petDocument"]>
  export type PetDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | RegisteredPetDefaultArgs<ExtArgs>
  }
  export type PetDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | RegisteredPetDefaultArgs<ExtArgs>
  }
  export type PetDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | RegisteredPetDefaultArgs<ExtArgs>
  }

  export type $PetDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PetDocument"
    objects: {
      pet: Prisma.$RegisteredPetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      petId: string
      documentType: $Enums.DocumentType
      fileName: string
      filePath: string
      mimeType: string
      sizeBytes: bigint
      createdAt: Date
    }, ExtArgs["result"]["petDocument"]>
    composites: {}
  }

  type PetDocumentGetPayload<S extends boolean | null | undefined | PetDocumentDefaultArgs> = $Result.GetResult<Prisma.$PetDocumentPayload, S>

  type PetDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PetDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PetDocumentCountAggregateInputType | true
    }

  export interface PetDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PetDocument'], meta: { name: 'PetDocument' } }
    /**
     * Find zero or one PetDocument that matches the filter.
     * @param {PetDocumentFindUniqueArgs} args - Arguments to find a PetDocument
     * @example
     * // Get one PetDocument
     * const petDocument = await prisma.petDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PetDocumentFindUniqueArgs>(args: SelectSubset<T, PetDocumentFindUniqueArgs<ExtArgs>>): Prisma__PetDocumentClient<$Result.GetResult<Prisma.$PetDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PetDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PetDocumentFindUniqueOrThrowArgs} args - Arguments to find a PetDocument
     * @example
     * // Get one PetDocument
     * const petDocument = await prisma.petDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PetDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, PetDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PetDocumentClient<$Result.GetResult<Prisma.$PetDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PetDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetDocumentFindFirstArgs} args - Arguments to find a PetDocument
     * @example
     * // Get one PetDocument
     * const petDocument = await prisma.petDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PetDocumentFindFirstArgs>(args?: SelectSubset<T, PetDocumentFindFirstArgs<ExtArgs>>): Prisma__PetDocumentClient<$Result.GetResult<Prisma.$PetDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PetDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetDocumentFindFirstOrThrowArgs} args - Arguments to find a PetDocument
     * @example
     * // Get one PetDocument
     * const petDocument = await prisma.petDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PetDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, PetDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PetDocumentClient<$Result.GetResult<Prisma.$PetDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PetDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PetDocuments
     * const petDocuments = await prisma.petDocument.findMany()
     * 
     * // Get first 10 PetDocuments
     * const petDocuments = await prisma.petDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const petDocumentWithIdOnly = await prisma.petDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PetDocumentFindManyArgs>(args?: SelectSubset<T, PetDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PetDocument.
     * @param {PetDocumentCreateArgs} args - Arguments to create a PetDocument.
     * @example
     * // Create one PetDocument
     * const PetDocument = await prisma.petDocument.create({
     *   data: {
     *     // ... data to create a PetDocument
     *   }
     * })
     * 
     */
    create<T extends PetDocumentCreateArgs>(args: SelectSubset<T, PetDocumentCreateArgs<ExtArgs>>): Prisma__PetDocumentClient<$Result.GetResult<Prisma.$PetDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PetDocuments.
     * @param {PetDocumentCreateManyArgs} args - Arguments to create many PetDocuments.
     * @example
     * // Create many PetDocuments
     * const petDocument = await prisma.petDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PetDocumentCreateManyArgs>(args?: SelectSubset<T, PetDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PetDocuments and returns the data saved in the database.
     * @param {PetDocumentCreateManyAndReturnArgs} args - Arguments to create many PetDocuments.
     * @example
     * // Create many PetDocuments
     * const petDocument = await prisma.petDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PetDocuments and only return the `id`
     * const petDocumentWithIdOnly = await prisma.petDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PetDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, PetDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PetDocument.
     * @param {PetDocumentDeleteArgs} args - Arguments to delete one PetDocument.
     * @example
     * // Delete one PetDocument
     * const PetDocument = await prisma.petDocument.delete({
     *   where: {
     *     // ... filter to delete one PetDocument
     *   }
     * })
     * 
     */
    delete<T extends PetDocumentDeleteArgs>(args: SelectSubset<T, PetDocumentDeleteArgs<ExtArgs>>): Prisma__PetDocumentClient<$Result.GetResult<Prisma.$PetDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PetDocument.
     * @param {PetDocumentUpdateArgs} args - Arguments to update one PetDocument.
     * @example
     * // Update one PetDocument
     * const petDocument = await prisma.petDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PetDocumentUpdateArgs>(args: SelectSubset<T, PetDocumentUpdateArgs<ExtArgs>>): Prisma__PetDocumentClient<$Result.GetResult<Prisma.$PetDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PetDocuments.
     * @param {PetDocumentDeleteManyArgs} args - Arguments to filter PetDocuments to delete.
     * @example
     * // Delete a few PetDocuments
     * const { count } = await prisma.petDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PetDocumentDeleteManyArgs>(args?: SelectSubset<T, PetDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PetDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PetDocuments
     * const petDocument = await prisma.petDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PetDocumentUpdateManyArgs>(args: SelectSubset<T, PetDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PetDocuments and returns the data updated in the database.
     * @param {PetDocumentUpdateManyAndReturnArgs} args - Arguments to update many PetDocuments.
     * @example
     * // Update many PetDocuments
     * const petDocument = await prisma.petDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PetDocuments and only return the `id`
     * const petDocumentWithIdOnly = await prisma.petDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PetDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, PetDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PetDocument.
     * @param {PetDocumentUpsertArgs} args - Arguments to update or create a PetDocument.
     * @example
     * // Update or create a PetDocument
     * const petDocument = await prisma.petDocument.upsert({
     *   create: {
     *     // ... data to create a PetDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PetDocument we want to update
     *   }
     * })
     */
    upsert<T extends PetDocumentUpsertArgs>(args: SelectSubset<T, PetDocumentUpsertArgs<ExtArgs>>): Prisma__PetDocumentClient<$Result.GetResult<Prisma.$PetDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PetDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetDocumentCountArgs} args - Arguments to filter PetDocuments to count.
     * @example
     * // Count the number of PetDocuments
     * const count = await prisma.petDocument.count({
     *   where: {
     *     // ... the filter for the PetDocuments we want to count
     *   }
     * })
    **/
    count<T extends PetDocumentCountArgs>(
      args?: Subset<T, PetDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PetDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PetDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PetDocumentAggregateArgs>(args: Subset<T, PetDocumentAggregateArgs>): Prisma.PrismaPromise<GetPetDocumentAggregateType<T>>

    /**
     * Group by PetDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PetDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PetDocumentGroupByArgs['orderBy'] }
        : { orderBy?: PetDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PetDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PetDocument model
   */
  readonly fields: PetDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PetDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PetDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pet<T extends RegisteredPetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegisteredPetDefaultArgs<ExtArgs>>): Prisma__RegisteredPetClient<$Result.GetResult<Prisma.$RegisteredPetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PetDocument model
   */
  interface PetDocumentFieldRefs {
    readonly id: FieldRef<"PetDocument", 'String'>
    readonly petId: FieldRef<"PetDocument", 'String'>
    readonly documentType: FieldRef<"PetDocument", 'DocumentType'>
    readonly fileName: FieldRef<"PetDocument", 'String'>
    readonly filePath: FieldRef<"PetDocument", 'String'>
    readonly mimeType: FieldRef<"PetDocument", 'String'>
    readonly sizeBytes: FieldRef<"PetDocument", 'BigInt'>
    readonly createdAt: FieldRef<"PetDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PetDocument findUnique
   */
  export type PetDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetDocument
     */
    select?: PetDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetDocument
     */
    omit?: PetDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PetDocument to fetch.
     */
    where: PetDocumentWhereUniqueInput
  }

  /**
   * PetDocument findUniqueOrThrow
   */
  export type PetDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetDocument
     */
    select?: PetDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetDocument
     */
    omit?: PetDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PetDocument to fetch.
     */
    where: PetDocumentWhereUniqueInput
  }

  /**
   * PetDocument findFirst
   */
  export type PetDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetDocument
     */
    select?: PetDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetDocument
     */
    omit?: PetDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PetDocument to fetch.
     */
    where?: PetDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetDocuments to fetch.
     */
    orderBy?: PetDocumentOrderByWithRelationInput | PetDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PetDocuments.
     */
    cursor?: PetDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PetDocuments.
     */
    distinct?: PetDocumentScalarFieldEnum | PetDocumentScalarFieldEnum[]
  }

  /**
   * PetDocument findFirstOrThrow
   */
  export type PetDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetDocument
     */
    select?: PetDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetDocument
     */
    omit?: PetDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PetDocument to fetch.
     */
    where?: PetDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetDocuments to fetch.
     */
    orderBy?: PetDocumentOrderByWithRelationInput | PetDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PetDocuments.
     */
    cursor?: PetDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PetDocuments.
     */
    distinct?: PetDocumentScalarFieldEnum | PetDocumentScalarFieldEnum[]
  }

  /**
   * PetDocument findMany
   */
  export type PetDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetDocument
     */
    select?: PetDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetDocument
     */
    omit?: PetDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PetDocuments to fetch.
     */
    where?: PetDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetDocuments to fetch.
     */
    orderBy?: PetDocumentOrderByWithRelationInput | PetDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PetDocuments.
     */
    cursor?: PetDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetDocuments.
     */
    skip?: number
    distinct?: PetDocumentScalarFieldEnum | PetDocumentScalarFieldEnum[]
  }

  /**
   * PetDocument create
   */
  export type PetDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetDocument
     */
    select?: PetDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetDocument
     */
    omit?: PetDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a PetDocument.
     */
    data: XOR<PetDocumentCreateInput, PetDocumentUncheckedCreateInput>
  }

  /**
   * PetDocument createMany
   */
  export type PetDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PetDocuments.
     */
    data: PetDocumentCreateManyInput | PetDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PetDocument createManyAndReturn
   */
  export type PetDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetDocument
     */
    select?: PetDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PetDocument
     */
    omit?: PetDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many PetDocuments.
     */
    data: PetDocumentCreateManyInput | PetDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PetDocument update
   */
  export type PetDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetDocument
     */
    select?: PetDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetDocument
     */
    omit?: PetDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a PetDocument.
     */
    data: XOR<PetDocumentUpdateInput, PetDocumentUncheckedUpdateInput>
    /**
     * Choose, which PetDocument to update.
     */
    where: PetDocumentWhereUniqueInput
  }

  /**
   * PetDocument updateMany
   */
  export type PetDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PetDocuments.
     */
    data: XOR<PetDocumentUpdateManyMutationInput, PetDocumentUncheckedUpdateManyInput>
    /**
     * Filter which PetDocuments to update
     */
    where?: PetDocumentWhereInput
    /**
     * Limit how many PetDocuments to update.
     */
    limit?: number
  }

  /**
   * PetDocument updateManyAndReturn
   */
  export type PetDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetDocument
     */
    select?: PetDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PetDocument
     */
    omit?: PetDocumentOmit<ExtArgs> | null
    /**
     * The data used to update PetDocuments.
     */
    data: XOR<PetDocumentUpdateManyMutationInput, PetDocumentUncheckedUpdateManyInput>
    /**
     * Filter which PetDocuments to update
     */
    where?: PetDocumentWhereInput
    /**
     * Limit how many PetDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PetDocument upsert
   */
  export type PetDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetDocument
     */
    select?: PetDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetDocument
     */
    omit?: PetDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the PetDocument to update in case it exists.
     */
    where: PetDocumentWhereUniqueInput
    /**
     * In case the PetDocument found by the `where` argument doesn't exist, create a new PetDocument with this data.
     */
    create: XOR<PetDocumentCreateInput, PetDocumentUncheckedCreateInput>
    /**
     * In case the PetDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PetDocumentUpdateInput, PetDocumentUncheckedUpdateInput>
  }

  /**
   * PetDocument delete
   */
  export type PetDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetDocument
     */
    select?: PetDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetDocument
     */
    omit?: PetDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetDocumentInclude<ExtArgs> | null
    /**
     * Filter which PetDocument to delete.
     */
    where: PetDocumentWhereUniqueInput
  }

  /**
   * PetDocument deleteMany
   */
  export type PetDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PetDocuments to delete
     */
    where?: PetDocumentWhereInput
    /**
     * Limit how many PetDocuments to delete.
     */
    limit?: number
  }

  /**
   * PetDocument without action
   */
  export type PetDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetDocument
     */
    select?: PetDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetDocument
     */
    omit?: PetDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetDocumentInclude<ExtArgs> | null
  }


  /**
   * Model CheckoutItem
   */

  export type AggregateCheckoutItem = {
    _count: CheckoutItemCountAggregateOutputType | null
    _avg: CheckoutItemAvgAggregateOutputType | null
    _sum: CheckoutItemSumAggregateOutputType | null
    _min: CheckoutItemMinAggregateOutputType | null
    _max: CheckoutItemMaxAggregateOutputType | null
  }

  export type CheckoutItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
  }

  export type CheckoutItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
  }

  export type CheckoutItemMinAggregateOutputType = {
    id: string | null
    applicationId: string | null
    sku: string | null
    itemName: string | null
    quantity: number | null
    unitPrice: Decimal | null
    createdAt: Date | null
  }

  export type CheckoutItemMaxAggregateOutputType = {
    id: string | null
    applicationId: string | null
    sku: string | null
    itemName: string | null
    quantity: number | null
    unitPrice: Decimal | null
    createdAt: Date | null
  }

  export type CheckoutItemCountAggregateOutputType = {
    id: number
    applicationId: number
    sku: number
    itemName: number
    quantity: number
    unitPrice: number
    createdAt: number
    _all: number
  }


  export type CheckoutItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
  }

  export type CheckoutItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
  }

  export type CheckoutItemMinAggregateInputType = {
    id?: true
    applicationId?: true
    sku?: true
    itemName?: true
    quantity?: true
    unitPrice?: true
    createdAt?: true
  }

  export type CheckoutItemMaxAggregateInputType = {
    id?: true
    applicationId?: true
    sku?: true
    itemName?: true
    quantity?: true
    unitPrice?: true
    createdAt?: true
  }

  export type CheckoutItemCountAggregateInputType = {
    id?: true
    applicationId?: true
    sku?: true
    itemName?: true
    quantity?: true
    unitPrice?: true
    createdAt?: true
    _all?: true
  }

  export type CheckoutItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheckoutItem to aggregate.
     */
    where?: CheckoutItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckoutItems to fetch.
     */
    orderBy?: CheckoutItemOrderByWithRelationInput | CheckoutItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CheckoutItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckoutItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckoutItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CheckoutItems
    **/
    _count?: true | CheckoutItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CheckoutItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CheckoutItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CheckoutItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CheckoutItemMaxAggregateInputType
  }

  export type GetCheckoutItemAggregateType<T extends CheckoutItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCheckoutItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCheckoutItem[P]>
      : GetScalarType<T[P], AggregateCheckoutItem[P]>
  }




  export type CheckoutItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckoutItemWhereInput
    orderBy?: CheckoutItemOrderByWithAggregationInput | CheckoutItemOrderByWithAggregationInput[]
    by: CheckoutItemScalarFieldEnum[] | CheckoutItemScalarFieldEnum
    having?: CheckoutItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CheckoutItemCountAggregateInputType | true
    _avg?: CheckoutItemAvgAggregateInputType
    _sum?: CheckoutItemSumAggregateInputType
    _min?: CheckoutItemMinAggregateInputType
    _max?: CheckoutItemMaxAggregateInputType
  }

  export type CheckoutItemGroupByOutputType = {
    id: string
    applicationId: string
    sku: string
    itemName: string
    quantity: number
    unitPrice: Decimal
    createdAt: Date
    _count: CheckoutItemCountAggregateOutputType | null
    _avg: CheckoutItemAvgAggregateOutputType | null
    _sum: CheckoutItemSumAggregateOutputType | null
    _min: CheckoutItemMinAggregateOutputType | null
    _max: CheckoutItemMaxAggregateOutputType | null
  }

  type GetCheckoutItemGroupByPayload<T extends CheckoutItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CheckoutItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CheckoutItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CheckoutItemGroupByOutputType[P]>
            : GetScalarType<T[P], CheckoutItemGroupByOutputType[P]>
        }
      >
    >


  export type CheckoutItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    sku?: boolean
    itemName?: boolean
    quantity?: boolean
    unitPrice?: boolean
    createdAt?: boolean
    application?: boolean | PetRegistrationApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkoutItem"]>

  export type CheckoutItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    sku?: boolean
    itemName?: boolean
    quantity?: boolean
    unitPrice?: boolean
    createdAt?: boolean
    application?: boolean | PetRegistrationApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkoutItem"]>

  export type CheckoutItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    sku?: boolean
    itemName?: boolean
    quantity?: boolean
    unitPrice?: boolean
    createdAt?: boolean
    application?: boolean | PetRegistrationApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkoutItem"]>

  export type CheckoutItemSelectScalar = {
    id?: boolean
    applicationId?: boolean
    sku?: boolean
    itemName?: boolean
    quantity?: boolean
    unitPrice?: boolean
    createdAt?: boolean
  }

  export type CheckoutItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "applicationId" | "sku" | "itemName" | "quantity" | "unitPrice" | "createdAt", ExtArgs["result"]["checkoutItem"]>
  export type CheckoutItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | PetRegistrationApplicationDefaultArgs<ExtArgs>
  }
  export type CheckoutItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | PetRegistrationApplicationDefaultArgs<ExtArgs>
  }
  export type CheckoutItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | PetRegistrationApplicationDefaultArgs<ExtArgs>
  }

  export type $CheckoutItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CheckoutItem"
    objects: {
      application: Prisma.$PetRegistrationApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicationId: string
      sku: string
      itemName: string
      quantity: number
      unitPrice: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["checkoutItem"]>
    composites: {}
  }

  type CheckoutItemGetPayload<S extends boolean | null | undefined | CheckoutItemDefaultArgs> = $Result.GetResult<Prisma.$CheckoutItemPayload, S>

  type CheckoutItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CheckoutItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CheckoutItemCountAggregateInputType | true
    }

  export interface CheckoutItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CheckoutItem'], meta: { name: 'CheckoutItem' } }
    /**
     * Find zero or one CheckoutItem that matches the filter.
     * @param {CheckoutItemFindUniqueArgs} args - Arguments to find a CheckoutItem
     * @example
     * // Get one CheckoutItem
     * const checkoutItem = await prisma.checkoutItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CheckoutItemFindUniqueArgs>(args: SelectSubset<T, CheckoutItemFindUniqueArgs<ExtArgs>>): Prisma__CheckoutItemClient<$Result.GetResult<Prisma.$CheckoutItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CheckoutItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CheckoutItemFindUniqueOrThrowArgs} args - Arguments to find a CheckoutItem
     * @example
     * // Get one CheckoutItem
     * const checkoutItem = await prisma.checkoutItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CheckoutItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CheckoutItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CheckoutItemClient<$Result.GetResult<Prisma.$CheckoutItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CheckoutItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckoutItemFindFirstArgs} args - Arguments to find a CheckoutItem
     * @example
     * // Get one CheckoutItem
     * const checkoutItem = await prisma.checkoutItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CheckoutItemFindFirstArgs>(args?: SelectSubset<T, CheckoutItemFindFirstArgs<ExtArgs>>): Prisma__CheckoutItemClient<$Result.GetResult<Prisma.$CheckoutItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CheckoutItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckoutItemFindFirstOrThrowArgs} args - Arguments to find a CheckoutItem
     * @example
     * // Get one CheckoutItem
     * const checkoutItem = await prisma.checkoutItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CheckoutItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CheckoutItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CheckoutItemClient<$Result.GetResult<Prisma.$CheckoutItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CheckoutItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckoutItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CheckoutItems
     * const checkoutItems = await prisma.checkoutItem.findMany()
     * 
     * // Get first 10 CheckoutItems
     * const checkoutItems = await prisma.checkoutItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checkoutItemWithIdOnly = await prisma.checkoutItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CheckoutItemFindManyArgs>(args?: SelectSubset<T, CheckoutItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckoutItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CheckoutItem.
     * @param {CheckoutItemCreateArgs} args - Arguments to create a CheckoutItem.
     * @example
     * // Create one CheckoutItem
     * const CheckoutItem = await prisma.checkoutItem.create({
     *   data: {
     *     // ... data to create a CheckoutItem
     *   }
     * })
     * 
     */
    create<T extends CheckoutItemCreateArgs>(args: SelectSubset<T, CheckoutItemCreateArgs<ExtArgs>>): Prisma__CheckoutItemClient<$Result.GetResult<Prisma.$CheckoutItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CheckoutItems.
     * @param {CheckoutItemCreateManyArgs} args - Arguments to create many CheckoutItems.
     * @example
     * // Create many CheckoutItems
     * const checkoutItem = await prisma.checkoutItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CheckoutItemCreateManyArgs>(args?: SelectSubset<T, CheckoutItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CheckoutItems and returns the data saved in the database.
     * @param {CheckoutItemCreateManyAndReturnArgs} args - Arguments to create many CheckoutItems.
     * @example
     * // Create many CheckoutItems
     * const checkoutItem = await prisma.checkoutItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CheckoutItems and only return the `id`
     * const checkoutItemWithIdOnly = await prisma.checkoutItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CheckoutItemCreateManyAndReturnArgs>(args?: SelectSubset<T, CheckoutItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckoutItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CheckoutItem.
     * @param {CheckoutItemDeleteArgs} args - Arguments to delete one CheckoutItem.
     * @example
     * // Delete one CheckoutItem
     * const CheckoutItem = await prisma.checkoutItem.delete({
     *   where: {
     *     // ... filter to delete one CheckoutItem
     *   }
     * })
     * 
     */
    delete<T extends CheckoutItemDeleteArgs>(args: SelectSubset<T, CheckoutItemDeleteArgs<ExtArgs>>): Prisma__CheckoutItemClient<$Result.GetResult<Prisma.$CheckoutItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CheckoutItem.
     * @param {CheckoutItemUpdateArgs} args - Arguments to update one CheckoutItem.
     * @example
     * // Update one CheckoutItem
     * const checkoutItem = await prisma.checkoutItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CheckoutItemUpdateArgs>(args: SelectSubset<T, CheckoutItemUpdateArgs<ExtArgs>>): Prisma__CheckoutItemClient<$Result.GetResult<Prisma.$CheckoutItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CheckoutItems.
     * @param {CheckoutItemDeleteManyArgs} args - Arguments to filter CheckoutItems to delete.
     * @example
     * // Delete a few CheckoutItems
     * const { count } = await prisma.checkoutItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CheckoutItemDeleteManyArgs>(args?: SelectSubset<T, CheckoutItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CheckoutItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckoutItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CheckoutItems
     * const checkoutItem = await prisma.checkoutItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CheckoutItemUpdateManyArgs>(args: SelectSubset<T, CheckoutItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CheckoutItems and returns the data updated in the database.
     * @param {CheckoutItemUpdateManyAndReturnArgs} args - Arguments to update many CheckoutItems.
     * @example
     * // Update many CheckoutItems
     * const checkoutItem = await prisma.checkoutItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CheckoutItems and only return the `id`
     * const checkoutItemWithIdOnly = await prisma.checkoutItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CheckoutItemUpdateManyAndReturnArgs>(args: SelectSubset<T, CheckoutItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckoutItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CheckoutItem.
     * @param {CheckoutItemUpsertArgs} args - Arguments to update or create a CheckoutItem.
     * @example
     * // Update or create a CheckoutItem
     * const checkoutItem = await prisma.checkoutItem.upsert({
     *   create: {
     *     // ... data to create a CheckoutItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CheckoutItem we want to update
     *   }
     * })
     */
    upsert<T extends CheckoutItemUpsertArgs>(args: SelectSubset<T, CheckoutItemUpsertArgs<ExtArgs>>): Prisma__CheckoutItemClient<$Result.GetResult<Prisma.$CheckoutItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CheckoutItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckoutItemCountArgs} args - Arguments to filter CheckoutItems to count.
     * @example
     * // Count the number of CheckoutItems
     * const count = await prisma.checkoutItem.count({
     *   where: {
     *     // ... the filter for the CheckoutItems we want to count
     *   }
     * })
    **/
    count<T extends CheckoutItemCountArgs>(
      args?: Subset<T, CheckoutItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CheckoutItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CheckoutItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckoutItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CheckoutItemAggregateArgs>(args: Subset<T, CheckoutItemAggregateArgs>): Prisma.PrismaPromise<GetCheckoutItemAggregateType<T>>

    /**
     * Group by CheckoutItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckoutItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CheckoutItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CheckoutItemGroupByArgs['orderBy'] }
        : { orderBy?: CheckoutItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CheckoutItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCheckoutItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CheckoutItem model
   */
  readonly fields: CheckoutItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CheckoutItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CheckoutItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends PetRegistrationApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PetRegistrationApplicationDefaultArgs<ExtArgs>>): Prisma__PetRegistrationApplicationClient<$Result.GetResult<Prisma.$PetRegistrationApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CheckoutItem model
   */
  interface CheckoutItemFieldRefs {
    readonly id: FieldRef<"CheckoutItem", 'String'>
    readonly applicationId: FieldRef<"CheckoutItem", 'String'>
    readonly sku: FieldRef<"CheckoutItem", 'String'>
    readonly itemName: FieldRef<"CheckoutItem", 'String'>
    readonly quantity: FieldRef<"CheckoutItem", 'Int'>
    readonly unitPrice: FieldRef<"CheckoutItem", 'Decimal'>
    readonly createdAt: FieldRef<"CheckoutItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CheckoutItem findUnique
   */
  export type CheckoutItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutItem
     */
    select?: CheckoutItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutItem
     */
    omit?: CheckoutItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutItemInclude<ExtArgs> | null
    /**
     * Filter, which CheckoutItem to fetch.
     */
    where: CheckoutItemWhereUniqueInput
  }

  /**
   * CheckoutItem findUniqueOrThrow
   */
  export type CheckoutItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutItem
     */
    select?: CheckoutItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutItem
     */
    omit?: CheckoutItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutItemInclude<ExtArgs> | null
    /**
     * Filter, which CheckoutItem to fetch.
     */
    where: CheckoutItemWhereUniqueInput
  }

  /**
   * CheckoutItem findFirst
   */
  export type CheckoutItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutItem
     */
    select?: CheckoutItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutItem
     */
    omit?: CheckoutItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutItemInclude<ExtArgs> | null
    /**
     * Filter, which CheckoutItem to fetch.
     */
    where?: CheckoutItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckoutItems to fetch.
     */
    orderBy?: CheckoutItemOrderByWithRelationInput | CheckoutItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckoutItems.
     */
    cursor?: CheckoutItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckoutItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckoutItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckoutItems.
     */
    distinct?: CheckoutItemScalarFieldEnum | CheckoutItemScalarFieldEnum[]
  }

  /**
   * CheckoutItem findFirstOrThrow
   */
  export type CheckoutItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutItem
     */
    select?: CheckoutItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutItem
     */
    omit?: CheckoutItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutItemInclude<ExtArgs> | null
    /**
     * Filter, which CheckoutItem to fetch.
     */
    where?: CheckoutItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckoutItems to fetch.
     */
    orderBy?: CheckoutItemOrderByWithRelationInput | CheckoutItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckoutItems.
     */
    cursor?: CheckoutItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckoutItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckoutItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckoutItems.
     */
    distinct?: CheckoutItemScalarFieldEnum | CheckoutItemScalarFieldEnum[]
  }

  /**
   * CheckoutItem findMany
   */
  export type CheckoutItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutItem
     */
    select?: CheckoutItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutItem
     */
    omit?: CheckoutItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutItemInclude<ExtArgs> | null
    /**
     * Filter, which CheckoutItems to fetch.
     */
    where?: CheckoutItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckoutItems to fetch.
     */
    orderBy?: CheckoutItemOrderByWithRelationInput | CheckoutItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CheckoutItems.
     */
    cursor?: CheckoutItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckoutItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckoutItems.
     */
    skip?: number
    distinct?: CheckoutItemScalarFieldEnum | CheckoutItemScalarFieldEnum[]
  }

  /**
   * CheckoutItem create
   */
  export type CheckoutItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutItem
     */
    select?: CheckoutItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutItem
     */
    omit?: CheckoutItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CheckoutItem.
     */
    data: XOR<CheckoutItemCreateInput, CheckoutItemUncheckedCreateInput>
  }

  /**
   * CheckoutItem createMany
   */
  export type CheckoutItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CheckoutItems.
     */
    data: CheckoutItemCreateManyInput | CheckoutItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CheckoutItem createManyAndReturn
   */
  export type CheckoutItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutItem
     */
    select?: CheckoutItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutItem
     */
    omit?: CheckoutItemOmit<ExtArgs> | null
    /**
     * The data used to create many CheckoutItems.
     */
    data: CheckoutItemCreateManyInput | CheckoutItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CheckoutItem update
   */
  export type CheckoutItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutItem
     */
    select?: CheckoutItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutItem
     */
    omit?: CheckoutItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CheckoutItem.
     */
    data: XOR<CheckoutItemUpdateInput, CheckoutItemUncheckedUpdateInput>
    /**
     * Choose, which CheckoutItem to update.
     */
    where: CheckoutItemWhereUniqueInput
  }

  /**
   * CheckoutItem updateMany
   */
  export type CheckoutItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CheckoutItems.
     */
    data: XOR<CheckoutItemUpdateManyMutationInput, CheckoutItemUncheckedUpdateManyInput>
    /**
     * Filter which CheckoutItems to update
     */
    where?: CheckoutItemWhereInput
    /**
     * Limit how many CheckoutItems to update.
     */
    limit?: number
  }

  /**
   * CheckoutItem updateManyAndReturn
   */
  export type CheckoutItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutItem
     */
    select?: CheckoutItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutItem
     */
    omit?: CheckoutItemOmit<ExtArgs> | null
    /**
     * The data used to update CheckoutItems.
     */
    data: XOR<CheckoutItemUpdateManyMutationInput, CheckoutItemUncheckedUpdateManyInput>
    /**
     * Filter which CheckoutItems to update
     */
    where?: CheckoutItemWhereInput
    /**
     * Limit how many CheckoutItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CheckoutItem upsert
   */
  export type CheckoutItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutItem
     */
    select?: CheckoutItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutItem
     */
    omit?: CheckoutItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CheckoutItem to update in case it exists.
     */
    where: CheckoutItemWhereUniqueInput
    /**
     * In case the CheckoutItem found by the `where` argument doesn't exist, create a new CheckoutItem with this data.
     */
    create: XOR<CheckoutItemCreateInput, CheckoutItemUncheckedCreateInput>
    /**
     * In case the CheckoutItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CheckoutItemUpdateInput, CheckoutItemUncheckedUpdateInput>
  }

  /**
   * CheckoutItem delete
   */
  export type CheckoutItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutItem
     */
    select?: CheckoutItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutItem
     */
    omit?: CheckoutItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutItemInclude<ExtArgs> | null
    /**
     * Filter which CheckoutItem to delete.
     */
    where: CheckoutItemWhereUniqueInput
  }

  /**
   * CheckoutItem deleteMany
   */
  export type CheckoutItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheckoutItems to delete
     */
    where?: CheckoutItemWhereInput
    /**
     * Limit how many CheckoutItems to delete.
     */
    limit?: number
  }

  /**
   * CheckoutItem without action
   */
  export type CheckoutItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckoutItem
     */
    select?: CheckoutItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckoutItem
     */
    omit?: CheckoutItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckoutItemInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    phone: 'phone',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    isActive: 'isActive',
    emailVerified: 'emailVerified',
    phoneVerified: 'phoneVerified',
    lastLogin: 'lastLogin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    googleId: 'googleId',
    appleId: 'appleId',
    profilePicture: 'profilePicture',
    authProvider: 'authProvider'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const OTPCodeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    codeHash: 'codeHash',
    purpose: 'purpose',
    deliveryMethod: 'deliveryMethod',
    expiresAt: 'expiresAt',
    isUsed: 'isUsed',
    attemptsCount: 'attemptsCount',
    maxAttempts: 'maxAttempts',
    createdAt: 'createdAt'
  };

  export type OTPCodeScalarFieldEnum = (typeof OTPCodeScalarFieldEnum)[keyof typeof OTPCodeScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    refreshTokenHash: 'refreshTokenHash',
    deviceInfo: 'deviceInfo',
    ipAddress: 'ipAddress',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    lastUsedAt: 'lastUsedAt'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const ExecutiveScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    employeeId: 'employeeId',
    territory: 'territory',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type ExecutiveScalarFieldEnum = (typeof ExecutiveScalarFieldEnum)[keyof typeof ExecutiveScalarFieldEnum]


  export const PetOwnerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode',
    countryCode: 'countryCode',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PetOwnerScalarFieldEnum = (typeof PetOwnerScalarFieldEnum)[keyof typeof PetOwnerScalarFieldEnum]


  export const PetSpeciesScalarFieldEnum: {
    id: 'id',
    speciesName: 'speciesName',
    category: 'category'
  };

  export type PetSpeciesScalarFieldEnum = (typeof PetSpeciesScalarFieldEnum)[keyof typeof PetSpeciesScalarFieldEnum]


  export const PetBreedScalarFieldEnum: {
    id: 'id',
    breedName: 'breedName',
    speciesId: 'speciesId',
    sizeCategory: 'sizeCategory',
    typicalLifespanYears: 'typicalLifespanYears'
  };

  export type PetBreedScalarFieldEnum = (typeof PetBreedScalarFieldEnum)[keyof typeof PetBreedScalarFieldEnum]


  export const PetScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    registeredBy: 'registeredBy',
    name: 'name',
    speciesId: 'speciesId',
    breed_id: 'breed_id',
    secondary_breed_id: 'secondary_breed_id',
    gender: 'gender',
    birthDate: 'birthDate',
    color: 'color',
    weightKg: 'weightKg',
    heightCm: 'heightCm',
    distinctiveMarks: 'distinctiveMarks',
    isSpayedNeutered: 'isSpayedNeutered',
    microchip_id: 'microchip_id',
    registrationNumber: 'registrationNumber',
    status: 'status',
    specialNeeds: 'specialNeeds',
    behavioralNotes: 'behavioralNotes',
    profileImageUrl: 'profileImageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PetScalarFieldEnum = (typeof PetScalarFieldEnum)[keyof typeof PetScalarFieldEnum]


  export const VaccineTypeScalarFieldEnum: {
    id: 'id',
    vaccineName: 'vaccineName',
    speciesApplicability: 'speciesApplicability',
    durationMonths: 'durationMonths',
    isRequiredByLaw: 'isRequiredByLaw'
  };

  export type VaccineTypeScalarFieldEnum = (typeof VaccineTypeScalarFieldEnum)[keyof typeof VaccineTypeScalarFieldEnum]


  export const VaccinationRecordScalarFieldEnum: {
    id: 'id',
    petId: 'petId',
    vaccineTypeId: 'vaccineTypeId',
    administeredDate: 'administeredDate',
    expirationDate: 'expirationDate',
    batchNumber: 'batchNumber',
    veterinarianName: 'veterinarianName',
    clinicName: 'clinicName',
    notes: 'notes',
    certificateUrl: 'certificateUrl',
    createdAt: 'createdAt'
  };

  export type VaccinationRecordScalarFieldEnum = (typeof VaccinationRecordScalarFieldEnum)[keyof typeof VaccinationRecordScalarFieldEnum]


  export const MedicalRecordScalarFieldEnum: {
    id: 'id',
    petId: 'petId',
    visitDate: 'visitDate',
    veterinarianName: 'veterinarianName',
    clinicName: 'clinicName',
    diagnosis: 'diagnosis',
    treatment: 'treatment',
    medications: 'medications',
    followUpRequired: 'followUpRequired',
    followUpDate: 'followUpDate',
    cost: 'cost',
    documentUrls: 'documentUrls',
    createdAt: 'createdAt'
  };

  export type MedicalRecordScalarFieldEnum = (typeof MedicalRecordScalarFieldEnum)[keyof typeof MedicalRecordScalarFieldEnum]


  export const QRCodePoolScalarFieldEnum: {
    id: 'id',
    poolName: 'poolName',
    totalCapacity: 'totalCapacity',
    usedCount: 'usedCount',
    createdAt: 'createdAt',
    status: 'status'
  };

  export type QRCodePoolScalarFieldEnum = (typeof QRCodePoolScalarFieldEnum)[keyof typeof QRCodePoolScalarFieldEnum]


  export const QRCodeScalarFieldEnum: {
    id: 'id',
    poolId: 'poolId',
    qrCodeString: 'qrCodeString',
    qrCodeHash: 'qrCodeHash',
    qrImageUrl: 'qrImageUrl',
    status: 'status',
    assignedToPet: 'assignedToPet',
    assignedAt: 'assignedAt',
    activatedAt: 'activatedAt',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type QRCodeScalarFieldEnum = (typeof QRCodeScalarFieldEnum)[keyof typeof QRCodeScalarFieldEnum]


  export const QRScanEventScalarFieldEnum: {
    id: 'id',
    qrId: 'qrId',
    petId: 'petId',
    scanTimestamp: 'scanTimestamp',
    scannerIp: 'scannerIp',
    userAgent: 'userAgent',
    deviceType: 'deviceType',
    scanLocation: 'scanLocation',
    locationAccuracy: 'locationAccuracy',
    locationName: 'locationName',
    countryCode: 'countryCode',
    city: 'city',
    scannerContactInfo: 'scannerContactInfo',
    scanResult: 'scanResult',
    createdAt: 'createdAt'
  };

  export type QRScanEventScalarFieldEnum = (typeof QRScanEventScalarFieldEnum)[keyof typeof QRScanEventScalarFieldEnum]


  export const PetLocationEventScalarFieldEnum: {
    id: 'id',
    petId: 'petId',
    qrScanId: 'qrScanId',
    latitude: 'latitude',
    longitude: 'longitude',
    accuracy: 'accuracy',
    scannerIp: 'scannerIp',
    userAgent: 'userAgent',
    deviceType: 'deviceType',
    locationName: 'locationName',
    countryCode: 'countryCode',
    city: 'city',
    state: 'state',
    scannerContactInfo: 'scannerContactInfo',
    createdAt: 'createdAt'
  };

  export type PetLocationEventScalarFieldEnum = (typeof PetLocationEventScalarFieldEnum)[keyof typeof PetLocationEventScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    razorpayOrderId: 'razorpayOrderId',
    userId: 'userId',
    receipt: 'receipt',
    amountInPaise: 'amountInPaise',
    currency: 'currency',
    status: 'status',
    notes: 'notes',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    expiresAt: 'expiresAt',
    rawOrderPayload: 'rawOrderPayload'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    localOrderId: 'localOrderId',
    razorpayPaymentId: 'razorpayPaymentId',
    razorpayOrderId: 'razorpayOrderId',
    amountInPaise: 'amountInPaise',
    currency: 'currency',
    method: 'method',
    status: 'status',
    captured: 'captured',
    capturedAt: 'capturedAt',
    bank: 'bank',
    vpa: 'vpa',
    card: 'card',
    fee: 'fee',
    tax: 'tax',
    currencyConversion: 'currencyConversion',
    signatureValid: 'signatureValid',
    signatureVerifiedAt: 'signatureVerifiedAt',
    verificationMethod: 'verificationMethod',
    rawPaymentPayload: 'rawPaymentPayload',
    clientMeta: 'clientMeta',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const RefundScalarFieldEnum: {
    id: 'id',
    razorpayRefundId: 'razorpayRefundId',
    razorpayPaymentId: 'razorpayPaymentId',
    paymentEventId: 'paymentEventId',
    amountInPaise: 'amountInPaise',
    refundAmount: 'refundAmount',
    reason: 'reason',
    initiatedBy: 'initiatedBy',
    status: 'status',
    processedAt: 'processedAt',
    rawRefundPayload: 'rawRefundPayload',
    createdAt: 'createdAt'
  };

  export type RefundScalarFieldEnum = (typeof RefundScalarFieldEnum)[keyof typeof RefundScalarFieldEnum]


  export const WebhookEventScalarFieldEnum: {
    id: 'id',
    razorpayEventId: 'razorpayEventId',
    eventType: 'eventType',
    rawEvent: 'rawEvent',
    headers: 'headers',
    signatureValid: 'signatureValid',
    receivedAt: 'receivedAt',
    processedAt: 'processedAt',
    processingResult: 'processingResult'
  };

  export type WebhookEventScalarFieldEnum = (typeof WebhookEventScalarFieldEnum)[keyof typeof WebhookEventScalarFieldEnum]


  export const PaymentWebhookScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    eventType: 'eventType',
    entityType: 'entityType',
    entityId: 'entityId',
    payload: 'payload',
    signature: 'signature',
    signatureVerified: 'signatureVerified',
    processed: 'processed',
    processedAt: 'processedAt',
    processingAttempts: 'processingAttempts',
    createdAt: 'createdAt'
  };

  export type PaymentWebhookScalarFieldEnum = (typeof PaymentWebhookScalarFieldEnum)[keyof typeof PaymentWebhookScalarFieldEnum]


  export const PaymentEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    petId: 'petId',
    qrId: 'qrId',
    amount: 'amount',
    currency: 'currency',
    paymentPurpose: 'paymentPurpose',
    status: 'status',
    razorpayOrderId: 'razorpayOrderId',
    razorpayPaymentId: 'razorpayPaymentId',
    razorpaySignature: 'razorpaySignature',
    paymentMethod: 'paymentMethod',
    failureReason: 'failureReason',
    createdAt: 'createdAt',
    completedAt: 'completedAt'
  };

  export type PaymentEventScalarFieldEnum = (typeof PaymentEventScalarFieldEnum)[keyof typeof PaymentEventScalarFieldEnum]


  export const LocationTrackScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    locationType: 'locationType',
    position: 'position',
    accuracy: 'accuracy',
    locationName: 'locationName',
    countryCode: 'countryCode',
    state: 'state',
    city: 'city',
    ipAddress: 'ipAddress',
    deviceInfo: 'deviceInfo',
    timestamp: 'timestamp'
  };

  export type LocationTrackScalarFieldEnum = (typeof LocationTrackScalarFieldEnum)[keyof typeof LocationTrackScalarFieldEnum]


  export const NotificationPreferenceScalarFieldEnum: {
    userId: 'userId',
    pushEnabled: 'pushEnabled',
    emailEnabled: 'emailEnabled',
    smsEnabled: 'smsEnabled',
    scanNotifications: 'scanNotifications',
    marketingNotifications: 'marketingNotifications',
    quietHoursStart: 'quietHoursStart',
    quietHoursEnd: 'quietHoursEnd',
    timezone: 'timezone',
    updatedAt: 'updatedAt'
  };

  export type NotificationPreferenceScalarFieldEnum = (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    petId: 'petId',
    qrScanId: 'qrScanId',
    notificationType: 'notificationType',
    title: 'title',
    message: 'message',
    channels: 'channels',
    deliveryStatus: 'deliveryStatus',
    metadata: 'metadata',
    createdAt: 'createdAt',
    sentAt: 'sentAt',
    readAt: 'readAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const DeviceTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    deviceToken: 'deviceToken',
    platform: 'platform',
    deviceInfo: 'deviceInfo',
    isActive: 'isActive',
    createdAt: 'createdAt',
    lastUsedAt: 'lastUsedAt'
  };

  export type DeviceTokenScalarFieldEnum = (typeof DeviceTokenScalarFieldEnum)[keyof typeof DeviceTokenScalarFieldEnum]


  export const SupportTicketScalarFieldEnum: {
    id: 'id',
    ticketNumber: 'ticketNumber',
    userId: 'userId',
    petId: 'petId',
    subject: 'subject',
    description: 'description',
    category: 'category',
    priority: 'priority',
    status: 'status',
    assignedTo: 'assignedTo',
    resolution: 'resolution',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    resolvedAt: 'resolvedAt'
  };

  export type SupportTicketScalarFieldEnum = (typeof SupportTicketScalarFieldEnum)[keyof typeof SupportTicketScalarFieldEnum]


  export const SupportMessageScalarFieldEnum: {
    id: 'id',
    ticketId: 'ticketId',
    senderId: 'senderId',
    senderType: 'senderType',
    message: 'message',
    attachments: 'attachments',
    isInternal: 'isInternal',
    createdAt: 'createdAt'
  };

  export type SupportMessageScalarFieldEnum = (typeof SupportMessageScalarFieldEnum)[keyof typeof SupportMessageScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    tableName: 'tableName',
    recordId: 'recordId',
    operationType: 'operationType',
    oldValues: 'oldValues',
    newValues: 'newValues',
    changedColumns: 'changedColumns',
    userId: 'userId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    timestamp: 'timestamp'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SystemAnalyticsScalarFieldEnum: {
    id: 'id',
    metricName: 'metricName',
    metricValue: 'metricValue',
    metricUnit: 'metricUnit',
    dimensions: 'dimensions',
    timestamp: 'timestamp'
  };

  export type SystemAnalyticsScalarFieldEnum = (typeof SystemAnalyticsScalarFieldEnum)[keyof typeof SystemAnalyticsScalarFieldEnum]


  export const PetRegistrationApplicationScalarFieldEnum: {
    id: 'id',
    applicationType: 'applicationType',
    identifierType: 'identifierType',
    identifierNumber: 'identifierNumber',
    submittedAt: 'submittedAt',
    city: 'city',
    state: 'state',
    country: 'country',
    applicantType: 'applicantType',
    applicantName: 'applicantName',
    fatherOrHusbandName: 'fatherOrHusbandName',
    applicantEmail: 'applicantEmail',
    applicantPhone: 'applicantPhone',
    aadhaarNumber: 'aadhaarNumber',
    pincode: 'pincode',
    address: 'address',
    hasTokenNumber: 'hasTokenNumber',
    declarationAcknowledgement: 'declarationAcknowledgement',
    acceptedTerms: 'acceptedTerms',
    registrationFee: 'registrationFee',
    convenienceFee: 'convenienceFee',
    gst: 'gst',
    totalAmount: 'totalAmount',
    currency: 'currency',
    deliveryAddressLine: 'deliveryAddressLine',
    deliveryCity: 'deliveryCity',
    deliveryState: 'deliveryState',
    deliveryPincode: 'deliveryPincode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PetRegistrationApplicationScalarFieldEnum = (typeof PetRegistrationApplicationScalarFieldEnum)[keyof typeof PetRegistrationApplicationScalarFieldEnum]


  export const RegisteredPetScalarFieldEnum: {
    id: 'id',
    applicationId: 'applicationId',
    petName: 'petName',
    breed: 'breed',
    dateOfBirth: 'dateOfBirth',
    ageOnRegistration: 'ageOnRegistration',
    lastRabiesVaccinationDate: 'lastRabiesVaccinationDate',
    veterinaryDoctorName: 'veterinaryDoctorName',
    veterinaryDoctorRegNumber: 'veterinaryDoctorRegNumber',
    veterinaryClinicOrHospitalName: 'veterinaryClinicOrHospitalName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    gender: 'gender'
  };

  export type RegisteredPetScalarFieldEnum = (typeof RegisteredPetScalarFieldEnum)[keyof typeof RegisteredPetScalarFieldEnum]


  export const ApplicationDocumentScalarFieldEnum: {
    id: 'id',
    applicationId: 'applicationId',
    documentType: 'documentType',
    fileName: 'fileName',
    filePath: 'filePath',
    mimeType: 'mimeType',
    sizeBytes: 'sizeBytes',
    createdAt: 'createdAt'
  };

  export type ApplicationDocumentScalarFieldEnum = (typeof ApplicationDocumentScalarFieldEnum)[keyof typeof ApplicationDocumentScalarFieldEnum]


  export const PetDocumentScalarFieldEnum: {
    id: 'id',
    petId: 'petId',
    documentType: 'documentType',
    fileName: 'fileName',
    filePath: 'filePath',
    mimeType: 'mimeType',
    sizeBytes: 'sizeBytes',
    createdAt: 'createdAt'
  };

  export type PetDocumentScalarFieldEnum = (typeof PetDocumentScalarFieldEnum)[keyof typeof PetDocumentScalarFieldEnum]


  export const CheckoutItemScalarFieldEnum: {
    id: 'id',
    applicationId: 'applicationId',
    sku: 'sku',
    itemName: 'itemName',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    createdAt: 'createdAt'
  };

  export type CheckoutItemScalarFieldEnum = (typeof CheckoutItemScalarFieldEnum)[keyof typeof CheckoutItemScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'AuthProvider'
   */
  export type EnumAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthProvider'>
    


  /**
   * Reference to a field of type 'AuthProvider[]'
   */
  export type ListEnumAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthProvider[]'>
    


  /**
   * Reference to a field of type 'OTPPurpose'
   */
  export type EnumOTPPurposeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OTPPurpose'>
    


  /**
   * Reference to a field of type 'OTPPurpose[]'
   */
  export type ListEnumOTPPurposeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OTPPurpose[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'SizeCategory'
   */
  export type EnumSizeCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SizeCategory'>
    


  /**
   * Reference to a field of type 'SizeCategory[]'
   */
  export type ListEnumSizeCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SizeCategory[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'PetStatus'
   */
  export type EnumPetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PetStatus'>
    


  /**
   * Reference to a field of type 'PetStatus[]'
   */
  export type ListEnumPetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PetStatus[]'>
    


  /**
   * Reference to a field of type 'PoolStatus'
   */
  export type EnumPoolStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PoolStatus'>
    


  /**
   * Reference to a field of type 'PoolStatus[]'
   */
  export type ListEnumPoolStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PoolStatus[]'>
    


  /**
   * Reference to a field of type 'QRStatus'
   */
  export type EnumQRStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QRStatus'>
    


  /**
   * Reference to a field of type 'QRStatus[]'
   */
  export type ListEnumQRStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QRStatus[]'>
    


  /**
   * Reference to a field of type 'DeviceType'
   */
  export type EnumDeviceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeviceType'>
    


  /**
   * Reference to a field of type 'DeviceType[]'
   */
  export type ListEnumDeviceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeviceType[]'>
    


  /**
   * Reference to a field of type 'ScanResult'
   */
  export type EnumScanResultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScanResult'>
    


  /**
   * Reference to a field of type 'ScanResult[]'
   */
  export type ListEnumScanResultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScanResult[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatusNew'
   */
  export type EnumPaymentStatusNewFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatusNew'>
    


  /**
   * Reference to a field of type 'PaymentStatusNew[]'
   */
  export type ListEnumPaymentStatusNewFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatusNew[]'>
    


  /**
   * Reference to a field of type 'VerificationMethod'
   */
  export type EnumVerificationMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationMethod'>
    


  /**
   * Reference to a field of type 'VerificationMethod[]'
   */
  export type ListEnumVerificationMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationMethod[]'>
    


  /**
   * Reference to a field of type 'RefundStatus'
   */
  export type EnumRefundStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefundStatus'>
    


  /**
   * Reference to a field of type 'RefundStatus[]'
   */
  export type ListEnumRefundStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefundStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentPurpose'
   */
  export type EnumPaymentPurposeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentPurpose'>
    


  /**
   * Reference to a field of type 'PaymentPurpose[]'
   */
  export type ListEnumPaymentPurposeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentPurpose[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'LocationType'
   */
  export type EnumLocationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LocationType'>
    


  /**
   * Reference to a field of type 'LocationType[]'
   */
  export type ListEnumLocationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LocationType[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'Platform'
   */
  export type EnumPlatformFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Platform'>
    


  /**
   * Reference to a field of type 'Platform[]'
   */
  export type ListEnumPlatformFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Platform[]'>
    


  /**
   * Reference to a field of type 'TicketCategory'
   */
  export type EnumTicketCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketCategory'>
    


  /**
   * Reference to a field of type 'TicketCategory[]'
   */
  export type ListEnumTicketCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketCategory[]'>
    


  /**
   * Reference to a field of type 'TicketPriority'
   */
  export type EnumTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketPriority'>
    


  /**
   * Reference to a field of type 'TicketPriority[]'
   */
  export type ListEnumTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketPriority[]'>
    


  /**
   * Reference to a field of type 'TicketStatus'
   */
  export type EnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus'>
    


  /**
   * Reference to a field of type 'TicketStatus[]'
   */
  export type ListEnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus[]'>
    


  /**
   * Reference to a field of type 'SenderType'
   */
  export type EnumSenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SenderType'>
    


  /**
   * Reference to a field of type 'SenderType[]'
   */
  export type ListEnumSenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SenderType[]'>
    


  /**
   * Reference to a field of type 'OperationType'
   */
  export type EnumOperationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OperationType'>
    


  /**
   * Reference to a field of type 'OperationType[]'
   */
  export type ListEnumOperationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OperationType[]'>
    


  /**
   * Reference to a field of type 'ApplicationType'
   */
  export type EnumApplicationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationType'>
    


  /**
   * Reference to a field of type 'ApplicationType[]'
   */
  export type ListEnumApplicationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationType[]'>
    


  /**
   * Reference to a field of type 'IdentifierType'
   */
  export type EnumIdentifierTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdentifierType'>
    


  /**
   * Reference to a field of type 'IdentifierType[]'
   */
  export type ListEnumIdentifierTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdentifierType[]'>
    


  /**
   * Reference to a field of type 'ApplicantType'
   */
  export type EnumApplicantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicantType'>
    


  /**
   * Reference to a field of type 'ApplicantType[]'
   */
  export type ListEnumApplicantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicantType[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    emailVerified?: BoolFilter<"User"> | boolean
    phoneVerified?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    googleId?: StringNullableFilter<"User"> | string | null
    appleId?: StringNullableFilter<"User"> | string | null
    profilePicture?: StringNullableFilter<"User"> | string | null
    authProvider?: EnumAuthProviderNullableFilter<"User"> | $Enums.AuthProvider | null
    auditLogs?: AuditLogListRelationFilter
    deviceTokens?: DeviceTokenListRelationFilter
    executive?: XOR<ExecutiveNullableScalarRelationFilter, ExecutiveWhereInput> | null
    locationTracks?: LocationTrackListRelationFilter
    notificationPrefs?: XOR<NotificationPreferenceNullableScalarRelationFilter, NotificationPreferenceWhereInput> | null
    notifications?: NotificationListRelationFilter
    orders?: OrderListRelationFilter
    otpCodes?: OTPCodeListRelationFilter
    paymentEvents?: PaymentEventListRelationFilter
    petOwner?: XOR<PetOwnerNullableScalarRelationFilter, PetOwnerWhereInput> | null
    registeredPets?: PetListRelationFilter
    supportMessages?: SupportMessageListRelationFilter
    assignedTickets?: SupportTicketListRelationFilter
    supportTickets?: SupportTicketListRelationFilter
    sessions?: UserSessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    googleId?: SortOrderInput | SortOrder
    appleId?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    authProvider?: SortOrderInput | SortOrder
    auditLogs?: AuditLogOrderByRelationAggregateInput
    deviceTokens?: DeviceTokenOrderByRelationAggregateInput
    executive?: ExecutiveOrderByWithRelationInput
    locationTracks?: LocationTrackOrderByRelationAggregateInput
    notificationPrefs?: NotificationPreferenceOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    otpCodes?: OTPCodeOrderByRelationAggregateInput
    paymentEvents?: PaymentEventOrderByRelationAggregateInput
    petOwner?: PetOwnerOrderByWithRelationInput
    registeredPets?: PetOrderByRelationAggregateInput
    supportMessages?: SupportMessageOrderByRelationAggregateInput
    assignedTickets?: SupportTicketOrderByRelationAggregateInput
    supportTickets?: SupportTicketOrderByRelationAggregateInput
    sessions?: UserSessionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    googleId?: string
    appleId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    emailVerified?: BoolFilter<"User"> | boolean
    phoneVerified?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    profilePicture?: StringNullableFilter<"User"> | string | null
    authProvider?: EnumAuthProviderNullableFilter<"User"> | $Enums.AuthProvider | null
    auditLogs?: AuditLogListRelationFilter
    deviceTokens?: DeviceTokenListRelationFilter
    executive?: XOR<ExecutiveNullableScalarRelationFilter, ExecutiveWhereInput> | null
    locationTracks?: LocationTrackListRelationFilter
    notificationPrefs?: XOR<NotificationPreferenceNullableScalarRelationFilter, NotificationPreferenceWhereInput> | null
    notifications?: NotificationListRelationFilter
    orders?: OrderListRelationFilter
    otpCodes?: OTPCodeListRelationFilter
    paymentEvents?: PaymentEventListRelationFilter
    petOwner?: XOR<PetOwnerNullableScalarRelationFilter, PetOwnerWhereInput> | null
    registeredPets?: PetListRelationFilter
    supportMessages?: SupportMessageListRelationFilter
    assignedTickets?: SupportTicketListRelationFilter
    supportTickets?: SupportTicketListRelationFilter
    sessions?: UserSessionListRelationFilter
  }, "id" | "email" | "phone" | "googleId" | "appleId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    googleId?: SortOrderInput | SortOrder
    appleId?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    authProvider?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    phoneVerified?: BoolWithAggregatesFilter<"User"> | boolean
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    googleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    appleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    profilePicture?: StringNullableWithAggregatesFilter<"User"> | string | null
    authProvider?: EnumAuthProviderNullableWithAggregatesFilter<"User"> | $Enums.AuthProvider | null
  }

  export type OTPCodeWhereInput = {
    AND?: OTPCodeWhereInput | OTPCodeWhereInput[]
    OR?: OTPCodeWhereInput[]
    NOT?: OTPCodeWhereInput | OTPCodeWhereInput[]
    id?: UuidFilter<"OTPCode"> | string
    userId?: UuidFilter<"OTPCode"> | string
    codeHash?: StringFilter<"OTPCode"> | string
    purpose?: EnumOTPPurposeFilter<"OTPCode"> | $Enums.OTPPurpose
    deliveryMethod?: StringNullableFilter<"OTPCode"> | string | null
    expiresAt?: DateTimeFilter<"OTPCode"> | Date | string
    isUsed?: BoolFilter<"OTPCode"> | boolean
    attemptsCount?: IntFilter<"OTPCode"> | number
    maxAttempts?: IntFilter<"OTPCode"> | number
    createdAt?: DateTimeFilter<"OTPCode"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OTPCodeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    purpose?: SortOrder
    deliveryMethod?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    attemptsCount?: SortOrder
    maxAttempts?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OTPCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OTPCodeWhereInput | OTPCodeWhereInput[]
    OR?: OTPCodeWhereInput[]
    NOT?: OTPCodeWhereInput | OTPCodeWhereInput[]
    userId?: UuidFilter<"OTPCode"> | string
    codeHash?: StringFilter<"OTPCode"> | string
    purpose?: EnumOTPPurposeFilter<"OTPCode"> | $Enums.OTPPurpose
    deliveryMethod?: StringNullableFilter<"OTPCode"> | string | null
    expiresAt?: DateTimeFilter<"OTPCode"> | Date | string
    isUsed?: BoolFilter<"OTPCode"> | boolean
    attemptsCount?: IntFilter<"OTPCode"> | number
    maxAttempts?: IntFilter<"OTPCode"> | number
    createdAt?: DateTimeFilter<"OTPCode"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type OTPCodeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    purpose?: SortOrder
    deliveryMethod?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    attemptsCount?: SortOrder
    maxAttempts?: SortOrder
    createdAt?: SortOrder
    _count?: OTPCodeCountOrderByAggregateInput
    _avg?: OTPCodeAvgOrderByAggregateInput
    _max?: OTPCodeMaxOrderByAggregateInput
    _min?: OTPCodeMinOrderByAggregateInput
    _sum?: OTPCodeSumOrderByAggregateInput
  }

  export type OTPCodeScalarWhereWithAggregatesInput = {
    AND?: OTPCodeScalarWhereWithAggregatesInput | OTPCodeScalarWhereWithAggregatesInput[]
    OR?: OTPCodeScalarWhereWithAggregatesInput[]
    NOT?: OTPCodeScalarWhereWithAggregatesInput | OTPCodeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"OTPCode"> | string
    userId?: UuidWithAggregatesFilter<"OTPCode"> | string
    codeHash?: StringWithAggregatesFilter<"OTPCode"> | string
    purpose?: EnumOTPPurposeWithAggregatesFilter<"OTPCode"> | $Enums.OTPPurpose
    deliveryMethod?: StringNullableWithAggregatesFilter<"OTPCode"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"OTPCode"> | Date | string
    isUsed?: BoolWithAggregatesFilter<"OTPCode"> | boolean
    attemptsCount?: IntWithAggregatesFilter<"OTPCode"> | number
    maxAttempts?: IntWithAggregatesFilter<"OTPCode"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OTPCode"> | Date | string
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    id?: UuidFilter<"UserSession"> | string
    userId?: UuidFilter<"UserSession"> | string
    refreshTokenHash?: StringFilter<"UserSession"> | string
    deviceInfo?: JsonNullableFilter<"UserSession">
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    lastUsedAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenHash?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    userId?: UuidFilter<"UserSession"> | string
    refreshTokenHash?: StringFilter<"UserSession"> | string
    deviceInfo?: JsonNullableFilter<"UserSession">
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    lastUsedAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenHash?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UserSession"> | string
    userId?: UuidWithAggregatesFilter<"UserSession"> | string
    refreshTokenHash?: StringWithAggregatesFilter<"UserSession"> | string
    deviceInfo?: JsonNullableWithAggregatesFilter<"UserSession">
    ipAddress?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    lastUsedAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
  }

  export type ExecutiveWhereInput = {
    AND?: ExecutiveWhereInput | ExecutiveWhereInput[]
    OR?: ExecutiveWhereInput[]
    NOT?: ExecutiveWhereInput | ExecutiveWhereInput[]
    id?: UuidFilter<"Executive"> | string
    userId?: UuidFilter<"Executive"> | string
    employeeId?: StringFilter<"Executive"> | string
    territory?: StringNullableFilter<"Executive"> | string | null
    isActive?: BoolFilter<"Executive"> | boolean
    createdAt?: DateTimeFilter<"Executive"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ExecutiveOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrder
    territory?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ExecutiveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    employeeId?: string
    AND?: ExecutiveWhereInput | ExecutiveWhereInput[]
    OR?: ExecutiveWhereInput[]
    NOT?: ExecutiveWhereInput | ExecutiveWhereInput[]
    territory?: StringNullableFilter<"Executive"> | string | null
    isActive?: BoolFilter<"Executive"> | boolean
    createdAt?: DateTimeFilter<"Executive"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId" | "employeeId">

  export type ExecutiveOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrder
    territory?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: ExecutiveCountOrderByAggregateInput
    _max?: ExecutiveMaxOrderByAggregateInput
    _min?: ExecutiveMinOrderByAggregateInput
  }

  export type ExecutiveScalarWhereWithAggregatesInput = {
    AND?: ExecutiveScalarWhereWithAggregatesInput | ExecutiveScalarWhereWithAggregatesInput[]
    OR?: ExecutiveScalarWhereWithAggregatesInput[]
    NOT?: ExecutiveScalarWhereWithAggregatesInput | ExecutiveScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Executive"> | string
    userId?: UuidWithAggregatesFilter<"Executive"> | string
    employeeId?: StringWithAggregatesFilter<"Executive"> | string
    territory?: StringNullableWithAggregatesFilter<"Executive"> | string | null
    isActive?: BoolWithAggregatesFilter<"Executive"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Executive"> | Date | string
  }

  export type PetOwnerWhereInput = {
    AND?: PetOwnerWhereInput | PetOwnerWhereInput[]
    OR?: PetOwnerWhereInput[]
    NOT?: PetOwnerWhereInput | PetOwnerWhereInput[]
    id?: UuidFilter<"PetOwner"> | string
    userId?: UuidFilter<"PetOwner"> | string
    addressLine1?: StringNullableFilter<"PetOwner"> | string | null
    addressLine2?: StringNullableFilter<"PetOwner"> | string | null
    city?: StringNullableFilter<"PetOwner"> | string | null
    state?: StringNullableFilter<"PetOwner"> | string | null
    postalCode?: StringNullableFilter<"PetOwner"> | string | null
    countryCode?: StringFilter<"PetOwner"> | string
    emergencyContactName?: StringNullableFilter<"PetOwner"> | string | null
    emergencyContactPhone?: StringNullableFilter<"PetOwner"> | string | null
    createdAt?: DateTimeFilter<"PetOwner"> | Date | string
    updatedAt?: DateTimeFilter<"PetOwner"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    pets?: PetListRelationFilter
  }

  export type PetOwnerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    countryCode?: SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    pets?: PetOrderByRelationAggregateInput
  }

  export type PetOwnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: PetOwnerWhereInput | PetOwnerWhereInput[]
    OR?: PetOwnerWhereInput[]
    NOT?: PetOwnerWhereInput | PetOwnerWhereInput[]
    addressLine1?: StringNullableFilter<"PetOwner"> | string | null
    addressLine2?: StringNullableFilter<"PetOwner"> | string | null
    city?: StringNullableFilter<"PetOwner"> | string | null
    state?: StringNullableFilter<"PetOwner"> | string | null
    postalCode?: StringNullableFilter<"PetOwner"> | string | null
    countryCode?: StringFilter<"PetOwner"> | string
    emergencyContactName?: StringNullableFilter<"PetOwner"> | string | null
    emergencyContactPhone?: StringNullableFilter<"PetOwner"> | string | null
    createdAt?: DateTimeFilter<"PetOwner"> | Date | string
    updatedAt?: DateTimeFilter<"PetOwner"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    pets?: PetListRelationFilter
  }, "id" | "userId">

  export type PetOwnerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    countryCode?: SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PetOwnerCountOrderByAggregateInput
    _max?: PetOwnerMaxOrderByAggregateInput
    _min?: PetOwnerMinOrderByAggregateInput
  }

  export type PetOwnerScalarWhereWithAggregatesInput = {
    AND?: PetOwnerScalarWhereWithAggregatesInput | PetOwnerScalarWhereWithAggregatesInput[]
    OR?: PetOwnerScalarWhereWithAggregatesInput[]
    NOT?: PetOwnerScalarWhereWithAggregatesInput | PetOwnerScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PetOwner"> | string
    userId?: UuidWithAggregatesFilter<"PetOwner"> | string
    addressLine1?: StringNullableWithAggregatesFilter<"PetOwner"> | string | null
    addressLine2?: StringNullableWithAggregatesFilter<"PetOwner"> | string | null
    city?: StringNullableWithAggregatesFilter<"PetOwner"> | string | null
    state?: StringNullableWithAggregatesFilter<"PetOwner"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"PetOwner"> | string | null
    countryCode?: StringWithAggregatesFilter<"PetOwner"> | string
    emergencyContactName?: StringNullableWithAggregatesFilter<"PetOwner"> | string | null
    emergencyContactPhone?: StringNullableWithAggregatesFilter<"PetOwner"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PetOwner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PetOwner"> | Date | string
  }

  export type PetSpeciesWhereInput = {
    AND?: PetSpeciesWhereInput | PetSpeciesWhereInput[]
    OR?: PetSpeciesWhereInput[]
    NOT?: PetSpeciesWhereInput | PetSpeciesWhereInput[]
    id?: IntFilter<"PetSpecies"> | number
    speciesName?: StringFilter<"PetSpecies"> | string
    category?: StringFilter<"PetSpecies"> | string
    breeds?: PetBreedListRelationFilter
    pets?: PetListRelationFilter
  }

  export type PetSpeciesOrderByWithRelationInput = {
    id?: SortOrder
    speciesName?: SortOrder
    category?: SortOrder
    breeds?: PetBreedOrderByRelationAggregateInput
    pets?: PetOrderByRelationAggregateInput
  }

  export type PetSpeciesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    speciesName?: string
    AND?: PetSpeciesWhereInput | PetSpeciesWhereInput[]
    OR?: PetSpeciesWhereInput[]
    NOT?: PetSpeciesWhereInput | PetSpeciesWhereInput[]
    category?: StringFilter<"PetSpecies"> | string
    breeds?: PetBreedListRelationFilter
    pets?: PetListRelationFilter
  }, "id" | "speciesName">

  export type PetSpeciesOrderByWithAggregationInput = {
    id?: SortOrder
    speciesName?: SortOrder
    category?: SortOrder
    _count?: PetSpeciesCountOrderByAggregateInput
    _avg?: PetSpeciesAvgOrderByAggregateInput
    _max?: PetSpeciesMaxOrderByAggregateInput
    _min?: PetSpeciesMinOrderByAggregateInput
    _sum?: PetSpeciesSumOrderByAggregateInput
  }

  export type PetSpeciesScalarWhereWithAggregatesInput = {
    AND?: PetSpeciesScalarWhereWithAggregatesInput | PetSpeciesScalarWhereWithAggregatesInput[]
    OR?: PetSpeciesScalarWhereWithAggregatesInput[]
    NOT?: PetSpeciesScalarWhereWithAggregatesInput | PetSpeciesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PetSpecies"> | number
    speciesName?: StringWithAggregatesFilter<"PetSpecies"> | string
    category?: StringWithAggregatesFilter<"PetSpecies"> | string
  }

  export type PetBreedWhereInput = {
    AND?: PetBreedWhereInput | PetBreedWhereInput[]
    OR?: PetBreedWhereInput[]
    NOT?: PetBreedWhereInput | PetBreedWhereInput[]
    id?: IntFilter<"PetBreed"> | number
    breedName?: StringFilter<"PetBreed"> | string
    speciesId?: IntFilter<"PetBreed"> | number
    sizeCategory?: EnumSizeCategoryNullableFilter<"PetBreed"> | $Enums.SizeCategory | null
    typicalLifespanYears?: IntNullableFilter<"PetBreed"> | number | null
    species?: XOR<PetSpeciesScalarRelationFilter, PetSpeciesWhereInput>
    pets_pets_breed_idTopet_breeds?: PetListRelationFilter
    pets_pets_secondary_breed_idTopet_breeds?: PetListRelationFilter
  }

  export type PetBreedOrderByWithRelationInput = {
    id?: SortOrder
    breedName?: SortOrder
    speciesId?: SortOrder
    sizeCategory?: SortOrderInput | SortOrder
    typicalLifespanYears?: SortOrderInput | SortOrder
    species?: PetSpeciesOrderByWithRelationInput
    pets_pets_breed_idTopet_breeds?: PetOrderByRelationAggregateInput
    pets_pets_secondary_breed_idTopet_breeds?: PetOrderByRelationAggregateInput
  }

  export type PetBreedWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PetBreedWhereInput | PetBreedWhereInput[]
    OR?: PetBreedWhereInput[]
    NOT?: PetBreedWhereInput | PetBreedWhereInput[]
    breedName?: StringFilter<"PetBreed"> | string
    speciesId?: IntFilter<"PetBreed"> | number
    sizeCategory?: EnumSizeCategoryNullableFilter<"PetBreed"> | $Enums.SizeCategory | null
    typicalLifespanYears?: IntNullableFilter<"PetBreed"> | number | null
    species?: XOR<PetSpeciesScalarRelationFilter, PetSpeciesWhereInput>
    pets_pets_breed_idTopet_breeds?: PetListRelationFilter
    pets_pets_secondary_breed_idTopet_breeds?: PetListRelationFilter
  }, "id">

  export type PetBreedOrderByWithAggregationInput = {
    id?: SortOrder
    breedName?: SortOrder
    speciesId?: SortOrder
    sizeCategory?: SortOrderInput | SortOrder
    typicalLifespanYears?: SortOrderInput | SortOrder
    _count?: PetBreedCountOrderByAggregateInput
    _avg?: PetBreedAvgOrderByAggregateInput
    _max?: PetBreedMaxOrderByAggregateInput
    _min?: PetBreedMinOrderByAggregateInput
    _sum?: PetBreedSumOrderByAggregateInput
  }

  export type PetBreedScalarWhereWithAggregatesInput = {
    AND?: PetBreedScalarWhereWithAggregatesInput | PetBreedScalarWhereWithAggregatesInput[]
    OR?: PetBreedScalarWhereWithAggregatesInput[]
    NOT?: PetBreedScalarWhereWithAggregatesInput | PetBreedScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PetBreed"> | number
    breedName?: StringWithAggregatesFilter<"PetBreed"> | string
    speciesId?: IntWithAggregatesFilter<"PetBreed"> | number
    sizeCategory?: EnumSizeCategoryNullableWithAggregatesFilter<"PetBreed"> | $Enums.SizeCategory | null
    typicalLifespanYears?: IntNullableWithAggregatesFilter<"PetBreed"> | number | null
  }

  export type PetWhereInput = {
    AND?: PetWhereInput | PetWhereInput[]
    OR?: PetWhereInput[]
    NOT?: PetWhereInput | PetWhereInput[]
    id?: UuidFilter<"Pet"> | string
    ownerId?: UuidFilter<"Pet"> | string
    registeredBy?: UuidNullableFilter<"Pet"> | string | null
    name?: StringFilter<"Pet"> | string
    speciesId?: IntNullableFilter<"Pet"> | number | null
    breed_id?: IntNullableFilter<"Pet"> | number | null
    secondary_breed_id?: IntNullableFilter<"Pet"> | number | null
    gender?: EnumGenderFilter<"Pet"> | $Enums.Gender
    birthDate?: DateTimeNullableFilter<"Pet"> | Date | string | null
    color?: StringNullableFilter<"Pet"> | string | null
    weightKg?: DecimalNullableFilter<"Pet"> | Decimal | DecimalJsLike | number | string | null
    heightCm?: DecimalNullableFilter<"Pet"> | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: StringNullableFilter<"Pet"> | string | null
    isSpayedNeutered?: BoolNullableFilter<"Pet"> | boolean | null
    microchip_id?: StringNullableFilter<"Pet"> | string | null
    registrationNumber?: StringNullableFilter<"Pet"> | string | null
    status?: EnumPetStatusFilter<"Pet"> | $Enums.PetStatus
    specialNeeds?: StringNullableFilter<"Pet"> | string | null
    behavioralNotes?: StringNullableFilter<"Pet"> | string | null
    profileImageUrl?: StringNullableFilter<"Pet"> | string | null
    createdAt?: DateTimeFilter<"Pet"> | Date | string
    updatedAt?: DateTimeFilter<"Pet"> | Date | string
    medicalRecords?: MedicalRecordListRelationFilter
    notifications?: NotificationListRelationFilter
    paymentEvents?: PaymentEventListRelationFilter
    locationEvents?: PetLocationEventListRelationFilter
    qrScanEvents?: QRScanEventListRelationFilter
    pet_breeds_pets_breed_idTopet_breeds?: XOR<PetBreedNullableScalarRelationFilter, PetBreedWhereInput> | null
    owner?: XOR<PetOwnerScalarRelationFilter, PetOwnerWhereInput>
    registeredByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    pet_breeds_pets_secondary_breed_idTopet_breeds?: XOR<PetBreedNullableScalarRelationFilter, PetBreedWhereInput> | null
    species?: XOR<PetSpeciesNullableScalarRelationFilter, PetSpeciesWhereInput> | null
    qrCodes?: QRCodeListRelationFilter
    supportTickets?: SupportTicketListRelationFilter
    vaccinationRecords?: VaccinationRecordListRelationFilter
  }

  export type PetOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    registeredBy?: SortOrderInput | SortOrder
    name?: SortOrder
    speciesId?: SortOrderInput | SortOrder
    breed_id?: SortOrderInput | SortOrder
    secondary_breed_id?: SortOrderInput | SortOrder
    gender?: SortOrder
    birthDate?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    weightKg?: SortOrderInput | SortOrder
    heightCm?: SortOrderInput | SortOrder
    distinctiveMarks?: SortOrderInput | SortOrder
    isSpayedNeutered?: SortOrderInput | SortOrder
    microchip_id?: SortOrderInput | SortOrder
    registrationNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    specialNeeds?: SortOrderInput | SortOrder
    behavioralNotes?: SortOrderInput | SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    medicalRecords?: MedicalRecordOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    paymentEvents?: PaymentEventOrderByRelationAggregateInput
    locationEvents?: PetLocationEventOrderByRelationAggregateInput
    qrScanEvents?: QRScanEventOrderByRelationAggregateInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedOrderByWithRelationInput
    owner?: PetOwnerOrderByWithRelationInput
    registeredByUser?: UserOrderByWithRelationInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedOrderByWithRelationInput
    species?: PetSpeciesOrderByWithRelationInput
    qrCodes?: QRCodeOrderByRelationAggregateInput
    supportTickets?: SupportTicketOrderByRelationAggregateInput
    vaccinationRecords?: VaccinationRecordOrderByRelationAggregateInput
  }

  export type PetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    microchip_id?: string
    registrationNumber?: string
    AND?: PetWhereInput | PetWhereInput[]
    OR?: PetWhereInput[]
    NOT?: PetWhereInput | PetWhereInput[]
    ownerId?: UuidFilter<"Pet"> | string
    registeredBy?: UuidNullableFilter<"Pet"> | string | null
    name?: StringFilter<"Pet"> | string
    speciesId?: IntNullableFilter<"Pet"> | number | null
    breed_id?: IntNullableFilter<"Pet"> | number | null
    secondary_breed_id?: IntNullableFilter<"Pet"> | number | null
    gender?: EnumGenderFilter<"Pet"> | $Enums.Gender
    birthDate?: DateTimeNullableFilter<"Pet"> | Date | string | null
    color?: StringNullableFilter<"Pet"> | string | null
    weightKg?: DecimalNullableFilter<"Pet"> | Decimal | DecimalJsLike | number | string | null
    heightCm?: DecimalNullableFilter<"Pet"> | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: StringNullableFilter<"Pet"> | string | null
    isSpayedNeutered?: BoolNullableFilter<"Pet"> | boolean | null
    status?: EnumPetStatusFilter<"Pet"> | $Enums.PetStatus
    specialNeeds?: StringNullableFilter<"Pet"> | string | null
    behavioralNotes?: StringNullableFilter<"Pet"> | string | null
    profileImageUrl?: StringNullableFilter<"Pet"> | string | null
    createdAt?: DateTimeFilter<"Pet"> | Date | string
    updatedAt?: DateTimeFilter<"Pet"> | Date | string
    medicalRecords?: MedicalRecordListRelationFilter
    notifications?: NotificationListRelationFilter
    paymentEvents?: PaymentEventListRelationFilter
    locationEvents?: PetLocationEventListRelationFilter
    qrScanEvents?: QRScanEventListRelationFilter
    pet_breeds_pets_breed_idTopet_breeds?: XOR<PetBreedNullableScalarRelationFilter, PetBreedWhereInput> | null
    owner?: XOR<PetOwnerScalarRelationFilter, PetOwnerWhereInput>
    registeredByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    pet_breeds_pets_secondary_breed_idTopet_breeds?: XOR<PetBreedNullableScalarRelationFilter, PetBreedWhereInput> | null
    species?: XOR<PetSpeciesNullableScalarRelationFilter, PetSpeciesWhereInput> | null
    qrCodes?: QRCodeListRelationFilter
    supportTickets?: SupportTicketListRelationFilter
    vaccinationRecords?: VaccinationRecordListRelationFilter
  }, "id" | "microchip_id" | "registrationNumber">

  export type PetOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    registeredBy?: SortOrderInput | SortOrder
    name?: SortOrder
    speciesId?: SortOrderInput | SortOrder
    breed_id?: SortOrderInput | SortOrder
    secondary_breed_id?: SortOrderInput | SortOrder
    gender?: SortOrder
    birthDate?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    weightKg?: SortOrderInput | SortOrder
    heightCm?: SortOrderInput | SortOrder
    distinctiveMarks?: SortOrderInput | SortOrder
    isSpayedNeutered?: SortOrderInput | SortOrder
    microchip_id?: SortOrderInput | SortOrder
    registrationNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    specialNeeds?: SortOrderInput | SortOrder
    behavioralNotes?: SortOrderInput | SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PetCountOrderByAggregateInput
    _avg?: PetAvgOrderByAggregateInput
    _max?: PetMaxOrderByAggregateInput
    _min?: PetMinOrderByAggregateInput
    _sum?: PetSumOrderByAggregateInput
  }

  export type PetScalarWhereWithAggregatesInput = {
    AND?: PetScalarWhereWithAggregatesInput | PetScalarWhereWithAggregatesInput[]
    OR?: PetScalarWhereWithAggregatesInput[]
    NOT?: PetScalarWhereWithAggregatesInput | PetScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Pet"> | string
    ownerId?: UuidWithAggregatesFilter<"Pet"> | string
    registeredBy?: UuidNullableWithAggregatesFilter<"Pet"> | string | null
    name?: StringWithAggregatesFilter<"Pet"> | string
    speciesId?: IntNullableWithAggregatesFilter<"Pet"> | number | null
    breed_id?: IntNullableWithAggregatesFilter<"Pet"> | number | null
    secondary_breed_id?: IntNullableWithAggregatesFilter<"Pet"> | number | null
    gender?: EnumGenderWithAggregatesFilter<"Pet"> | $Enums.Gender
    birthDate?: DateTimeNullableWithAggregatesFilter<"Pet"> | Date | string | null
    color?: StringNullableWithAggregatesFilter<"Pet"> | string | null
    weightKg?: DecimalNullableWithAggregatesFilter<"Pet"> | Decimal | DecimalJsLike | number | string | null
    heightCm?: DecimalNullableWithAggregatesFilter<"Pet"> | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: StringNullableWithAggregatesFilter<"Pet"> | string | null
    isSpayedNeutered?: BoolNullableWithAggregatesFilter<"Pet"> | boolean | null
    microchip_id?: StringNullableWithAggregatesFilter<"Pet"> | string | null
    registrationNumber?: StringNullableWithAggregatesFilter<"Pet"> | string | null
    status?: EnumPetStatusWithAggregatesFilter<"Pet"> | $Enums.PetStatus
    specialNeeds?: StringNullableWithAggregatesFilter<"Pet"> | string | null
    behavioralNotes?: StringNullableWithAggregatesFilter<"Pet"> | string | null
    profileImageUrl?: StringNullableWithAggregatesFilter<"Pet"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Pet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pet"> | Date | string
  }

  export type VaccineTypeWhereInput = {
    AND?: VaccineTypeWhereInput | VaccineTypeWhereInput[]
    OR?: VaccineTypeWhereInput[]
    NOT?: VaccineTypeWhereInput | VaccineTypeWhereInput[]
    id?: IntFilter<"VaccineType"> | number
    vaccineName?: StringFilter<"VaccineType"> | string
    speciesApplicability?: IntNullableListFilter<"VaccineType">
    durationMonths?: IntNullableFilter<"VaccineType"> | number | null
    isRequiredByLaw?: BoolFilter<"VaccineType"> | boolean
    vaccinationRecords?: VaccinationRecordListRelationFilter
  }

  export type VaccineTypeOrderByWithRelationInput = {
    id?: SortOrder
    vaccineName?: SortOrder
    speciesApplicability?: SortOrder
    durationMonths?: SortOrderInput | SortOrder
    isRequiredByLaw?: SortOrder
    vaccinationRecords?: VaccinationRecordOrderByRelationAggregateInput
  }

  export type VaccineTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VaccineTypeWhereInput | VaccineTypeWhereInput[]
    OR?: VaccineTypeWhereInput[]
    NOT?: VaccineTypeWhereInput | VaccineTypeWhereInput[]
    vaccineName?: StringFilter<"VaccineType"> | string
    speciesApplicability?: IntNullableListFilter<"VaccineType">
    durationMonths?: IntNullableFilter<"VaccineType"> | number | null
    isRequiredByLaw?: BoolFilter<"VaccineType"> | boolean
    vaccinationRecords?: VaccinationRecordListRelationFilter
  }, "id">

  export type VaccineTypeOrderByWithAggregationInput = {
    id?: SortOrder
    vaccineName?: SortOrder
    speciesApplicability?: SortOrder
    durationMonths?: SortOrderInput | SortOrder
    isRequiredByLaw?: SortOrder
    _count?: VaccineTypeCountOrderByAggregateInput
    _avg?: VaccineTypeAvgOrderByAggregateInput
    _max?: VaccineTypeMaxOrderByAggregateInput
    _min?: VaccineTypeMinOrderByAggregateInput
    _sum?: VaccineTypeSumOrderByAggregateInput
  }

  export type VaccineTypeScalarWhereWithAggregatesInput = {
    AND?: VaccineTypeScalarWhereWithAggregatesInput | VaccineTypeScalarWhereWithAggregatesInput[]
    OR?: VaccineTypeScalarWhereWithAggregatesInput[]
    NOT?: VaccineTypeScalarWhereWithAggregatesInput | VaccineTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VaccineType"> | number
    vaccineName?: StringWithAggregatesFilter<"VaccineType"> | string
    speciesApplicability?: IntNullableListFilter<"VaccineType">
    durationMonths?: IntNullableWithAggregatesFilter<"VaccineType"> | number | null
    isRequiredByLaw?: BoolWithAggregatesFilter<"VaccineType"> | boolean
  }

  export type VaccinationRecordWhereInput = {
    AND?: VaccinationRecordWhereInput | VaccinationRecordWhereInput[]
    OR?: VaccinationRecordWhereInput[]
    NOT?: VaccinationRecordWhereInput | VaccinationRecordWhereInput[]
    id?: UuidFilter<"VaccinationRecord"> | string
    petId?: UuidFilter<"VaccinationRecord"> | string
    vaccineTypeId?: IntFilter<"VaccinationRecord"> | number
    administeredDate?: DateTimeFilter<"VaccinationRecord"> | Date | string
    expirationDate?: DateTimeNullableFilter<"VaccinationRecord"> | Date | string | null
    batchNumber?: StringNullableFilter<"VaccinationRecord"> | string | null
    veterinarianName?: StringNullableFilter<"VaccinationRecord"> | string | null
    clinicName?: StringNullableFilter<"VaccinationRecord"> | string | null
    notes?: StringNullableFilter<"VaccinationRecord"> | string | null
    certificateUrl?: StringNullableFilter<"VaccinationRecord"> | string | null
    createdAt?: DateTimeFilter<"VaccinationRecord"> | Date | string
    pet?: XOR<PetScalarRelationFilter, PetWhereInput>
    vaccineType?: XOR<VaccineTypeScalarRelationFilter, VaccineTypeWhereInput>
  }

  export type VaccinationRecordOrderByWithRelationInput = {
    id?: SortOrder
    petId?: SortOrder
    vaccineTypeId?: SortOrder
    administeredDate?: SortOrder
    expirationDate?: SortOrderInput | SortOrder
    batchNumber?: SortOrderInput | SortOrder
    veterinarianName?: SortOrderInput | SortOrder
    clinicName?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    certificateUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    pet?: PetOrderByWithRelationInput
    vaccineType?: VaccineTypeOrderByWithRelationInput
  }

  export type VaccinationRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VaccinationRecordWhereInput | VaccinationRecordWhereInput[]
    OR?: VaccinationRecordWhereInput[]
    NOT?: VaccinationRecordWhereInput | VaccinationRecordWhereInput[]
    petId?: UuidFilter<"VaccinationRecord"> | string
    vaccineTypeId?: IntFilter<"VaccinationRecord"> | number
    administeredDate?: DateTimeFilter<"VaccinationRecord"> | Date | string
    expirationDate?: DateTimeNullableFilter<"VaccinationRecord"> | Date | string | null
    batchNumber?: StringNullableFilter<"VaccinationRecord"> | string | null
    veterinarianName?: StringNullableFilter<"VaccinationRecord"> | string | null
    clinicName?: StringNullableFilter<"VaccinationRecord"> | string | null
    notes?: StringNullableFilter<"VaccinationRecord"> | string | null
    certificateUrl?: StringNullableFilter<"VaccinationRecord"> | string | null
    createdAt?: DateTimeFilter<"VaccinationRecord"> | Date | string
    pet?: XOR<PetScalarRelationFilter, PetWhereInput>
    vaccineType?: XOR<VaccineTypeScalarRelationFilter, VaccineTypeWhereInput>
  }, "id">

  export type VaccinationRecordOrderByWithAggregationInput = {
    id?: SortOrder
    petId?: SortOrder
    vaccineTypeId?: SortOrder
    administeredDate?: SortOrder
    expirationDate?: SortOrderInput | SortOrder
    batchNumber?: SortOrderInput | SortOrder
    veterinarianName?: SortOrderInput | SortOrder
    clinicName?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    certificateUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VaccinationRecordCountOrderByAggregateInput
    _avg?: VaccinationRecordAvgOrderByAggregateInput
    _max?: VaccinationRecordMaxOrderByAggregateInput
    _min?: VaccinationRecordMinOrderByAggregateInput
    _sum?: VaccinationRecordSumOrderByAggregateInput
  }

  export type VaccinationRecordScalarWhereWithAggregatesInput = {
    AND?: VaccinationRecordScalarWhereWithAggregatesInput | VaccinationRecordScalarWhereWithAggregatesInput[]
    OR?: VaccinationRecordScalarWhereWithAggregatesInput[]
    NOT?: VaccinationRecordScalarWhereWithAggregatesInput | VaccinationRecordScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"VaccinationRecord"> | string
    petId?: UuidWithAggregatesFilter<"VaccinationRecord"> | string
    vaccineTypeId?: IntWithAggregatesFilter<"VaccinationRecord"> | number
    administeredDate?: DateTimeWithAggregatesFilter<"VaccinationRecord"> | Date | string
    expirationDate?: DateTimeNullableWithAggregatesFilter<"VaccinationRecord"> | Date | string | null
    batchNumber?: StringNullableWithAggregatesFilter<"VaccinationRecord"> | string | null
    veterinarianName?: StringNullableWithAggregatesFilter<"VaccinationRecord"> | string | null
    clinicName?: StringNullableWithAggregatesFilter<"VaccinationRecord"> | string | null
    notes?: StringNullableWithAggregatesFilter<"VaccinationRecord"> | string | null
    certificateUrl?: StringNullableWithAggregatesFilter<"VaccinationRecord"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VaccinationRecord"> | Date | string
  }

  export type MedicalRecordWhereInput = {
    AND?: MedicalRecordWhereInput | MedicalRecordWhereInput[]
    OR?: MedicalRecordWhereInput[]
    NOT?: MedicalRecordWhereInput | MedicalRecordWhereInput[]
    id?: UuidFilter<"MedicalRecord"> | string
    petId?: UuidFilter<"MedicalRecord"> | string
    visitDate?: DateTimeFilter<"MedicalRecord"> | Date | string
    veterinarianName?: StringNullableFilter<"MedicalRecord"> | string | null
    clinicName?: StringNullableFilter<"MedicalRecord"> | string | null
    diagnosis?: StringNullableFilter<"MedicalRecord"> | string | null
    treatment?: StringNullableFilter<"MedicalRecord"> | string | null
    medications?: JsonNullableFilter<"MedicalRecord">
    followUpRequired?: BoolFilter<"MedicalRecord"> | boolean
    followUpDate?: DateTimeNullableFilter<"MedicalRecord"> | Date | string | null
    cost?: DecimalNullableFilter<"MedicalRecord"> | Decimal | DecimalJsLike | number | string | null
    documentUrls?: StringNullableListFilter<"MedicalRecord">
    createdAt?: DateTimeFilter<"MedicalRecord"> | Date | string
    pet?: XOR<PetScalarRelationFilter, PetWhereInput>
  }

  export type MedicalRecordOrderByWithRelationInput = {
    id?: SortOrder
    petId?: SortOrder
    visitDate?: SortOrder
    veterinarianName?: SortOrderInput | SortOrder
    clinicName?: SortOrderInput | SortOrder
    diagnosis?: SortOrderInput | SortOrder
    treatment?: SortOrderInput | SortOrder
    medications?: SortOrderInput | SortOrder
    followUpRequired?: SortOrder
    followUpDate?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    documentUrls?: SortOrder
    createdAt?: SortOrder
    pet?: PetOrderByWithRelationInput
  }

  export type MedicalRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicalRecordWhereInput | MedicalRecordWhereInput[]
    OR?: MedicalRecordWhereInput[]
    NOT?: MedicalRecordWhereInput | MedicalRecordWhereInput[]
    petId?: UuidFilter<"MedicalRecord"> | string
    visitDate?: DateTimeFilter<"MedicalRecord"> | Date | string
    veterinarianName?: StringNullableFilter<"MedicalRecord"> | string | null
    clinicName?: StringNullableFilter<"MedicalRecord"> | string | null
    diagnosis?: StringNullableFilter<"MedicalRecord"> | string | null
    treatment?: StringNullableFilter<"MedicalRecord"> | string | null
    medications?: JsonNullableFilter<"MedicalRecord">
    followUpRequired?: BoolFilter<"MedicalRecord"> | boolean
    followUpDate?: DateTimeNullableFilter<"MedicalRecord"> | Date | string | null
    cost?: DecimalNullableFilter<"MedicalRecord"> | Decimal | DecimalJsLike | number | string | null
    documentUrls?: StringNullableListFilter<"MedicalRecord">
    createdAt?: DateTimeFilter<"MedicalRecord"> | Date | string
    pet?: XOR<PetScalarRelationFilter, PetWhereInput>
  }, "id">

  export type MedicalRecordOrderByWithAggregationInput = {
    id?: SortOrder
    petId?: SortOrder
    visitDate?: SortOrder
    veterinarianName?: SortOrderInput | SortOrder
    clinicName?: SortOrderInput | SortOrder
    diagnosis?: SortOrderInput | SortOrder
    treatment?: SortOrderInput | SortOrder
    medications?: SortOrderInput | SortOrder
    followUpRequired?: SortOrder
    followUpDate?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    documentUrls?: SortOrder
    createdAt?: SortOrder
    _count?: MedicalRecordCountOrderByAggregateInput
    _avg?: MedicalRecordAvgOrderByAggregateInput
    _max?: MedicalRecordMaxOrderByAggregateInput
    _min?: MedicalRecordMinOrderByAggregateInput
    _sum?: MedicalRecordSumOrderByAggregateInput
  }

  export type MedicalRecordScalarWhereWithAggregatesInput = {
    AND?: MedicalRecordScalarWhereWithAggregatesInput | MedicalRecordScalarWhereWithAggregatesInput[]
    OR?: MedicalRecordScalarWhereWithAggregatesInput[]
    NOT?: MedicalRecordScalarWhereWithAggregatesInput | MedicalRecordScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MedicalRecord"> | string
    petId?: UuidWithAggregatesFilter<"MedicalRecord"> | string
    visitDate?: DateTimeWithAggregatesFilter<"MedicalRecord"> | Date | string
    veterinarianName?: StringNullableWithAggregatesFilter<"MedicalRecord"> | string | null
    clinicName?: StringNullableWithAggregatesFilter<"MedicalRecord"> | string | null
    diagnosis?: StringNullableWithAggregatesFilter<"MedicalRecord"> | string | null
    treatment?: StringNullableWithAggregatesFilter<"MedicalRecord"> | string | null
    medications?: JsonNullableWithAggregatesFilter<"MedicalRecord">
    followUpRequired?: BoolWithAggregatesFilter<"MedicalRecord"> | boolean
    followUpDate?: DateTimeNullableWithAggregatesFilter<"MedicalRecord"> | Date | string | null
    cost?: DecimalNullableWithAggregatesFilter<"MedicalRecord"> | Decimal | DecimalJsLike | number | string | null
    documentUrls?: StringNullableListFilter<"MedicalRecord">
    createdAt?: DateTimeWithAggregatesFilter<"MedicalRecord"> | Date | string
  }

  export type QRCodePoolWhereInput = {
    AND?: QRCodePoolWhereInput | QRCodePoolWhereInput[]
    OR?: QRCodePoolWhereInput[]
    NOT?: QRCodePoolWhereInput | QRCodePoolWhereInput[]
    id?: UuidFilter<"QRCodePool"> | string
    poolName?: StringFilter<"QRCodePool"> | string
    totalCapacity?: IntFilter<"QRCodePool"> | number
    usedCount?: IntFilter<"QRCodePool"> | number
    createdAt?: DateTimeFilter<"QRCodePool"> | Date | string
    status?: EnumPoolStatusFilter<"QRCodePool"> | $Enums.PoolStatus
    qrCodes?: QRCodeListRelationFilter
  }

  export type QRCodePoolOrderByWithRelationInput = {
    id?: SortOrder
    poolName?: SortOrder
    totalCapacity?: SortOrder
    usedCount?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    qrCodes?: QRCodeOrderByRelationAggregateInput
  }

  export type QRCodePoolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QRCodePoolWhereInput | QRCodePoolWhereInput[]
    OR?: QRCodePoolWhereInput[]
    NOT?: QRCodePoolWhereInput | QRCodePoolWhereInput[]
    poolName?: StringFilter<"QRCodePool"> | string
    totalCapacity?: IntFilter<"QRCodePool"> | number
    usedCount?: IntFilter<"QRCodePool"> | number
    createdAt?: DateTimeFilter<"QRCodePool"> | Date | string
    status?: EnumPoolStatusFilter<"QRCodePool"> | $Enums.PoolStatus
    qrCodes?: QRCodeListRelationFilter
  }, "id">

  export type QRCodePoolOrderByWithAggregationInput = {
    id?: SortOrder
    poolName?: SortOrder
    totalCapacity?: SortOrder
    usedCount?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    _count?: QRCodePoolCountOrderByAggregateInput
    _avg?: QRCodePoolAvgOrderByAggregateInput
    _max?: QRCodePoolMaxOrderByAggregateInput
    _min?: QRCodePoolMinOrderByAggregateInput
    _sum?: QRCodePoolSumOrderByAggregateInput
  }

  export type QRCodePoolScalarWhereWithAggregatesInput = {
    AND?: QRCodePoolScalarWhereWithAggregatesInput | QRCodePoolScalarWhereWithAggregatesInput[]
    OR?: QRCodePoolScalarWhereWithAggregatesInput[]
    NOT?: QRCodePoolScalarWhereWithAggregatesInput | QRCodePoolScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"QRCodePool"> | string
    poolName?: StringWithAggregatesFilter<"QRCodePool"> | string
    totalCapacity?: IntWithAggregatesFilter<"QRCodePool"> | number
    usedCount?: IntWithAggregatesFilter<"QRCodePool"> | number
    createdAt?: DateTimeWithAggregatesFilter<"QRCodePool"> | Date | string
    status?: EnumPoolStatusWithAggregatesFilter<"QRCodePool"> | $Enums.PoolStatus
  }

  export type QRCodeWhereInput = {
    AND?: QRCodeWhereInput | QRCodeWhereInput[]
    OR?: QRCodeWhereInput[]
    NOT?: QRCodeWhereInput | QRCodeWhereInput[]
    id?: UuidFilter<"QRCode"> | string
    poolId?: UuidNullableFilter<"QRCode"> | string | null
    qrCodeString?: StringFilter<"QRCode"> | string
    qrCodeHash?: StringFilter<"QRCode"> | string
    qrImageUrl?: StringNullableFilter<"QRCode"> | string | null
    status?: EnumQRStatusFilter<"QRCode"> | $Enums.QRStatus
    assignedToPet?: UuidNullableFilter<"QRCode"> | string | null
    assignedAt?: DateTimeNullableFilter<"QRCode"> | Date | string | null
    activatedAt?: DateTimeNullableFilter<"QRCode"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"QRCode"> | Date | string | null
    createdAt?: DateTimeFilter<"QRCode"> | Date | string
    paymentEvents?: PaymentEventListRelationFilter
    pet?: XOR<PetNullableScalarRelationFilter, PetWhereInput> | null
    pool?: XOR<QRCodePoolNullableScalarRelationFilter, QRCodePoolWhereInput> | null
    scanEvents?: QRScanEventListRelationFilter
  }

  export type QRCodeOrderByWithRelationInput = {
    id?: SortOrder
    poolId?: SortOrderInput | SortOrder
    qrCodeString?: SortOrder
    qrCodeHash?: SortOrder
    qrImageUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    assignedToPet?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    activatedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    paymentEvents?: PaymentEventOrderByRelationAggregateInput
    pet?: PetOrderByWithRelationInput
    pool?: QRCodePoolOrderByWithRelationInput
    scanEvents?: QRScanEventOrderByRelationAggregateInput
  }

  export type QRCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    qrCodeString?: string
    qrCodeHash?: string
    AND?: QRCodeWhereInput | QRCodeWhereInput[]
    OR?: QRCodeWhereInput[]
    NOT?: QRCodeWhereInput | QRCodeWhereInput[]
    poolId?: UuidNullableFilter<"QRCode"> | string | null
    qrImageUrl?: StringNullableFilter<"QRCode"> | string | null
    status?: EnumQRStatusFilter<"QRCode"> | $Enums.QRStatus
    assignedToPet?: UuidNullableFilter<"QRCode"> | string | null
    assignedAt?: DateTimeNullableFilter<"QRCode"> | Date | string | null
    activatedAt?: DateTimeNullableFilter<"QRCode"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"QRCode"> | Date | string | null
    createdAt?: DateTimeFilter<"QRCode"> | Date | string
    paymentEvents?: PaymentEventListRelationFilter
    pet?: XOR<PetNullableScalarRelationFilter, PetWhereInput> | null
    pool?: XOR<QRCodePoolNullableScalarRelationFilter, QRCodePoolWhereInput> | null
    scanEvents?: QRScanEventListRelationFilter
  }, "id" | "qrCodeString" | "qrCodeHash">

  export type QRCodeOrderByWithAggregationInput = {
    id?: SortOrder
    poolId?: SortOrderInput | SortOrder
    qrCodeString?: SortOrder
    qrCodeHash?: SortOrder
    qrImageUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    assignedToPet?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    activatedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: QRCodeCountOrderByAggregateInput
    _max?: QRCodeMaxOrderByAggregateInput
    _min?: QRCodeMinOrderByAggregateInput
  }

  export type QRCodeScalarWhereWithAggregatesInput = {
    AND?: QRCodeScalarWhereWithAggregatesInput | QRCodeScalarWhereWithAggregatesInput[]
    OR?: QRCodeScalarWhereWithAggregatesInput[]
    NOT?: QRCodeScalarWhereWithAggregatesInput | QRCodeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"QRCode"> | string
    poolId?: UuidNullableWithAggregatesFilter<"QRCode"> | string | null
    qrCodeString?: StringWithAggregatesFilter<"QRCode"> | string
    qrCodeHash?: StringWithAggregatesFilter<"QRCode"> | string
    qrImageUrl?: StringNullableWithAggregatesFilter<"QRCode"> | string | null
    status?: EnumQRStatusWithAggregatesFilter<"QRCode"> | $Enums.QRStatus
    assignedToPet?: UuidNullableWithAggregatesFilter<"QRCode"> | string | null
    assignedAt?: DateTimeNullableWithAggregatesFilter<"QRCode"> | Date | string | null
    activatedAt?: DateTimeNullableWithAggregatesFilter<"QRCode"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"QRCode"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"QRCode"> | Date | string
  }

  export type QRScanEventWhereInput = {
    AND?: QRScanEventWhereInput | QRScanEventWhereInput[]
    OR?: QRScanEventWhereInput[]
    NOT?: QRScanEventWhereInput | QRScanEventWhereInput[]
    id?: UuidFilter<"QRScanEvent"> | string
    qrId?: UuidFilter<"QRScanEvent"> | string
    petId?: UuidNullableFilter<"QRScanEvent"> | string | null
    scanTimestamp?: DateTimeFilter<"QRScanEvent"> | Date | string
    scannerIp?: StringNullableFilter<"QRScanEvent"> | string | null
    userAgent?: StringNullableFilter<"QRScanEvent"> | string | null
    deviceType?: EnumDeviceTypeNullableFilter<"QRScanEvent"> | $Enums.DeviceType | null
    scanLocation?: StringNullableFilter<"QRScanEvent"> | string | null
    locationAccuracy?: DecimalNullableFilter<"QRScanEvent"> | Decimal | DecimalJsLike | number | string | null
    locationName?: StringNullableFilter<"QRScanEvent"> | string | null
    countryCode?: StringNullableFilter<"QRScanEvent"> | string | null
    city?: StringNullableFilter<"QRScanEvent"> | string | null
    scannerContactInfo?: JsonNullableFilter<"QRScanEvent">
    scanResult?: EnumScanResultFilter<"QRScanEvent"> | $Enums.ScanResult
    createdAt?: DateTimeFilter<"QRScanEvent"> | Date | string
    qrCode?: XOR<QRCodeScalarRelationFilter, QRCodeWhereInput>
    pet?: XOR<PetNullableScalarRelationFilter, PetWhereInput> | null
    locationEvents?: PetLocationEventListRelationFilter
  }

  export type QRScanEventOrderByWithRelationInput = {
    id?: SortOrder
    qrId?: SortOrder
    petId?: SortOrderInput | SortOrder
    scanTimestamp?: SortOrder
    scannerIp?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    scanLocation?: SortOrderInput | SortOrder
    locationAccuracy?: SortOrderInput | SortOrder
    locationName?: SortOrderInput | SortOrder
    countryCode?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    scannerContactInfo?: SortOrderInput | SortOrder
    scanResult?: SortOrder
    createdAt?: SortOrder
    qrCode?: QRCodeOrderByWithRelationInput
    pet?: PetOrderByWithRelationInput
    locationEvents?: PetLocationEventOrderByRelationAggregateInput
  }

  export type QRScanEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QRScanEventWhereInput | QRScanEventWhereInput[]
    OR?: QRScanEventWhereInput[]
    NOT?: QRScanEventWhereInput | QRScanEventWhereInput[]
    qrId?: UuidFilter<"QRScanEvent"> | string
    petId?: UuidNullableFilter<"QRScanEvent"> | string | null
    scanTimestamp?: DateTimeFilter<"QRScanEvent"> | Date | string
    scannerIp?: StringNullableFilter<"QRScanEvent"> | string | null
    userAgent?: StringNullableFilter<"QRScanEvent"> | string | null
    deviceType?: EnumDeviceTypeNullableFilter<"QRScanEvent"> | $Enums.DeviceType | null
    scanLocation?: StringNullableFilter<"QRScanEvent"> | string | null
    locationAccuracy?: DecimalNullableFilter<"QRScanEvent"> | Decimal | DecimalJsLike | number | string | null
    locationName?: StringNullableFilter<"QRScanEvent"> | string | null
    countryCode?: StringNullableFilter<"QRScanEvent"> | string | null
    city?: StringNullableFilter<"QRScanEvent"> | string | null
    scannerContactInfo?: JsonNullableFilter<"QRScanEvent">
    scanResult?: EnumScanResultFilter<"QRScanEvent"> | $Enums.ScanResult
    createdAt?: DateTimeFilter<"QRScanEvent"> | Date | string
    qrCode?: XOR<QRCodeScalarRelationFilter, QRCodeWhereInput>
    pet?: XOR<PetNullableScalarRelationFilter, PetWhereInput> | null
    locationEvents?: PetLocationEventListRelationFilter
  }, "id">

  export type QRScanEventOrderByWithAggregationInput = {
    id?: SortOrder
    qrId?: SortOrder
    petId?: SortOrderInput | SortOrder
    scanTimestamp?: SortOrder
    scannerIp?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    scanLocation?: SortOrderInput | SortOrder
    locationAccuracy?: SortOrderInput | SortOrder
    locationName?: SortOrderInput | SortOrder
    countryCode?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    scannerContactInfo?: SortOrderInput | SortOrder
    scanResult?: SortOrder
    createdAt?: SortOrder
    _count?: QRScanEventCountOrderByAggregateInput
    _avg?: QRScanEventAvgOrderByAggregateInput
    _max?: QRScanEventMaxOrderByAggregateInput
    _min?: QRScanEventMinOrderByAggregateInput
    _sum?: QRScanEventSumOrderByAggregateInput
  }

  export type QRScanEventScalarWhereWithAggregatesInput = {
    AND?: QRScanEventScalarWhereWithAggregatesInput | QRScanEventScalarWhereWithAggregatesInput[]
    OR?: QRScanEventScalarWhereWithAggregatesInput[]
    NOT?: QRScanEventScalarWhereWithAggregatesInput | QRScanEventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"QRScanEvent"> | string
    qrId?: UuidWithAggregatesFilter<"QRScanEvent"> | string
    petId?: UuidNullableWithAggregatesFilter<"QRScanEvent"> | string | null
    scanTimestamp?: DateTimeWithAggregatesFilter<"QRScanEvent"> | Date | string
    scannerIp?: StringNullableWithAggregatesFilter<"QRScanEvent"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"QRScanEvent"> | string | null
    deviceType?: EnumDeviceTypeNullableWithAggregatesFilter<"QRScanEvent"> | $Enums.DeviceType | null
    scanLocation?: StringNullableWithAggregatesFilter<"QRScanEvent"> | string | null
    locationAccuracy?: DecimalNullableWithAggregatesFilter<"QRScanEvent"> | Decimal | DecimalJsLike | number | string | null
    locationName?: StringNullableWithAggregatesFilter<"QRScanEvent"> | string | null
    countryCode?: StringNullableWithAggregatesFilter<"QRScanEvent"> | string | null
    city?: StringNullableWithAggregatesFilter<"QRScanEvent"> | string | null
    scannerContactInfo?: JsonNullableWithAggregatesFilter<"QRScanEvent">
    scanResult?: EnumScanResultWithAggregatesFilter<"QRScanEvent"> | $Enums.ScanResult
    createdAt?: DateTimeWithAggregatesFilter<"QRScanEvent"> | Date | string
  }

  export type PetLocationEventWhereInput = {
    AND?: PetLocationEventWhereInput | PetLocationEventWhereInput[]
    OR?: PetLocationEventWhereInput[]
    NOT?: PetLocationEventWhereInput | PetLocationEventWhereInput[]
    id?: UuidFilter<"PetLocationEvent"> | string
    petId?: UuidFilter<"PetLocationEvent"> | string
    qrScanId?: UuidNullableFilter<"PetLocationEvent"> | string | null
    latitude?: DecimalFilter<"PetLocationEvent"> | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFilter<"PetLocationEvent"> | Decimal | DecimalJsLike | number | string
    accuracy?: DecimalNullableFilter<"PetLocationEvent"> | Decimal | DecimalJsLike | number | string | null
    scannerIp?: StringNullableFilter<"PetLocationEvent"> | string | null
    userAgent?: StringNullableFilter<"PetLocationEvent"> | string | null
    deviceType?: EnumDeviceTypeNullableFilter<"PetLocationEvent"> | $Enums.DeviceType | null
    locationName?: StringNullableFilter<"PetLocationEvent"> | string | null
    countryCode?: StringNullableFilter<"PetLocationEvent"> | string | null
    city?: StringNullableFilter<"PetLocationEvent"> | string | null
    state?: StringNullableFilter<"PetLocationEvent"> | string | null
    scannerContactInfo?: JsonNullableFilter<"PetLocationEvent">
    createdAt?: DateTimeFilter<"PetLocationEvent"> | Date | string
    pet?: XOR<PetScalarRelationFilter, PetWhereInput>
    qrScanEvent?: XOR<QRScanEventNullableScalarRelationFilter, QRScanEventWhereInput> | null
  }

  export type PetLocationEventOrderByWithRelationInput = {
    id?: SortOrder
    petId?: SortOrder
    qrScanId?: SortOrderInput | SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrderInput | SortOrder
    scannerIp?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    locationName?: SortOrderInput | SortOrder
    countryCode?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    scannerContactInfo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    pet?: PetOrderByWithRelationInput
    qrScanEvent?: QRScanEventOrderByWithRelationInput
  }

  export type PetLocationEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PetLocationEventWhereInput | PetLocationEventWhereInput[]
    OR?: PetLocationEventWhereInput[]
    NOT?: PetLocationEventWhereInput | PetLocationEventWhereInput[]
    petId?: UuidFilter<"PetLocationEvent"> | string
    qrScanId?: UuidNullableFilter<"PetLocationEvent"> | string | null
    latitude?: DecimalFilter<"PetLocationEvent"> | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFilter<"PetLocationEvent"> | Decimal | DecimalJsLike | number | string
    accuracy?: DecimalNullableFilter<"PetLocationEvent"> | Decimal | DecimalJsLike | number | string | null
    scannerIp?: StringNullableFilter<"PetLocationEvent"> | string | null
    userAgent?: StringNullableFilter<"PetLocationEvent"> | string | null
    deviceType?: EnumDeviceTypeNullableFilter<"PetLocationEvent"> | $Enums.DeviceType | null
    locationName?: StringNullableFilter<"PetLocationEvent"> | string | null
    countryCode?: StringNullableFilter<"PetLocationEvent"> | string | null
    city?: StringNullableFilter<"PetLocationEvent"> | string | null
    state?: StringNullableFilter<"PetLocationEvent"> | string | null
    scannerContactInfo?: JsonNullableFilter<"PetLocationEvent">
    createdAt?: DateTimeFilter<"PetLocationEvent"> | Date | string
    pet?: XOR<PetScalarRelationFilter, PetWhereInput>
    qrScanEvent?: XOR<QRScanEventNullableScalarRelationFilter, QRScanEventWhereInput> | null
  }, "id">

  export type PetLocationEventOrderByWithAggregationInput = {
    id?: SortOrder
    petId?: SortOrder
    qrScanId?: SortOrderInput | SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrderInput | SortOrder
    scannerIp?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    locationName?: SortOrderInput | SortOrder
    countryCode?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    scannerContactInfo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PetLocationEventCountOrderByAggregateInput
    _avg?: PetLocationEventAvgOrderByAggregateInput
    _max?: PetLocationEventMaxOrderByAggregateInput
    _min?: PetLocationEventMinOrderByAggregateInput
    _sum?: PetLocationEventSumOrderByAggregateInput
  }

  export type PetLocationEventScalarWhereWithAggregatesInput = {
    AND?: PetLocationEventScalarWhereWithAggregatesInput | PetLocationEventScalarWhereWithAggregatesInput[]
    OR?: PetLocationEventScalarWhereWithAggregatesInput[]
    NOT?: PetLocationEventScalarWhereWithAggregatesInput | PetLocationEventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PetLocationEvent"> | string
    petId?: UuidWithAggregatesFilter<"PetLocationEvent"> | string
    qrScanId?: UuidNullableWithAggregatesFilter<"PetLocationEvent"> | string | null
    latitude?: DecimalWithAggregatesFilter<"PetLocationEvent"> | Decimal | DecimalJsLike | number | string
    longitude?: DecimalWithAggregatesFilter<"PetLocationEvent"> | Decimal | DecimalJsLike | number | string
    accuracy?: DecimalNullableWithAggregatesFilter<"PetLocationEvent"> | Decimal | DecimalJsLike | number | string | null
    scannerIp?: StringNullableWithAggregatesFilter<"PetLocationEvent"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"PetLocationEvent"> | string | null
    deviceType?: EnumDeviceTypeNullableWithAggregatesFilter<"PetLocationEvent"> | $Enums.DeviceType | null
    locationName?: StringNullableWithAggregatesFilter<"PetLocationEvent"> | string | null
    countryCode?: StringNullableWithAggregatesFilter<"PetLocationEvent"> | string | null
    city?: StringNullableWithAggregatesFilter<"PetLocationEvent"> | string | null
    state?: StringNullableWithAggregatesFilter<"PetLocationEvent"> | string | null
    scannerContactInfo?: JsonNullableWithAggregatesFilter<"PetLocationEvent">
    createdAt?: DateTimeWithAggregatesFilter<"PetLocationEvent"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: UuidFilter<"Order"> | string
    razorpayOrderId?: StringNullableFilter<"Order"> | string | null
    userId?: UuidFilter<"Order"> | string
    receipt?: StringNullableFilter<"Order"> | string | null
    amountInPaise?: BigIntFilter<"Order"> | bigint | number
    currency?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    notes?: JsonNullableFilter<"Order">
    metadata?: JsonNullableFilter<"Order">
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    rawOrderPayload?: JsonNullableFilter<"Order">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    payments?: PaymentListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    razorpayOrderId?: SortOrderInput | SortOrder
    userId?: SortOrder
    receipt?: SortOrderInput | SortOrder
    amountInPaise?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    rawOrderPayload?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    razorpayOrderId?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    userId?: UuidFilter<"Order"> | string
    receipt?: StringNullableFilter<"Order"> | string | null
    amountInPaise?: BigIntFilter<"Order"> | bigint | number
    currency?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    notes?: JsonNullableFilter<"Order">
    metadata?: JsonNullableFilter<"Order">
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    rawOrderPayload?: JsonNullableFilter<"Order">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    payments?: PaymentListRelationFilter
  }, "id" | "razorpayOrderId">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    razorpayOrderId?: SortOrderInput | SortOrder
    userId?: SortOrder
    receipt?: SortOrderInput | SortOrder
    amountInPaise?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    rawOrderPayload?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Order"> | string
    razorpayOrderId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    userId?: UuidWithAggregatesFilter<"Order"> | string
    receipt?: StringNullableWithAggregatesFilter<"Order"> | string | null
    amountInPaise?: BigIntWithAggregatesFilter<"Order"> | bigint | number
    currency?: StringWithAggregatesFilter<"Order"> | string
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    notes?: JsonNullableWithAggregatesFilter<"Order">
    metadata?: JsonNullableWithAggregatesFilter<"Order">
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    rawOrderPayload?: JsonNullableWithAggregatesFilter<"Order">
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: UuidFilter<"Payment"> | string
    localOrderId?: UuidFilter<"Payment"> | string
    razorpayPaymentId?: StringFilter<"Payment"> | string
    razorpayOrderId?: StringFilter<"Payment"> | string
    amountInPaise?: BigIntFilter<"Payment"> | bigint | number
    currency?: StringFilter<"Payment"> | string
    method?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusNewFilter<"Payment"> | $Enums.PaymentStatusNew
    captured?: BoolFilter<"Payment"> | boolean
    capturedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    bank?: StringNullableFilter<"Payment"> | string | null
    vpa?: StringNullableFilter<"Payment"> | string | null
    card?: JsonNullableFilter<"Payment">
    fee?: BigIntNullableFilter<"Payment"> | bigint | number | null
    tax?: BigIntNullableFilter<"Payment"> | bigint | number | null
    currencyConversion?: JsonNullableFilter<"Payment">
    signatureValid?: BoolNullableFilter<"Payment"> | boolean | null
    signatureVerifiedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    verificationMethod?: EnumVerificationMethodNullableFilter<"Payment"> | $Enums.VerificationMethod | null
    rawPaymentPayload?: JsonNullableFilter<"Payment">
    clientMeta?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    refunds?: RefundListRelationFilter
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    localOrderId?: SortOrder
    razorpayPaymentId?: SortOrder
    razorpayOrderId?: SortOrder
    amountInPaise?: SortOrder
    currency?: SortOrder
    method?: SortOrderInput | SortOrder
    status?: SortOrder
    captured?: SortOrder
    capturedAt?: SortOrderInput | SortOrder
    bank?: SortOrderInput | SortOrder
    vpa?: SortOrderInput | SortOrder
    card?: SortOrderInput | SortOrder
    fee?: SortOrderInput | SortOrder
    tax?: SortOrderInput | SortOrder
    currencyConversion?: SortOrderInput | SortOrder
    signatureValid?: SortOrderInput | SortOrder
    signatureVerifiedAt?: SortOrderInput | SortOrder
    verificationMethod?: SortOrderInput | SortOrder
    rawPaymentPayload?: SortOrderInput | SortOrder
    clientMeta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    refunds?: RefundOrderByRelationAggregateInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    razorpayPaymentId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    localOrderId?: UuidFilter<"Payment"> | string
    razorpayOrderId?: StringFilter<"Payment"> | string
    amountInPaise?: BigIntFilter<"Payment"> | bigint | number
    currency?: StringFilter<"Payment"> | string
    method?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusNewFilter<"Payment"> | $Enums.PaymentStatusNew
    captured?: BoolFilter<"Payment"> | boolean
    capturedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    bank?: StringNullableFilter<"Payment"> | string | null
    vpa?: StringNullableFilter<"Payment"> | string | null
    card?: JsonNullableFilter<"Payment">
    fee?: BigIntNullableFilter<"Payment"> | bigint | number | null
    tax?: BigIntNullableFilter<"Payment"> | bigint | number | null
    currencyConversion?: JsonNullableFilter<"Payment">
    signatureValid?: BoolNullableFilter<"Payment"> | boolean | null
    signatureVerifiedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    verificationMethod?: EnumVerificationMethodNullableFilter<"Payment"> | $Enums.VerificationMethod | null
    rawPaymentPayload?: JsonNullableFilter<"Payment">
    clientMeta?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    refunds?: RefundListRelationFilter
  }, "id" | "razorpayPaymentId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    localOrderId?: SortOrder
    razorpayPaymentId?: SortOrder
    razorpayOrderId?: SortOrder
    amountInPaise?: SortOrder
    currency?: SortOrder
    method?: SortOrderInput | SortOrder
    status?: SortOrder
    captured?: SortOrder
    capturedAt?: SortOrderInput | SortOrder
    bank?: SortOrderInput | SortOrder
    vpa?: SortOrderInput | SortOrder
    card?: SortOrderInput | SortOrder
    fee?: SortOrderInput | SortOrder
    tax?: SortOrderInput | SortOrder
    currencyConversion?: SortOrderInput | SortOrder
    signatureValid?: SortOrderInput | SortOrder
    signatureVerifiedAt?: SortOrderInput | SortOrder
    verificationMethod?: SortOrderInput | SortOrder
    rawPaymentPayload?: SortOrderInput | SortOrder
    clientMeta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Payment"> | string
    localOrderId?: UuidWithAggregatesFilter<"Payment"> | string
    razorpayPaymentId?: StringWithAggregatesFilter<"Payment"> | string
    razorpayOrderId?: StringWithAggregatesFilter<"Payment"> | string
    amountInPaise?: BigIntWithAggregatesFilter<"Payment"> | bigint | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    method?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    status?: EnumPaymentStatusNewWithAggregatesFilter<"Payment"> | $Enums.PaymentStatusNew
    captured?: BoolWithAggregatesFilter<"Payment"> | boolean
    capturedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    bank?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    vpa?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    card?: JsonNullableWithAggregatesFilter<"Payment">
    fee?: BigIntNullableWithAggregatesFilter<"Payment"> | bigint | number | null
    tax?: BigIntNullableWithAggregatesFilter<"Payment"> | bigint | number | null
    currencyConversion?: JsonNullableWithAggregatesFilter<"Payment">
    signatureValid?: BoolNullableWithAggregatesFilter<"Payment"> | boolean | null
    signatureVerifiedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    verificationMethod?: EnumVerificationMethodNullableWithAggregatesFilter<"Payment"> | $Enums.VerificationMethod | null
    rawPaymentPayload?: JsonNullableWithAggregatesFilter<"Payment">
    clientMeta?: JsonNullableWithAggregatesFilter<"Payment">
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type RefundWhereInput = {
    AND?: RefundWhereInput | RefundWhereInput[]
    OR?: RefundWhereInput[]
    NOT?: RefundWhereInput | RefundWhereInput[]
    id?: UuidFilter<"Refund"> | string
    razorpayRefundId?: StringNullableFilter<"Refund"> | string | null
    razorpayPaymentId?: StringFilter<"Refund"> | string
    paymentEventId?: UuidNullableFilter<"Refund"> | string | null
    amountInPaise?: BigIntFilter<"Refund"> | bigint | number
    refundAmount?: DecimalNullableFilter<"Refund"> | Decimal | DecimalJsLike | number | string | null
    reason?: StringNullableFilter<"Refund"> | string | null
    initiatedBy?: UuidNullableFilter<"Refund"> | string | null
    status?: EnumRefundStatusFilter<"Refund"> | $Enums.RefundStatus
    processedAt?: DateTimeNullableFilter<"Refund"> | Date | string | null
    rawRefundPayload?: JsonNullableFilter<"Refund">
    createdAt?: DateTimeFilter<"Refund"> | Date | string
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
    paymentEvent?: XOR<PaymentEventNullableScalarRelationFilter, PaymentEventWhereInput> | null
  }

  export type RefundOrderByWithRelationInput = {
    id?: SortOrder
    razorpayRefundId?: SortOrderInput | SortOrder
    razorpayPaymentId?: SortOrder
    paymentEventId?: SortOrderInput | SortOrder
    amountInPaise?: SortOrder
    refundAmount?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    initiatedBy?: SortOrderInput | SortOrder
    status?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    rawRefundPayload?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    payment?: PaymentOrderByWithRelationInput
    paymentEvent?: PaymentEventOrderByWithRelationInput
  }

  export type RefundWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RefundWhereInput | RefundWhereInput[]
    OR?: RefundWhereInput[]
    NOT?: RefundWhereInput | RefundWhereInput[]
    razorpayRefundId?: StringNullableFilter<"Refund"> | string | null
    razorpayPaymentId?: StringFilter<"Refund"> | string
    paymentEventId?: UuidNullableFilter<"Refund"> | string | null
    amountInPaise?: BigIntFilter<"Refund"> | bigint | number
    refundAmount?: DecimalNullableFilter<"Refund"> | Decimal | DecimalJsLike | number | string | null
    reason?: StringNullableFilter<"Refund"> | string | null
    initiatedBy?: UuidNullableFilter<"Refund"> | string | null
    status?: EnumRefundStatusFilter<"Refund"> | $Enums.RefundStatus
    processedAt?: DateTimeNullableFilter<"Refund"> | Date | string | null
    rawRefundPayload?: JsonNullableFilter<"Refund">
    createdAt?: DateTimeFilter<"Refund"> | Date | string
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
    paymentEvent?: XOR<PaymentEventNullableScalarRelationFilter, PaymentEventWhereInput> | null
  }, "id">

  export type RefundOrderByWithAggregationInput = {
    id?: SortOrder
    razorpayRefundId?: SortOrderInput | SortOrder
    razorpayPaymentId?: SortOrder
    paymentEventId?: SortOrderInput | SortOrder
    amountInPaise?: SortOrder
    refundAmount?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    initiatedBy?: SortOrderInput | SortOrder
    status?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    rawRefundPayload?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RefundCountOrderByAggregateInput
    _avg?: RefundAvgOrderByAggregateInput
    _max?: RefundMaxOrderByAggregateInput
    _min?: RefundMinOrderByAggregateInput
    _sum?: RefundSumOrderByAggregateInput
  }

  export type RefundScalarWhereWithAggregatesInput = {
    AND?: RefundScalarWhereWithAggregatesInput | RefundScalarWhereWithAggregatesInput[]
    OR?: RefundScalarWhereWithAggregatesInput[]
    NOT?: RefundScalarWhereWithAggregatesInput | RefundScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Refund"> | string
    razorpayRefundId?: StringNullableWithAggregatesFilter<"Refund"> | string | null
    razorpayPaymentId?: StringWithAggregatesFilter<"Refund"> | string
    paymentEventId?: UuidNullableWithAggregatesFilter<"Refund"> | string | null
    amountInPaise?: BigIntWithAggregatesFilter<"Refund"> | bigint | number
    refundAmount?: DecimalNullableWithAggregatesFilter<"Refund"> | Decimal | DecimalJsLike | number | string | null
    reason?: StringNullableWithAggregatesFilter<"Refund"> | string | null
    initiatedBy?: UuidNullableWithAggregatesFilter<"Refund"> | string | null
    status?: EnumRefundStatusWithAggregatesFilter<"Refund"> | $Enums.RefundStatus
    processedAt?: DateTimeNullableWithAggregatesFilter<"Refund"> | Date | string | null
    rawRefundPayload?: JsonNullableWithAggregatesFilter<"Refund">
    createdAt?: DateTimeWithAggregatesFilter<"Refund"> | Date | string
  }

  export type WebhookEventWhereInput = {
    AND?: WebhookEventWhereInput | WebhookEventWhereInput[]
    OR?: WebhookEventWhereInput[]
    NOT?: WebhookEventWhereInput | WebhookEventWhereInput[]
    id?: UuidFilter<"WebhookEvent"> | string
    razorpayEventId?: StringNullableFilter<"WebhookEvent"> | string | null
    eventType?: StringFilter<"WebhookEvent"> | string
    rawEvent?: JsonFilter<"WebhookEvent">
    headers?: JsonNullableFilter<"WebhookEvent">
    signatureValid?: BoolFilter<"WebhookEvent"> | boolean
    receivedAt?: DateTimeFilter<"WebhookEvent"> | Date | string
    processedAt?: DateTimeNullableFilter<"WebhookEvent"> | Date | string | null
    processingResult?: JsonNullableFilter<"WebhookEvent">
  }

  export type WebhookEventOrderByWithRelationInput = {
    id?: SortOrder
    razorpayEventId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    rawEvent?: SortOrder
    headers?: SortOrderInput | SortOrder
    signatureValid?: SortOrder
    receivedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    processingResult?: SortOrderInput | SortOrder
  }

  export type WebhookEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    razorpayEventId?: string
    AND?: WebhookEventWhereInput | WebhookEventWhereInput[]
    OR?: WebhookEventWhereInput[]
    NOT?: WebhookEventWhereInput | WebhookEventWhereInput[]
    eventType?: StringFilter<"WebhookEvent"> | string
    rawEvent?: JsonFilter<"WebhookEvent">
    headers?: JsonNullableFilter<"WebhookEvent">
    signatureValid?: BoolFilter<"WebhookEvent"> | boolean
    receivedAt?: DateTimeFilter<"WebhookEvent"> | Date | string
    processedAt?: DateTimeNullableFilter<"WebhookEvent"> | Date | string | null
    processingResult?: JsonNullableFilter<"WebhookEvent">
  }, "id" | "razorpayEventId">

  export type WebhookEventOrderByWithAggregationInput = {
    id?: SortOrder
    razorpayEventId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    rawEvent?: SortOrder
    headers?: SortOrderInput | SortOrder
    signatureValid?: SortOrder
    receivedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    processingResult?: SortOrderInput | SortOrder
    _count?: WebhookEventCountOrderByAggregateInput
    _max?: WebhookEventMaxOrderByAggregateInput
    _min?: WebhookEventMinOrderByAggregateInput
  }

  export type WebhookEventScalarWhereWithAggregatesInput = {
    AND?: WebhookEventScalarWhereWithAggregatesInput | WebhookEventScalarWhereWithAggregatesInput[]
    OR?: WebhookEventScalarWhereWithAggregatesInput[]
    NOT?: WebhookEventScalarWhereWithAggregatesInput | WebhookEventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"WebhookEvent"> | string
    razorpayEventId?: StringNullableWithAggregatesFilter<"WebhookEvent"> | string | null
    eventType?: StringWithAggregatesFilter<"WebhookEvent"> | string
    rawEvent?: JsonWithAggregatesFilter<"WebhookEvent">
    headers?: JsonNullableWithAggregatesFilter<"WebhookEvent">
    signatureValid?: BoolWithAggregatesFilter<"WebhookEvent"> | boolean
    receivedAt?: DateTimeWithAggregatesFilter<"WebhookEvent"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"WebhookEvent"> | Date | string | null
    processingResult?: JsonNullableWithAggregatesFilter<"WebhookEvent">
  }

  export type PaymentWebhookWhereInput = {
    AND?: PaymentWebhookWhereInput | PaymentWebhookWhereInput[]
    OR?: PaymentWebhookWhereInput[]
    NOT?: PaymentWebhookWhereInput | PaymentWebhookWhereInput[]
    id?: UuidFilter<"PaymentWebhook"> | string
    eventId?: StringNullableFilter<"PaymentWebhook"> | string | null
    eventType?: StringFilter<"PaymentWebhook"> | string
    entityType?: StringFilter<"PaymentWebhook"> | string
    entityId?: StringFilter<"PaymentWebhook"> | string
    payload?: JsonFilter<"PaymentWebhook">
    signature?: StringFilter<"PaymentWebhook"> | string
    signatureVerified?: BoolFilter<"PaymentWebhook"> | boolean
    processed?: BoolFilter<"PaymentWebhook"> | boolean
    processedAt?: DateTimeNullableFilter<"PaymentWebhook"> | Date | string | null
    processingAttempts?: IntFilter<"PaymentWebhook"> | number
    createdAt?: DateTimeFilter<"PaymentWebhook"> | Date | string
  }

  export type PaymentWebhookOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    payload?: SortOrder
    signature?: SortOrder
    signatureVerified?: SortOrder
    processed?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    processingAttempts?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentWebhookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWebhookWhereInput | PaymentWebhookWhereInput[]
    OR?: PaymentWebhookWhereInput[]
    NOT?: PaymentWebhookWhereInput | PaymentWebhookWhereInput[]
    eventId?: StringNullableFilter<"PaymentWebhook"> | string | null
    eventType?: StringFilter<"PaymentWebhook"> | string
    entityType?: StringFilter<"PaymentWebhook"> | string
    entityId?: StringFilter<"PaymentWebhook"> | string
    payload?: JsonFilter<"PaymentWebhook">
    signature?: StringFilter<"PaymentWebhook"> | string
    signatureVerified?: BoolFilter<"PaymentWebhook"> | boolean
    processed?: BoolFilter<"PaymentWebhook"> | boolean
    processedAt?: DateTimeNullableFilter<"PaymentWebhook"> | Date | string | null
    processingAttempts?: IntFilter<"PaymentWebhook"> | number
    createdAt?: DateTimeFilter<"PaymentWebhook"> | Date | string
  }, "id">

  export type PaymentWebhookOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    payload?: SortOrder
    signature?: SortOrder
    signatureVerified?: SortOrder
    processed?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    processingAttempts?: SortOrder
    createdAt?: SortOrder
    _count?: PaymentWebhookCountOrderByAggregateInput
    _avg?: PaymentWebhookAvgOrderByAggregateInput
    _max?: PaymentWebhookMaxOrderByAggregateInput
    _min?: PaymentWebhookMinOrderByAggregateInput
    _sum?: PaymentWebhookSumOrderByAggregateInput
  }

  export type PaymentWebhookScalarWhereWithAggregatesInput = {
    AND?: PaymentWebhookScalarWhereWithAggregatesInput | PaymentWebhookScalarWhereWithAggregatesInput[]
    OR?: PaymentWebhookScalarWhereWithAggregatesInput[]
    NOT?: PaymentWebhookScalarWhereWithAggregatesInput | PaymentWebhookScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PaymentWebhook"> | string
    eventId?: StringNullableWithAggregatesFilter<"PaymentWebhook"> | string | null
    eventType?: StringWithAggregatesFilter<"PaymentWebhook"> | string
    entityType?: StringWithAggregatesFilter<"PaymentWebhook"> | string
    entityId?: StringWithAggregatesFilter<"PaymentWebhook"> | string
    payload?: JsonWithAggregatesFilter<"PaymentWebhook">
    signature?: StringWithAggregatesFilter<"PaymentWebhook"> | string
    signatureVerified?: BoolWithAggregatesFilter<"PaymentWebhook"> | boolean
    processed?: BoolWithAggregatesFilter<"PaymentWebhook"> | boolean
    processedAt?: DateTimeNullableWithAggregatesFilter<"PaymentWebhook"> | Date | string | null
    processingAttempts?: IntWithAggregatesFilter<"PaymentWebhook"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PaymentWebhook"> | Date | string
  }

  export type PaymentEventWhereInput = {
    AND?: PaymentEventWhereInput | PaymentEventWhereInput[]
    OR?: PaymentEventWhereInput[]
    NOT?: PaymentEventWhereInput | PaymentEventWhereInput[]
    id?: UuidFilter<"PaymentEvent"> | string
    userId?: UuidNullableFilter<"PaymentEvent"> | string | null
    petId?: UuidNullableFilter<"PaymentEvent"> | string | null
    qrId?: UuidNullableFilter<"PaymentEvent"> | string | null
    amount?: DecimalFilter<"PaymentEvent"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"PaymentEvent"> | string
    paymentPurpose?: EnumPaymentPurposeFilter<"PaymentEvent"> | $Enums.PaymentPurpose
    status?: EnumPaymentStatusFilter<"PaymentEvent"> | $Enums.PaymentStatus
    razorpayOrderId?: StringNullableFilter<"PaymentEvent"> | string | null
    razorpayPaymentId?: StringNullableFilter<"PaymentEvent"> | string | null
    razorpaySignature?: StringNullableFilter<"PaymentEvent"> | string | null
    paymentMethod?: StringNullableFilter<"PaymentEvent"> | string | null
    failureReason?: StringNullableFilter<"PaymentEvent"> | string | null
    createdAt?: DateTimeFilter<"PaymentEvent"> | Date | string
    completedAt?: DateTimeNullableFilter<"PaymentEvent"> | Date | string | null
    pet?: XOR<PetNullableScalarRelationFilter, PetWhereInput> | null
    qrCode?: XOR<QRCodeNullableScalarRelationFilter, QRCodeWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    refunds?: RefundListRelationFilter
  }

  export type PaymentEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    petId?: SortOrderInput | SortOrder
    qrId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentPurpose?: SortOrder
    status?: SortOrder
    razorpayOrderId?: SortOrderInput | SortOrder
    razorpayPaymentId?: SortOrderInput | SortOrder
    razorpaySignature?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    pet?: PetOrderByWithRelationInput
    qrCode?: QRCodeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    refunds?: RefundOrderByRelationAggregateInput
  }

  export type PaymentEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentEventWhereInput | PaymentEventWhereInput[]
    OR?: PaymentEventWhereInput[]
    NOT?: PaymentEventWhereInput | PaymentEventWhereInput[]
    userId?: UuidNullableFilter<"PaymentEvent"> | string | null
    petId?: UuidNullableFilter<"PaymentEvent"> | string | null
    qrId?: UuidNullableFilter<"PaymentEvent"> | string | null
    amount?: DecimalFilter<"PaymentEvent"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"PaymentEvent"> | string
    paymentPurpose?: EnumPaymentPurposeFilter<"PaymentEvent"> | $Enums.PaymentPurpose
    status?: EnumPaymentStatusFilter<"PaymentEvent"> | $Enums.PaymentStatus
    razorpayOrderId?: StringNullableFilter<"PaymentEvent"> | string | null
    razorpayPaymentId?: StringNullableFilter<"PaymentEvent"> | string | null
    razorpaySignature?: StringNullableFilter<"PaymentEvent"> | string | null
    paymentMethod?: StringNullableFilter<"PaymentEvent"> | string | null
    failureReason?: StringNullableFilter<"PaymentEvent"> | string | null
    createdAt?: DateTimeFilter<"PaymentEvent"> | Date | string
    completedAt?: DateTimeNullableFilter<"PaymentEvent"> | Date | string | null
    pet?: XOR<PetNullableScalarRelationFilter, PetWhereInput> | null
    qrCode?: XOR<QRCodeNullableScalarRelationFilter, QRCodeWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    refunds?: RefundListRelationFilter
  }, "id">

  export type PaymentEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    petId?: SortOrderInput | SortOrder
    qrId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentPurpose?: SortOrder
    status?: SortOrder
    razorpayOrderId?: SortOrderInput | SortOrder
    razorpayPaymentId?: SortOrderInput | SortOrder
    razorpaySignature?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: PaymentEventCountOrderByAggregateInput
    _avg?: PaymentEventAvgOrderByAggregateInput
    _max?: PaymentEventMaxOrderByAggregateInput
    _min?: PaymentEventMinOrderByAggregateInput
    _sum?: PaymentEventSumOrderByAggregateInput
  }

  export type PaymentEventScalarWhereWithAggregatesInput = {
    AND?: PaymentEventScalarWhereWithAggregatesInput | PaymentEventScalarWhereWithAggregatesInput[]
    OR?: PaymentEventScalarWhereWithAggregatesInput[]
    NOT?: PaymentEventScalarWhereWithAggregatesInput | PaymentEventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PaymentEvent"> | string
    userId?: UuidNullableWithAggregatesFilter<"PaymentEvent"> | string | null
    petId?: UuidNullableWithAggregatesFilter<"PaymentEvent"> | string | null
    qrId?: UuidNullableWithAggregatesFilter<"PaymentEvent"> | string | null
    amount?: DecimalWithAggregatesFilter<"PaymentEvent"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"PaymentEvent"> | string
    paymentPurpose?: EnumPaymentPurposeWithAggregatesFilter<"PaymentEvent"> | $Enums.PaymentPurpose
    status?: EnumPaymentStatusWithAggregatesFilter<"PaymentEvent"> | $Enums.PaymentStatus
    razorpayOrderId?: StringNullableWithAggregatesFilter<"PaymentEvent"> | string | null
    razorpayPaymentId?: StringNullableWithAggregatesFilter<"PaymentEvent"> | string | null
    razorpaySignature?: StringNullableWithAggregatesFilter<"PaymentEvent"> | string | null
    paymentMethod?: StringNullableWithAggregatesFilter<"PaymentEvent"> | string | null
    failureReason?: StringNullableWithAggregatesFilter<"PaymentEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PaymentEvent"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"PaymentEvent"> | Date | string | null
  }

  export type LocationTrackWhereInput = {
    AND?: LocationTrackWhereInput | LocationTrackWhereInput[]
    OR?: LocationTrackWhereInput[]
    NOT?: LocationTrackWhereInput | LocationTrackWhereInput[]
    id?: UuidFilter<"LocationTrack"> | string
    userId?: UuidNullableFilter<"LocationTrack"> | string | null
    locationType?: EnumLocationTypeFilter<"LocationTrack"> | $Enums.LocationType
    position?: StringNullableFilter<"LocationTrack"> | string | null
    accuracy?: DecimalNullableFilter<"LocationTrack"> | Decimal | DecimalJsLike | number | string | null
    locationName?: StringNullableFilter<"LocationTrack"> | string | null
    countryCode?: StringNullableFilter<"LocationTrack"> | string | null
    state?: StringNullableFilter<"LocationTrack"> | string | null
    city?: StringNullableFilter<"LocationTrack"> | string | null
    ipAddress?: StringNullableFilter<"LocationTrack"> | string | null
    deviceInfo?: JsonNullableFilter<"LocationTrack">
    timestamp?: DateTimeFilter<"LocationTrack"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type LocationTrackOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    locationType?: SortOrder
    position?: SortOrderInput | SortOrder
    accuracy?: SortOrderInput | SortOrder
    locationName?: SortOrderInput | SortOrder
    countryCode?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LocationTrackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationTrackWhereInput | LocationTrackWhereInput[]
    OR?: LocationTrackWhereInput[]
    NOT?: LocationTrackWhereInput | LocationTrackWhereInput[]
    userId?: UuidNullableFilter<"LocationTrack"> | string | null
    locationType?: EnumLocationTypeFilter<"LocationTrack"> | $Enums.LocationType
    position?: StringNullableFilter<"LocationTrack"> | string | null
    accuracy?: DecimalNullableFilter<"LocationTrack"> | Decimal | DecimalJsLike | number | string | null
    locationName?: StringNullableFilter<"LocationTrack"> | string | null
    countryCode?: StringNullableFilter<"LocationTrack"> | string | null
    state?: StringNullableFilter<"LocationTrack"> | string | null
    city?: StringNullableFilter<"LocationTrack"> | string | null
    ipAddress?: StringNullableFilter<"LocationTrack"> | string | null
    deviceInfo?: JsonNullableFilter<"LocationTrack">
    timestamp?: DateTimeFilter<"LocationTrack"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type LocationTrackOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    locationType?: SortOrder
    position?: SortOrderInput | SortOrder
    accuracy?: SortOrderInput | SortOrder
    locationName?: SortOrderInput | SortOrder
    countryCode?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: LocationTrackCountOrderByAggregateInput
    _avg?: LocationTrackAvgOrderByAggregateInput
    _max?: LocationTrackMaxOrderByAggregateInput
    _min?: LocationTrackMinOrderByAggregateInput
    _sum?: LocationTrackSumOrderByAggregateInput
  }

  export type LocationTrackScalarWhereWithAggregatesInput = {
    AND?: LocationTrackScalarWhereWithAggregatesInput | LocationTrackScalarWhereWithAggregatesInput[]
    OR?: LocationTrackScalarWhereWithAggregatesInput[]
    NOT?: LocationTrackScalarWhereWithAggregatesInput | LocationTrackScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"LocationTrack"> | string
    userId?: UuidNullableWithAggregatesFilter<"LocationTrack"> | string | null
    locationType?: EnumLocationTypeWithAggregatesFilter<"LocationTrack"> | $Enums.LocationType
    position?: StringNullableWithAggregatesFilter<"LocationTrack"> | string | null
    accuracy?: DecimalNullableWithAggregatesFilter<"LocationTrack"> | Decimal | DecimalJsLike | number | string | null
    locationName?: StringNullableWithAggregatesFilter<"LocationTrack"> | string | null
    countryCode?: StringNullableWithAggregatesFilter<"LocationTrack"> | string | null
    state?: StringNullableWithAggregatesFilter<"LocationTrack"> | string | null
    city?: StringNullableWithAggregatesFilter<"LocationTrack"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"LocationTrack"> | string | null
    deviceInfo?: JsonNullableWithAggregatesFilter<"LocationTrack">
    timestamp?: DateTimeWithAggregatesFilter<"LocationTrack"> | Date | string
  }

  export type NotificationPreferenceWhereInput = {
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    userId?: UuidFilter<"NotificationPreference"> | string
    pushEnabled?: BoolFilter<"NotificationPreference"> | boolean
    emailEnabled?: BoolFilter<"NotificationPreference"> | boolean
    smsEnabled?: BoolFilter<"NotificationPreference"> | boolean
    scanNotifications?: BoolFilter<"NotificationPreference"> | boolean
    marketingNotifications?: BoolFilter<"NotificationPreference"> | boolean
    quietHoursStart?: DateTimeNullableFilter<"NotificationPreference"> | Date | string | null
    quietHoursEnd?: DateTimeNullableFilter<"NotificationPreference"> | Date | string | null
    timezone?: StringFilter<"NotificationPreference"> | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationPreferenceOrderByWithRelationInput = {
    userId?: SortOrder
    pushEnabled?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    scanNotifications?: SortOrder
    marketingNotifications?: SortOrder
    quietHoursStart?: SortOrderInput | SortOrder
    quietHoursEnd?: SortOrderInput | SortOrder
    timezone?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationPreferenceWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    pushEnabled?: BoolFilter<"NotificationPreference"> | boolean
    emailEnabled?: BoolFilter<"NotificationPreference"> | boolean
    smsEnabled?: BoolFilter<"NotificationPreference"> | boolean
    scanNotifications?: BoolFilter<"NotificationPreference"> | boolean
    marketingNotifications?: BoolFilter<"NotificationPreference"> | boolean
    quietHoursStart?: DateTimeNullableFilter<"NotificationPreference"> | Date | string | null
    quietHoursEnd?: DateTimeNullableFilter<"NotificationPreference"> | Date | string | null
    timezone?: StringFilter<"NotificationPreference"> | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId">

  export type NotificationPreferenceOrderByWithAggregationInput = {
    userId?: SortOrder
    pushEnabled?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    scanNotifications?: SortOrder
    marketingNotifications?: SortOrder
    quietHoursStart?: SortOrderInput | SortOrder
    quietHoursEnd?: SortOrderInput | SortOrder
    timezone?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationPreferenceCountOrderByAggregateInput
    _max?: NotificationPreferenceMaxOrderByAggregateInput
    _min?: NotificationPreferenceMinOrderByAggregateInput
  }

  export type NotificationPreferenceScalarWhereWithAggregatesInput = {
    AND?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    OR?: NotificationPreferenceScalarWhereWithAggregatesInput[]
    NOT?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    userId?: UuidWithAggregatesFilter<"NotificationPreference"> | string
    pushEnabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    emailEnabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    smsEnabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    scanNotifications?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    marketingNotifications?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    quietHoursStart?: DateTimeNullableWithAggregatesFilter<"NotificationPreference"> | Date | string | null
    quietHoursEnd?: DateTimeNullableWithAggregatesFilter<"NotificationPreference"> | Date | string | null
    timezone?: StringWithAggregatesFilter<"NotificationPreference"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: UuidFilter<"Notification"> | string
    userId?: UuidNullableFilter<"Notification"> | string | null
    petId?: UuidNullableFilter<"Notification"> | string | null
    qrScanId?: UuidNullableFilter<"Notification"> | string | null
    notificationType?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    channels?: StringNullableListFilter<"Notification">
    deliveryStatus?: JsonNullableFilter<"Notification">
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    pet?: XOR<PetNullableScalarRelationFilter, PetWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    petId?: SortOrderInput | SortOrder
    qrScanId?: SortOrderInput | SortOrder
    notificationType?: SortOrder
    title?: SortOrder
    message?: SortOrder
    channels?: SortOrder
    deliveryStatus?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    pet?: PetOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: UuidNullableFilter<"Notification"> | string | null
    petId?: UuidNullableFilter<"Notification"> | string | null
    qrScanId?: UuidNullableFilter<"Notification"> | string | null
    notificationType?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    channels?: StringNullableListFilter<"Notification">
    deliveryStatus?: JsonNullableFilter<"Notification">
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    pet?: XOR<PetNullableScalarRelationFilter, PetWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    petId?: SortOrderInput | SortOrder
    qrScanId?: SortOrderInput | SortOrder
    notificationType?: SortOrder
    title?: SortOrder
    message?: SortOrder
    channels?: SortOrder
    deliveryStatus?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Notification"> | string
    userId?: UuidNullableWithAggregatesFilter<"Notification"> | string | null
    petId?: UuidNullableWithAggregatesFilter<"Notification"> | string | null
    qrScanId?: UuidNullableWithAggregatesFilter<"Notification"> | string | null
    notificationType?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    channels?: StringNullableListFilter<"Notification">
    deliveryStatus?: JsonNullableWithAggregatesFilter<"Notification">
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    sentAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
  }

  export type DeviceTokenWhereInput = {
    AND?: DeviceTokenWhereInput | DeviceTokenWhereInput[]
    OR?: DeviceTokenWhereInput[]
    NOT?: DeviceTokenWhereInput | DeviceTokenWhereInput[]
    id?: UuidFilter<"DeviceToken"> | string
    userId?: UuidFilter<"DeviceToken"> | string
    deviceToken?: StringFilter<"DeviceToken"> | string
    platform?: EnumPlatformFilter<"DeviceToken"> | $Enums.Platform
    deviceInfo?: JsonNullableFilter<"DeviceToken">
    isActive?: BoolFilter<"DeviceToken"> | boolean
    createdAt?: DateTimeFilter<"DeviceToken"> | Date | string
    lastUsedAt?: DateTimeFilter<"DeviceToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DeviceTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceToken?: SortOrder
    platform?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DeviceTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeviceTokenWhereInput | DeviceTokenWhereInput[]
    OR?: DeviceTokenWhereInput[]
    NOT?: DeviceTokenWhereInput | DeviceTokenWhereInput[]
    userId?: UuidFilter<"DeviceToken"> | string
    deviceToken?: StringFilter<"DeviceToken"> | string
    platform?: EnumPlatformFilter<"DeviceToken"> | $Enums.Platform
    deviceInfo?: JsonNullableFilter<"DeviceToken">
    isActive?: BoolFilter<"DeviceToken"> | boolean
    createdAt?: DateTimeFilter<"DeviceToken"> | Date | string
    lastUsedAt?: DateTimeFilter<"DeviceToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DeviceTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceToken?: SortOrder
    platform?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
    _count?: DeviceTokenCountOrderByAggregateInput
    _max?: DeviceTokenMaxOrderByAggregateInput
    _min?: DeviceTokenMinOrderByAggregateInput
  }

  export type DeviceTokenScalarWhereWithAggregatesInput = {
    AND?: DeviceTokenScalarWhereWithAggregatesInput | DeviceTokenScalarWhereWithAggregatesInput[]
    OR?: DeviceTokenScalarWhereWithAggregatesInput[]
    NOT?: DeviceTokenScalarWhereWithAggregatesInput | DeviceTokenScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"DeviceToken"> | string
    userId?: UuidWithAggregatesFilter<"DeviceToken"> | string
    deviceToken?: StringWithAggregatesFilter<"DeviceToken"> | string
    platform?: EnumPlatformWithAggregatesFilter<"DeviceToken"> | $Enums.Platform
    deviceInfo?: JsonNullableWithAggregatesFilter<"DeviceToken">
    isActive?: BoolWithAggregatesFilter<"DeviceToken"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DeviceToken"> | Date | string
    lastUsedAt?: DateTimeWithAggregatesFilter<"DeviceToken"> | Date | string
  }

  export type SupportTicketWhereInput = {
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    id?: UuidFilter<"SupportTicket"> | string
    ticketNumber?: StringFilter<"SupportTicket"> | string
    userId?: UuidNullableFilter<"SupportTicket"> | string | null
    petId?: UuidNullableFilter<"SupportTicket"> | string | null
    subject?: StringFilter<"SupportTicket"> | string
    description?: StringFilter<"SupportTicket"> | string
    category?: EnumTicketCategoryFilter<"SupportTicket"> | $Enums.TicketCategory
    priority?: EnumTicketPriorityFilter<"SupportTicket"> | $Enums.TicketPriority
    status?: EnumTicketStatusFilter<"SupportTicket"> | $Enums.TicketStatus
    assignedTo?: UuidNullableFilter<"SupportTicket"> | string | null
    resolution?: StringNullableFilter<"SupportTicket"> | string | null
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    messages?: SupportMessageListRelationFilter
    assignedToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    pet?: XOR<PetNullableScalarRelationFilter, PetWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type SupportTicketOrderByWithRelationInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    userId?: SortOrderInput | SortOrder
    petId?: SortOrderInput | SortOrder
    subject?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    messages?: SupportMessageOrderByRelationAggregateInput
    assignedToUser?: UserOrderByWithRelationInput
    pet?: PetOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type SupportTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ticketNumber?: string
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    userId?: UuidNullableFilter<"SupportTicket"> | string | null
    petId?: UuidNullableFilter<"SupportTicket"> | string | null
    subject?: StringFilter<"SupportTicket"> | string
    description?: StringFilter<"SupportTicket"> | string
    category?: EnumTicketCategoryFilter<"SupportTicket"> | $Enums.TicketCategory
    priority?: EnumTicketPriorityFilter<"SupportTicket"> | $Enums.TicketPriority
    status?: EnumTicketStatusFilter<"SupportTicket"> | $Enums.TicketStatus
    assignedTo?: UuidNullableFilter<"SupportTicket"> | string | null
    resolution?: StringNullableFilter<"SupportTicket"> | string | null
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    messages?: SupportMessageListRelationFilter
    assignedToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    pet?: XOR<PetNullableScalarRelationFilter, PetWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "ticketNumber">

  export type SupportTicketOrderByWithAggregationInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    userId?: SortOrderInput | SortOrder
    petId?: SortOrderInput | SortOrder
    subject?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    _count?: SupportTicketCountOrderByAggregateInput
    _max?: SupportTicketMaxOrderByAggregateInput
    _min?: SupportTicketMinOrderByAggregateInput
  }

  export type SupportTicketScalarWhereWithAggregatesInput = {
    AND?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    OR?: SupportTicketScalarWhereWithAggregatesInput[]
    NOT?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SupportTicket"> | string
    ticketNumber?: StringWithAggregatesFilter<"SupportTicket"> | string
    userId?: UuidNullableWithAggregatesFilter<"SupportTicket"> | string | null
    petId?: UuidNullableWithAggregatesFilter<"SupportTicket"> | string | null
    subject?: StringWithAggregatesFilter<"SupportTicket"> | string
    description?: StringWithAggregatesFilter<"SupportTicket"> | string
    category?: EnumTicketCategoryWithAggregatesFilter<"SupportTicket"> | $Enums.TicketCategory
    priority?: EnumTicketPriorityWithAggregatesFilter<"SupportTicket"> | $Enums.TicketPriority
    status?: EnumTicketStatusWithAggregatesFilter<"SupportTicket"> | $Enums.TicketStatus
    assignedTo?: UuidNullableWithAggregatesFilter<"SupportTicket"> | string | null
    resolution?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"SupportTicket"> | Date | string | null
  }

  export type SupportMessageWhereInput = {
    AND?: SupportMessageWhereInput | SupportMessageWhereInput[]
    OR?: SupportMessageWhereInput[]
    NOT?: SupportMessageWhereInput | SupportMessageWhereInput[]
    id?: UuidFilter<"SupportMessage"> | string
    ticketId?: UuidFilter<"SupportMessage"> | string
    senderId?: UuidNullableFilter<"SupportMessage"> | string | null
    senderType?: EnumSenderTypeFilter<"SupportMessage"> | $Enums.SenderType
    message?: StringFilter<"SupportMessage"> | string
    attachments?: StringNullableListFilter<"SupportMessage">
    isInternal?: BoolFilter<"SupportMessage"> | boolean
    createdAt?: DateTimeFilter<"SupportMessage"> | Date | string
    sender?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    ticket?: XOR<SupportTicketScalarRelationFilter, SupportTicketWhereInput>
  }

  export type SupportMessageOrderByWithRelationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    senderId?: SortOrderInput | SortOrder
    senderType?: SortOrder
    message?: SortOrder
    attachments?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    sender?: UserOrderByWithRelationInput
    ticket?: SupportTicketOrderByWithRelationInput
  }

  export type SupportMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupportMessageWhereInput | SupportMessageWhereInput[]
    OR?: SupportMessageWhereInput[]
    NOT?: SupportMessageWhereInput | SupportMessageWhereInput[]
    ticketId?: UuidFilter<"SupportMessage"> | string
    senderId?: UuidNullableFilter<"SupportMessage"> | string | null
    senderType?: EnumSenderTypeFilter<"SupportMessage"> | $Enums.SenderType
    message?: StringFilter<"SupportMessage"> | string
    attachments?: StringNullableListFilter<"SupportMessage">
    isInternal?: BoolFilter<"SupportMessage"> | boolean
    createdAt?: DateTimeFilter<"SupportMessage"> | Date | string
    sender?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    ticket?: XOR<SupportTicketScalarRelationFilter, SupportTicketWhereInput>
  }, "id">

  export type SupportMessageOrderByWithAggregationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    senderId?: SortOrderInput | SortOrder
    senderType?: SortOrder
    message?: SortOrder
    attachments?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    _count?: SupportMessageCountOrderByAggregateInput
    _max?: SupportMessageMaxOrderByAggregateInput
    _min?: SupportMessageMinOrderByAggregateInput
  }

  export type SupportMessageScalarWhereWithAggregatesInput = {
    AND?: SupportMessageScalarWhereWithAggregatesInput | SupportMessageScalarWhereWithAggregatesInput[]
    OR?: SupportMessageScalarWhereWithAggregatesInput[]
    NOT?: SupportMessageScalarWhereWithAggregatesInput | SupportMessageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SupportMessage"> | string
    ticketId?: UuidWithAggregatesFilter<"SupportMessage"> | string
    senderId?: UuidNullableWithAggregatesFilter<"SupportMessage"> | string | null
    senderType?: EnumSenderTypeWithAggregatesFilter<"SupportMessage"> | $Enums.SenderType
    message?: StringWithAggregatesFilter<"SupportMessage"> | string
    attachments?: StringNullableListFilter<"SupportMessage">
    isInternal?: BoolWithAggregatesFilter<"SupportMessage"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SupportMessage"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    tableName?: StringFilter<"AuditLog"> | string
    recordId?: UuidFilter<"AuditLog"> | string
    operationType?: EnumOperationTypeFilter<"AuditLog"> | $Enums.OperationType
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    changedColumns?: StringNullableListFilter<"AuditLog">
    userId?: UuidNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    operationType?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    changedColumns?: SortOrder
    userId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    tableName?: StringFilter<"AuditLog"> | string
    recordId?: UuidFilter<"AuditLog"> | string
    operationType?: EnumOperationTypeFilter<"AuditLog"> | $Enums.OperationType
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    changedColumns?: StringNullableListFilter<"AuditLog">
    userId?: UuidNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    operationType?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    changedColumns?: SortOrder
    userId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AuditLog"> | string
    tableName?: StringWithAggregatesFilter<"AuditLog"> | string
    recordId?: UuidWithAggregatesFilter<"AuditLog"> | string
    operationType?: EnumOperationTypeWithAggregatesFilter<"AuditLog"> | $Enums.OperationType
    oldValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    newValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    changedColumns?: StringNullableListFilter<"AuditLog">
    userId?: UuidNullableWithAggregatesFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type SystemAnalyticsWhereInput = {
    AND?: SystemAnalyticsWhereInput | SystemAnalyticsWhereInput[]
    OR?: SystemAnalyticsWhereInput[]
    NOT?: SystemAnalyticsWhereInput | SystemAnalyticsWhereInput[]
    id?: UuidFilter<"SystemAnalytics"> | string
    metricName?: StringFilter<"SystemAnalytics"> | string
    metricValue?: DecimalNullableFilter<"SystemAnalytics"> | Decimal | DecimalJsLike | number | string | null
    metricUnit?: StringNullableFilter<"SystemAnalytics"> | string | null
    dimensions?: JsonNullableFilter<"SystemAnalytics">
    timestamp?: DateTimeFilter<"SystemAnalytics"> | Date | string
  }

  export type SystemAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrderInput | SortOrder
    metricUnit?: SortOrderInput | SortOrder
    dimensions?: SortOrderInput | SortOrder
    timestamp?: SortOrder
  }

  export type SystemAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemAnalyticsWhereInput | SystemAnalyticsWhereInput[]
    OR?: SystemAnalyticsWhereInput[]
    NOT?: SystemAnalyticsWhereInput | SystemAnalyticsWhereInput[]
    metricName?: StringFilter<"SystemAnalytics"> | string
    metricValue?: DecimalNullableFilter<"SystemAnalytics"> | Decimal | DecimalJsLike | number | string | null
    metricUnit?: StringNullableFilter<"SystemAnalytics"> | string | null
    dimensions?: JsonNullableFilter<"SystemAnalytics">
    timestamp?: DateTimeFilter<"SystemAnalytics"> | Date | string
  }, "id">

  export type SystemAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrderInput | SortOrder
    metricUnit?: SortOrderInput | SortOrder
    dimensions?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: SystemAnalyticsCountOrderByAggregateInput
    _avg?: SystemAnalyticsAvgOrderByAggregateInput
    _max?: SystemAnalyticsMaxOrderByAggregateInput
    _min?: SystemAnalyticsMinOrderByAggregateInput
    _sum?: SystemAnalyticsSumOrderByAggregateInput
  }

  export type SystemAnalyticsScalarWhereWithAggregatesInput = {
    AND?: SystemAnalyticsScalarWhereWithAggregatesInput | SystemAnalyticsScalarWhereWithAggregatesInput[]
    OR?: SystemAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: SystemAnalyticsScalarWhereWithAggregatesInput | SystemAnalyticsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SystemAnalytics"> | string
    metricName?: StringWithAggregatesFilter<"SystemAnalytics"> | string
    metricValue?: DecimalNullableWithAggregatesFilter<"SystemAnalytics"> | Decimal | DecimalJsLike | number | string | null
    metricUnit?: StringNullableWithAggregatesFilter<"SystemAnalytics"> | string | null
    dimensions?: JsonNullableWithAggregatesFilter<"SystemAnalytics">
    timestamp?: DateTimeWithAggregatesFilter<"SystemAnalytics"> | Date | string
  }

  export type PetRegistrationApplicationWhereInput = {
    AND?: PetRegistrationApplicationWhereInput | PetRegistrationApplicationWhereInput[]
    OR?: PetRegistrationApplicationWhereInput[]
    NOT?: PetRegistrationApplicationWhereInput | PetRegistrationApplicationWhereInput[]
    id?: UuidFilter<"PetRegistrationApplication"> | string
    applicationType?: EnumApplicationTypeFilter<"PetRegistrationApplication"> | $Enums.ApplicationType
    identifierType?: EnumIdentifierTypeFilter<"PetRegistrationApplication"> | $Enums.IdentifierType
    identifierNumber?: StringNullableFilter<"PetRegistrationApplication"> | string | null
    submittedAt?: DateTimeFilter<"PetRegistrationApplication"> | Date | string
    city?: StringFilter<"PetRegistrationApplication"> | string
    state?: StringFilter<"PetRegistrationApplication"> | string
    country?: StringFilter<"PetRegistrationApplication"> | string
    applicantType?: EnumApplicantTypeFilter<"PetRegistrationApplication"> | $Enums.ApplicantType
    applicantName?: StringFilter<"PetRegistrationApplication"> | string
    fatherOrHusbandName?: StringNullableFilter<"PetRegistrationApplication"> | string | null
    applicantEmail?: StringFilter<"PetRegistrationApplication"> | string
    applicantPhone?: StringFilter<"PetRegistrationApplication"> | string
    aadhaarNumber?: StringNullableFilter<"PetRegistrationApplication"> | string | null
    pincode?: StringFilter<"PetRegistrationApplication"> | string
    address?: StringFilter<"PetRegistrationApplication"> | string
    hasTokenNumber?: BoolFilter<"PetRegistrationApplication"> | boolean
    declarationAcknowledgement?: StringFilter<"PetRegistrationApplication"> | string
    acceptedTerms?: BoolFilter<"PetRegistrationApplication"> | boolean
    registrationFee?: DecimalFilter<"PetRegistrationApplication"> | Decimal | DecimalJsLike | number | string
    convenienceFee?: DecimalFilter<"PetRegistrationApplication"> | Decimal | DecimalJsLike | number | string
    gst?: DecimalFilter<"PetRegistrationApplication"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"PetRegistrationApplication"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"PetRegistrationApplication"> | string
    deliveryAddressLine?: StringFilter<"PetRegistrationApplication"> | string
    deliveryCity?: StringFilter<"PetRegistrationApplication"> | string
    deliveryState?: StringFilter<"PetRegistrationApplication"> | string
    deliveryPincode?: StringFilter<"PetRegistrationApplication"> | string
    createdAt?: DateTimeFilter<"PetRegistrationApplication"> | Date | string
    updatedAt?: DateTimeFilter<"PetRegistrationApplication"> | Date | string
    documents?: ApplicationDocumentListRelationFilter
    checkoutItems?: CheckoutItemListRelationFilter
    pets?: RegisteredPetListRelationFilter
  }

  export type PetRegistrationApplicationOrderByWithRelationInput = {
    id?: SortOrder
    applicationType?: SortOrder
    identifierType?: SortOrder
    identifierNumber?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    applicantType?: SortOrder
    applicantName?: SortOrder
    fatherOrHusbandName?: SortOrderInput | SortOrder
    applicantEmail?: SortOrder
    applicantPhone?: SortOrder
    aadhaarNumber?: SortOrderInput | SortOrder
    pincode?: SortOrder
    address?: SortOrder
    hasTokenNumber?: SortOrder
    declarationAcknowledgement?: SortOrder
    acceptedTerms?: SortOrder
    registrationFee?: SortOrder
    convenienceFee?: SortOrder
    gst?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    deliveryAddressLine?: SortOrder
    deliveryCity?: SortOrder
    deliveryState?: SortOrder
    deliveryPincode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    documents?: ApplicationDocumentOrderByRelationAggregateInput
    checkoutItems?: CheckoutItemOrderByRelationAggregateInput
    pets?: RegisteredPetOrderByRelationAggregateInput
  }

  export type PetRegistrationApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PetRegistrationApplicationWhereInput | PetRegistrationApplicationWhereInput[]
    OR?: PetRegistrationApplicationWhereInput[]
    NOT?: PetRegistrationApplicationWhereInput | PetRegistrationApplicationWhereInput[]
    applicationType?: EnumApplicationTypeFilter<"PetRegistrationApplication"> | $Enums.ApplicationType
    identifierType?: EnumIdentifierTypeFilter<"PetRegistrationApplication"> | $Enums.IdentifierType
    identifierNumber?: StringNullableFilter<"PetRegistrationApplication"> | string | null
    submittedAt?: DateTimeFilter<"PetRegistrationApplication"> | Date | string
    city?: StringFilter<"PetRegistrationApplication"> | string
    state?: StringFilter<"PetRegistrationApplication"> | string
    country?: StringFilter<"PetRegistrationApplication"> | string
    applicantType?: EnumApplicantTypeFilter<"PetRegistrationApplication"> | $Enums.ApplicantType
    applicantName?: StringFilter<"PetRegistrationApplication"> | string
    fatherOrHusbandName?: StringNullableFilter<"PetRegistrationApplication"> | string | null
    applicantEmail?: StringFilter<"PetRegistrationApplication"> | string
    applicantPhone?: StringFilter<"PetRegistrationApplication"> | string
    aadhaarNumber?: StringNullableFilter<"PetRegistrationApplication"> | string | null
    pincode?: StringFilter<"PetRegistrationApplication"> | string
    address?: StringFilter<"PetRegistrationApplication"> | string
    hasTokenNumber?: BoolFilter<"PetRegistrationApplication"> | boolean
    declarationAcknowledgement?: StringFilter<"PetRegistrationApplication"> | string
    acceptedTerms?: BoolFilter<"PetRegistrationApplication"> | boolean
    registrationFee?: DecimalFilter<"PetRegistrationApplication"> | Decimal | DecimalJsLike | number | string
    convenienceFee?: DecimalFilter<"PetRegistrationApplication"> | Decimal | DecimalJsLike | number | string
    gst?: DecimalFilter<"PetRegistrationApplication"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"PetRegistrationApplication"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"PetRegistrationApplication"> | string
    deliveryAddressLine?: StringFilter<"PetRegistrationApplication"> | string
    deliveryCity?: StringFilter<"PetRegistrationApplication"> | string
    deliveryState?: StringFilter<"PetRegistrationApplication"> | string
    deliveryPincode?: StringFilter<"PetRegistrationApplication"> | string
    createdAt?: DateTimeFilter<"PetRegistrationApplication"> | Date | string
    updatedAt?: DateTimeFilter<"PetRegistrationApplication"> | Date | string
    documents?: ApplicationDocumentListRelationFilter
    checkoutItems?: CheckoutItemListRelationFilter
    pets?: RegisteredPetListRelationFilter
  }, "id">

  export type PetRegistrationApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    applicationType?: SortOrder
    identifierType?: SortOrder
    identifierNumber?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    applicantType?: SortOrder
    applicantName?: SortOrder
    fatherOrHusbandName?: SortOrderInput | SortOrder
    applicantEmail?: SortOrder
    applicantPhone?: SortOrder
    aadhaarNumber?: SortOrderInput | SortOrder
    pincode?: SortOrder
    address?: SortOrder
    hasTokenNumber?: SortOrder
    declarationAcknowledgement?: SortOrder
    acceptedTerms?: SortOrder
    registrationFee?: SortOrder
    convenienceFee?: SortOrder
    gst?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    deliveryAddressLine?: SortOrder
    deliveryCity?: SortOrder
    deliveryState?: SortOrder
    deliveryPincode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PetRegistrationApplicationCountOrderByAggregateInput
    _avg?: PetRegistrationApplicationAvgOrderByAggregateInput
    _max?: PetRegistrationApplicationMaxOrderByAggregateInput
    _min?: PetRegistrationApplicationMinOrderByAggregateInput
    _sum?: PetRegistrationApplicationSumOrderByAggregateInput
  }

  export type PetRegistrationApplicationScalarWhereWithAggregatesInput = {
    AND?: PetRegistrationApplicationScalarWhereWithAggregatesInput | PetRegistrationApplicationScalarWhereWithAggregatesInput[]
    OR?: PetRegistrationApplicationScalarWhereWithAggregatesInput[]
    NOT?: PetRegistrationApplicationScalarWhereWithAggregatesInput | PetRegistrationApplicationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PetRegistrationApplication"> | string
    applicationType?: EnumApplicationTypeWithAggregatesFilter<"PetRegistrationApplication"> | $Enums.ApplicationType
    identifierType?: EnumIdentifierTypeWithAggregatesFilter<"PetRegistrationApplication"> | $Enums.IdentifierType
    identifierNumber?: StringNullableWithAggregatesFilter<"PetRegistrationApplication"> | string | null
    submittedAt?: DateTimeWithAggregatesFilter<"PetRegistrationApplication"> | Date | string
    city?: StringWithAggregatesFilter<"PetRegistrationApplication"> | string
    state?: StringWithAggregatesFilter<"PetRegistrationApplication"> | string
    country?: StringWithAggregatesFilter<"PetRegistrationApplication"> | string
    applicantType?: EnumApplicantTypeWithAggregatesFilter<"PetRegistrationApplication"> | $Enums.ApplicantType
    applicantName?: StringWithAggregatesFilter<"PetRegistrationApplication"> | string
    fatherOrHusbandName?: StringNullableWithAggregatesFilter<"PetRegistrationApplication"> | string | null
    applicantEmail?: StringWithAggregatesFilter<"PetRegistrationApplication"> | string
    applicantPhone?: StringWithAggregatesFilter<"PetRegistrationApplication"> | string
    aadhaarNumber?: StringNullableWithAggregatesFilter<"PetRegistrationApplication"> | string | null
    pincode?: StringWithAggregatesFilter<"PetRegistrationApplication"> | string
    address?: StringWithAggregatesFilter<"PetRegistrationApplication"> | string
    hasTokenNumber?: BoolWithAggregatesFilter<"PetRegistrationApplication"> | boolean
    declarationAcknowledgement?: StringWithAggregatesFilter<"PetRegistrationApplication"> | string
    acceptedTerms?: BoolWithAggregatesFilter<"PetRegistrationApplication"> | boolean
    registrationFee?: DecimalWithAggregatesFilter<"PetRegistrationApplication"> | Decimal | DecimalJsLike | number | string
    convenienceFee?: DecimalWithAggregatesFilter<"PetRegistrationApplication"> | Decimal | DecimalJsLike | number | string
    gst?: DecimalWithAggregatesFilter<"PetRegistrationApplication"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalWithAggregatesFilter<"PetRegistrationApplication"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"PetRegistrationApplication"> | string
    deliveryAddressLine?: StringWithAggregatesFilter<"PetRegistrationApplication"> | string
    deliveryCity?: StringWithAggregatesFilter<"PetRegistrationApplication"> | string
    deliveryState?: StringWithAggregatesFilter<"PetRegistrationApplication"> | string
    deliveryPincode?: StringWithAggregatesFilter<"PetRegistrationApplication"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PetRegistrationApplication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PetRegistrationApplication"> | Date | string
  }

  export type RegisteredPetWhereInput = {
    AND?: RegisteredPetWhereInput | RegisteredPetWhereInput[]
    OR?: RegisteredPetWhereInput[]
    NOT?: RegisteredPetWhereInput | RegisteredPetWhereInput[]
    id?: UuidFilter<"RegisteredPet"> | string
    applicationId?: UuidFilter<"RegisteredPet"> | string
    petName?: StringFilter<"RegisteredPet"> | string
    breed?: StringFilter<"RegisteredPet"> | string
    dateOfBirth?: DateTimeFilter<"RegisteredPet"> | Date | string
    ageOnRegistration?: StringFilter<"RegisteredPet"> | string
    lastRabiesVaccinationDate?: DateTimeFilter<"RegisteredPet"> | Date | string
    veterinaryDoctorName?: StringFilter<"RegisteredPet"> | string
    veterinaryDoctorRegNumber?: StringFilter<"RegisteredPet"> | string
    veterinaryClinicOrHospitalName?: StringFilter<"RegisteredPet"> | string
    createdAt?: DateTimeFilter<"RegisteredPet"> | Date | string
    updatedAt?: DateTimeFilter<"RegisteredPet"> | Date | string
    gender?: EnumGenderFilter<"RegisteredPet"> | $Enums.Gender
    documents?: PetDocumentListRelationFilter
    application?: XOR<PetRegistrationApplicationScalarRelationFilter, PetRegistrationApplicationWhereInput>
  }

  export type RegisteredPetOrderByWithRelationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    petName?: SortOrder
    breed?: SortOrder
    dateOfBirth?: SortOrder
    ageOnRegistration?: SortOrder
    lastRabiesVaccinationDate?: SortOrder
    veterinaryDoctorName?: SortOrder
    veterinaryDoctorRegNumber?: SortOrder
    veterinaryClinicOrHospitalName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gender?: SortOrder
    documents?: PetDocumentOrderByRelationAggregateInput
    application?: PetRegistrationApplicationOrderByWithRelationInput
  }

  export type RegisteredPetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RegisteredPetWhereInput | RegisteredPetWhereInput[]
    OR?: RegisteredPetWhereInput[]
    NOT?: RegisteredPetWhereInput | RegisteredPetWhereInput[]
    applicationId?: UuidFilter<"RegisteredPet"> | string
    petName?: StringFilter<"RegisteredPet"> | string
    breed?: StringFilter<"RegisteredPet"> | string
    dateOfBirth?: DateTimeFilter<"RegisteredPet"> | Date | string
    ageOnRegistration?: StringFilter<"RegisteredPet"> | string
    lastRabiesVaccinationDate?: DateTimeFilter<"RegisteredPet"> | Date | string
    veterinaryDoctorName?: StringFilter<"RegisteredPet"> | string
    veterinaryDoctorRegNumber?: StringFilter<"RegisteredPet"> | string
    veterinaryClinicOrHospitalName?: StringFilter<"RegisteredPet"> | string
    createdAt?: DateTimeFilter<"RegisteredPet"> | Date | string
    updatedAt?: DateTimeFilter<"RegisteredPet"> | Date | string
    gender?: EnumGenderFilter<"RegisteredPet"> | $Enums.Gender
    documents?: PetDocumentListRelationFilter
    application?: XOR<PetRegistrationApplicationScalarRelationFilter, PetRegistrationApplicationWhereInput>
  }, "id">

  export type RegisteredPetOrderByWithAggregationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    petName?: SortOrder
    breed?: SortOrder
    dateOfBirth?: SortOrder
    ageOnRegistration?: SortOrder
    lastRabiesVaccinationDate?: SortOrder
    veterinaryDoctorName?: SortOrder
    veterinaryDoctorRegNumber?: SortOrder
    veterinaryClinicOrHospitalName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gender?: SortOrder
    _count?: RegisteredPetCountOrderByAggregateInput
    _max?: RegisteredPetMaxOrderByAggregateInput
    _min?: RegisteredPetMinOrderByAggregateInput
  }

  export type RegisteredPetScalarWhereWithAggregatesInput = {
    AND?: RegisteredPetScalarWhereWithAggregatesInput | RegisteredPetScalarWhereWithAggregatesInput[]
    OR?: RegisteredPetScalarWhereWithAggregatesInput[]
    NOT?: RegisteredPetScalarWhereWithAggregatesInput | RegisteredPetScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"RegisteredPet"> | string
    applicationId?: UuidWithAggregatesFilter<"RegisteredPet"> | string
    petName?: StringWithAggregatesFilter<"RegisteredPet"> | string
    breed?: StringWithAggregatesFilter<"RegisteredPet"> | string
    dateOfBirth?: DateTimeWithAggregatesFilter<"RegisteredPet"> | Date | string
    ageOnRegistration?: StringWithAggregatesFilter<"RegisteredPet"> | string
    lastRabiesVaccinationDate?: DateTimeWithAggregatesFilter<"RegisteredPet"> | Date | string
    veterinaryDoctorName?: StringWithAggregatesFilter<"RegisteredPet"> | string
    veterinaryDoctorRegNumber?: StringWithAggregatesFilter<"RegisteredPet"> | string
    veterinaryClinicOrHospitalName?: StringWithAggregatesFilter<"RegisteredPet"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RegisteredPet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RegisteredPet"> | Date | string
    gender?: EnumGenderWithAggregatesFilter<"RegisteredPet"> | $Enums.Gender
  }

  export type ApplicationDocumentWhereInput = {
    AND?: ApplicationDocumentWhereInput | ApplicationDocumentWhereInput[]
    OR?: ApplicationDocumentWhereInput[]
    NOT?: ApplicationDocumentWhereInput | ApplicationDocumentWhereInput[]
    id?: UuidFilter<"ApplicationDocument"> | string
    applicationId?: UuidFilter<"ApplicationDocument"> | string
    documentType?: EnumDocumentTypeFilter<"ApplicationDocument"> | $Enums.DocumentType
    fileName?: StringFilter<"ApplicationDocument"> | string
    filePath?: StringFilter<"ApplicationDocument"> | string
    mimeType?: StringFilter<"ApplicationDocument"> | string
    sizeBytes?: BigIntFilter<"ApplicationDocument"> | bigint | number
    createdAt?: DateTimeFilter<"ApplicationDocument"> | Date | string
    application?: XOR<PetRegistrationApplicationScalarRelationFilter, PetRegistrationApplicationWhereInput>
  }

  export type ApplicationDocumentOrderByWithRelationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
    application?: PetRegistrationApplicationOrderByWithRelationInput
  }

  export type ApplicationDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApplicationDocumentWhereInput | ApplicationDocumentWhereInput[]
    OR?: ApplicationDocumentWhereInput[]
    NOT?: ApplicationDocumentWhereInput | ApplicationDocumentWhereInput[]
    applicationId?: UuidFilter<"ApplicationDocument"> | string
    documentType?: EnumDocumentTypeFilter<"ApplicationDocument"> | $Enums.DocumentType
    fileName?: StringFilter<"ApplicationDocument"> | string
    filePath?: StringFilter<"ApplicationDocument"> | string
    mimeType?: StringFilter<"ApplicationDocument"> | string
    sizeBytes?: BigIntFilter<"ApplicationDocument"> | bigint | number
    createdAt?: DateTimeFilter<"ApplicationDocument"> | Date | string
    application?: XOR<PetRegistrationApplicationScalarRelationFilter, PetRegistrationApplicationWhereInput>
  }, "id">

  export type ApplicationDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
    _count?: ApplicationDocumentCountOrderByAggregateInput
    _avg?: ApplicationDocumentAvgOrderByAggregateInput
    _max?: ApplicationDocumentMaxOrderByAggregateInput
    _min?: ApplicationDocumentMinOrderByAggregateInput
    _sum?: ApplicationDocumentSumOrderByAggregateInput
  }

  export type ApplicationDocumentScalarWhereWithAggregatesInput = {
    AND?: ApplicationDocumentScalarWhereWithAggregatesInput | ApplicationDocumentScalarWhereWithAggregatesInput[]
    OR?: ApplicationDocumentScalarWhereWithAggregatesInput[]
    NOT?: ApplicationDocumentScalarWhereWithAggregatesInput | ApplicationDocumentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ApplicationDocument"> | string
    applicationId?: UuidWithAggregatesFilter<"ApplicationDocument"> | string
    documentType?: EnumDocumentTypeWithAggregatesFilter<"ApplicationDocument"> | $Enums.DocumentType
    fileName?: StringWithAggregatesFilter<"ApplicationDocument"> | string
    filePath?: StringWithAggregatesFilter<"ApplicationDocument"> | string
    mimeType?: StringWithAggregatesFilter<"ApplicationDocument"> | string
    sizeBytes?: BigIntWithAggregatesFilter<"ApplicationDocument"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"ApplicationDocument"> | Date | string
  }

  export type PetDocumentWhereInput = {
    AND?: PetDocumentWhereInput | PetDocumentWhereInput[]
    OR?: PetDocumentWhereInput[]
    NOT?: PetDocumentWhereInput | PetDocumentWhereInput[]
    id?: UuidFilter<"PetDocument"> | string
    petId?: UuidFilter<"PetDocument"> | string
    documentType?: EnumDocumentTypeFilter<"PetDocument"> | $Enums.DocumentType
    fileName?: StringFilter<"PetDocument"> | string
    filePath?: StringFilter<"PetDocument"> | string
    mimeType?: StringFilter<"PetDocument"> | string
    sizeBytes?: BigIntFilter<"PetDocument"> | bigint | number
    createdAt?: DateTimeFilter<"PetDocument"> | Date | string
    pet?: XOR<RegisteredPetScalarRelationFilter, RegisteredPetWhereInput>
  }

  export type PetDocumentOrderByWithRelationInput = {
    id?: SortOrder
    petId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
    pet?: RegisteredPetOrderByWithRelationInput
  }

  export type PetDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PetDocumentWhereInput | PetDocumentWhereInput[]
    OR?: PetDocumentWhereInput[]
    NOT?: PetDocumentWhereInput | PetDocumentWhereInput[]
    petId?: UuidFilter<"PetDocument"> | string
    documentType?: EnumDocumentTypeFilter<"PetDocument"> | $Enums.DocumentType
    fileName?: StringFilter<"PetDocument"> | string
    filePath?: StringFilter<"PetDocument"> | string
    mimeType?: StringFilter<"PetDocument"> | string
    sizeBytes?: BigIntFilter<"PetDocument"> | bigint | number
    createdAt?: DateTimeFilter<"PetDocument"> | Date | string
    pet?: XOR<RegisteredPetScalarRelationFilter, RegisteredPetWhereInput>
  }, "id">

  export type PetDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    petId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
    _count?: PetDocumentCountOrderByAggregateInput
    _avg?: PetDocumentAvgOrderByAggregateInput
    _max?: PetDocumentMaxOrderByAggregateInput
    _min?: PetDocumentMinOrderByAggregateInput
    _sum?: PetDocumentSumOrderByAggregateInput
  }

  export type PetDocumentScalarWhereWithAggregatesInput = {
    AND?: PetDocumentScalarWhereWithAggregatesInput | PetDocumentScalarWhereWithAggregatesInput[]
    OR?: PetDocumentScalarWhereWithAggregatesInput[]
    NOT?: PetDocumentScalarWhereWithAggregatesInput | PetDocumentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PetDocument"> | string
    petId?: UuidWithAggregatesFilter<"PetDocument"> | string
    documentType?: EnumDocumentTypeWithAggregatesFilter<"PetDocument"> | $Enums.DocumentType
    fileName?: StringWithAggregatesFilter<"PetDocument"> | string
    filePath?: StringWithAggregatesFilter<"PetDocument"> | string
    mimeType?: StringWithAggregatesFilter<"PetDocument"> | string
    sizeBytes?: BigIntWithAggregatesFilter<"PetDocument"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"PetDocument"> | Date | string
  }

  export type CheckoutItemWhereInput = {
    AND?: CheckoutItemWhereInput | CheckoutItemWhereInput[]
    OR?: CheckoutItemWhereInput[]
    NOT?: CheckoutItemWhereInput | CheckoutItemWhereInput[]
    id?: UuidFilter<"CheckoutItem"> | string
    applicationId?: UuidFilter<"CheckoutItem"> | string
    sku?: StringFilter<"CheckoutItem"> | string
    itemName?: StringFilter<"CheckoutItem"> | string
    quantity?: IntFilter<"CheckoutItem"> | number
    unitPrice?: DecimalFilter<"CheckoutItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"CheckoutItem"> | Date | string
    application?: XOR<PetRegistrationApplicationScalarRelationFilter, PetRegistrationApplicationWhereInput>
  }

  export type CheckoutItemOrderByWithRelationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    sku?: SortOrder
    itemName?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    createdAt?: SortOrder
    application?: PetRegistrationApplicationOrderByWithRelationInput
  }

  export type CheckoutItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CheckoutItemWhereInput | CheckoutItemWhereInput[]
    OR?: CheckoutItemWhereInput[]
    NOT?: CheckoutItemWhereInput | CheckoutItemWhereInput[]
    applicationId?: UuidFilter<"CheckoutItem"> | string
    sku?: StringFilter<"CheckoutItem"> | string
    itemName?: StringFilter<"CheckoutItem"> | string
    quantity?: IntFilter<"CheckoutItem"> | number
    unitPrice?: DecimalFilter<"CheckoutItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"CheckoutItem"> | Date | string
    application?: XOR<PetRegistrationApplicationScalarRelationFilter, PetRegistrationApplicationWhereInput>
  }, "id">

  export type CheckoutItemOrderByWithAggregationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    sku?: SortOrder
    itemName?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    createdAt?: SortOrder
    _count?: CheckoutItemCountOrderByAggregateInput
    _avg?: CheckoutItemAvgOrderByAggregateInput
    _max?: CheckoutItemMaxOrderByAggregateInput
    _min?: CheckoutItemMinOrderByAggregateInput
    _sum?: CheckoutItemSumOrderByAggregateInput
  }

  export type CheckoutItemScalarWhereWithAggregatesInput = {
    AND?: CheckoutItemScalarWhereWithAggregatesInput | CheckoutItemScalarWhereWithAggregatesInput[]
    OR?: CheckoutItemScalarWhereWithAggregatesInput[]
    NOT?: CheckoutItemScalarWhereWithAggregatesInput | CheckoutItemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CheckoutItem"> | string
    applicationId?: UuidWithAggregatesFilter<"CheckoutItem"> | string
    sku?: StringWithAggregatesFilter<"CheckoutItem"> | string
    itemName?: StringWithAggregatesFilter<"CheckoutItem"> | string
    quantity?: IntWithAggregatesFilter<"CheckoutItem"> | number
    unitPrice?: DecimalWithAggregatesFilter<"CheckoutItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"CheckoutItem"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    executive?: ExecutiveCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerCreateNestedOneWithoutUserInput
    registeredPets?: PetCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    executive?: ExecutiveUncheckedCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeUncheckedCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerUncheckedCreateNestedOneWithoutUserInput
    registeredPets?: PetUncheckedCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUpdateOneWithoutUserNestedInput
    registeredPets?: PetUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUncheckedUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUncheckedUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUncheckedUpdateOneWithoutUserNestedInput
    registeredPets?: PetUncheckedUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
  }

  export type OTPCodeCreateInput = {
    id?: string
    codeHash: string
    purpose: $Enums.OTPPurpose
    deliveryMethod?: string | null
    expiresAt: Date | string
    isUsed?: boolean
    attemptsCount?: number
    maxAttempts?: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutOtpCodesInput
  }

  export type OTPCodeUncheckedCreateInput = {
    id?: string
    userId: string
    codeHash: string
    purpose: $Enums.OTPPurpose
    deliveryMethod?: string | null
    expiresAt: Date | string
    isUsed?: boolean
    attemptsCount?: number
    maxAttempts?: number
    createdAt?: Date | string
  }

  export type OTPCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    purpose?: EnumOTPPurposeFieldUpdateOperationsInput | $Enums.OTPPurpose
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    attemptsCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOtpCodesNestedInput
  }

  export type OTPCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    purpose?: EnumOTPPurposeFieldUpdateOperationsInput | $Enums.OTPPurpose
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    attemptsCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPCodeCreateManyInput = {
    id?: string
    userId: string
    codeHash: string
    purpose: $Enums.OTPPurpose
    deliveryMethod?: string | null
    expiresAt: Date | string
    isUsed?: boolean
    attemptsCount?: number
    maxAttempts?: number
    createdAt?: Date | string
  }

  export type OTPCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    purpose?: EnumOTPPurposeFieldUpdateOperationsInput | $Enums.OTPPurpose
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    attemptsCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    purpose?: EnumOTPPurposeFieldUpdateOperationsInput | $Enums.OTPPurpose
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    attemptsCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateInput = {
    id?: string
    refreshTokenHash: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    lastUsedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type UserSessionUncheckedCreateInput = {
    id?: string
    userId: string
    refreshTokenHash: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type UserSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateManyInput = {
    id?: string
    userId: string
    refreshTokenHash: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type UserSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExecutiveCreateInput = {
    id?: string
    employeeId: string
    territory?: string | null
    isActive?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutExecutiveInput
  }

  export type ExecutiveUncheckedCreateInput = {
    id?: string
    userId: string
    employeeId: string
    territory?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ExecutiveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    territory?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExecutiveNestedInput
  }

  export type ExecutiveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    territory?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExecutiveCreateManyInput = {
    id?: string
    userId: string
    employeeId: string
    territory?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ExecutiveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    territory?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExecutiveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    territory?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetOwnerCreateInput = {
    id?: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    countryCode?: string
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPetOwnerInput
    pets?: PetCreateNestedManyWithoutOwnerInput
  }

  export type PetOwnerUncheckedCreateInput = {
    id?: string
    userId: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    countryCode?: string
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pets?: PetUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type PetOwnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: StringFieldUpdateOperationsInput | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPetOwnerNestedInput
    pets?: PetUpdateManyWithoutOwnerNestedInput
  }

  export type PetOwnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: StringFieldUpdateOperationsInput | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pets?: PetUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type PetOwnerCreateManyInput = {
    id?: string
    userId: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    countryCode?: string
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PetOwnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: StringFieldUpdateOperationsInput | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetOwnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: StringFieldUpdateOperationsInput | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetSpeciesCreateInput = {
    speciesName: string
    category: string
    breeds?: PetBreedCreateNestedManyWithoutSpeciesInput
    pets?: PetCreateNestedManyWithoutSpeciesInput
  }

  export type PetSpeciesUncheckedCreateInput = {
    id?: number
    speciesName: string
    category: string
    breeds?: PetBreedUncheckedCreateNestedManyWithoutSpeciesInput
    pets?: PetUncheckedCreateNestedManyWithoutSpeciesInput
  }

  export type PetSpeciesUpdateInput = {
    speciesName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    breeds?: PetBreedUpdateManyWithoutSpeciesNestedInput
    pets?: PetUpdateManyWithoutSpeciesNestedInput
  }

  export type PetSpeciesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    speciesName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    breeds?: PetBreedUncheckedUpdateManyWithoutSpeciesNestedInput
    pets?: PetUncheckedUpdateManyWithoutSpeciesNestedInput
  }

  export type PetSpeciesCreateManyInput = {
    id?: number
    speciesName: string
    category: string
  }

  export type PetSpeciesUpdateManyMutationInput = {
    speciesName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
  }

  export type PetSpeciesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    speciesName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
  }

  export type PetBreedCreateInput = {
    breedName: string
    sizeCategory?: $Enums.SizeCategory | null
    typicalLifespanYears?: number | null
    species: PetSpeciesCreateNestedOneWithoutBreedsInput
    pets_pets_breed_idTopet_breeds?: PetCreateNestedManyWithoutPet_breeds_pets_breed_idTopet_breedsInput
    pets_pets_secondary_breed_idTopet_breeds?: PetCreateNestedManyWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput
  }

  export type PetBreedUncheckedCreateInput = {
    id?: number
    breedName: string
    speciesId: number
    sizeCategory?: $Enums.SizeCategory | null
    typicalLifespanYears?: number | null
    pets_pets_breed_idTopet_breeds?: PetUncheckedCreateNestedManyWithoutPet_breeds_pets_breed_idTopet_breedsInput
    pets_pets_secondary_breed_idTopet_breeds?: PetUncheckedCreateNestedManyWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput
  }

  export type PetBreedUpdateInput = {
    breedName?: StringFieldUpdateOperationsInput | string
    sizeCategory?: NullableEnumSizeCategoryFieldUpdateOperationsInput | $Enums.SizeCategory | null
    typicalLifespanYears?: NullableIntFieldUpdateOperationsInput | number | null
    species?: PetSpeciesUpdateOneRequiredWithoutBreedsNestedInput
    pets_pets_breed_idTopet_breeds?: PetUpdateManyWithoutPet_breeds_pets_breed_idTopet_breedsNestedInput
    pets_pets_secondary_breed_idTopet_breeds?: PetUpdateManyWithoutPet_breeds_pets_secondary_breed_idTopet_breedsNestedInput
  }

  export type PetBreedUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    breedName?: StringFieldUpdateOperationsInput | string
    speciesId?: IntFieldUpdateOperationsInput | number
    sizeCategory?: NullableEnumSizeCategoryFieldUpdateOperationsInput | $Enums.SizeCategory | null
    typicalLifespanYears?: NullableIntFieldUpdateOperationsInput | number | null
    pets_pets_breed_idTopet_breeds?: PetUncheckedUpdateManyWithoutPet_breeds_pets_breed_idTopet_breedsNestedInput
    pets_pets_secondary_breed_idTopet_breeds?: PetUncheckedUpdateManyWithoutPet_breeds_pets_secondary_breed_idTopet_breedsNestedInput
  }

  export type PetBreedCreateManyInput = {
    id?: number
    breedName: string
    speciesId: number
    sizeCategory?: $Enums.SizeCategory | null
    typicalLifespanYears?: number | null
  }

  export type PetBreedUpdateManyMutationInput = {
    breedName?: StringFieldUpdateOperationsInput | string
    sizeCategory?: NullableEnumSizeCategoryFieldUpdateOperationsInput | $Enums.SizeCategory | null
    typicalLifespanYears?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PetBreedUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    breedName?: StringFieldUpdateOperationsInput | string
    speciesId?: IntFieldUpdateOperationsInput | number
    sizeCategory?: NullableEnumSizeCategoryFieldUpdateOperationsInput | $Enums.SizeCategory | null
    typicalLifespanYears?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PetCreateInput = {
    id?: string
    name: string
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPetInput
    notifications?: NotificationCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventCreateNestedManyWithoutPetInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_breed_idTopet_breedsInput
    owner: PetOwnerCreateNestedOneWithoutPetsInput
    registeredByUser?: UserCreateNestedOneWithoutRegisteredPetsInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_secondary_breed_idTopet_breedsInput
    species?: PetSpeciesCreateNestedOneWithoutPetsInput
    qrCodes?: QRCodeCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordCreateNestedManyWithoutPetInput
  }

  export type PetUncheckedCreateInput = {
    id?: string
    ownerId: string
    registeredBy?: string | null
    name: string
    speciesId?: number | null
    breed_id?: number | null
    secondary_breed_id?: number | null
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPetInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventUncheckedCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventUncheckedCreateNestedManyWithoutPetInput
    qrCodes?: QRCodeUncheckedCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUpdateManyWithoutPetNestedInput
    notifications?: NotificationUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUpdateManyWithoutPetNestedInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_breed_idTopet_breedsNestedInput
    owner?: PetOwnerUpdateOneRequiredWithoutPetsNestedInput
    registeredByUser?: UserUpdateOneWithoutRegisteredPetsNestedInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_secondary_breed_idTopet_breedsNestedInput
    species?: PetSpeciesUpdateOneWithoutPetsNestedInput
    qrCodes?: QRCodeUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    registeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableIntFieldUpdateOperationsInput | number | null
    breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPetNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUncheckedUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUncheckedUpdateManyWithoutPetNestedInput
    qrCodes?: QRCodeUncheckedUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUncheckedUpdateManyWithoutPetNestedInput
  }

  export type PetCreateManyInput = {
    id?: string
    ownerId: string
    registeredBy?: string | null
    name: string
    speciesId?: number | null
    breed_id?: number | null
    secondary_breed_id?: number | null
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    registeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableIntFieldUpdateOperationsInput | number | null
    breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccineTypeCreateInput = {
    vaccineName: string
    speciesApplicability?: VaccineTypeCreatespeciesApplicabilityInput | number[]
    durationMonths?: number | null
    isRequiredByLaw?: boolean
    vaccinationRecords?: VaccinationRecordCreateNestedManyWithoutVaccineTypeInput
  }

  export type VaccineTypeUncheckedCreateInput = {
    id?: number
    vaccineName: string
    speciesApplicability?: VaccineTypeCreatespeciesApplicabilityInput | number[]
    durationMonths?: number | null
    isRequiredByLaw?: boolean
    vaccinationRecords?: VaccinationRecordUncheckedCreateNestedManyWithoutVaccineTypeInput
  }

  export type VaccineTypeUpdateInput = {
    vaccineName?: StringFieldUpdateOperationsInput | string
    speciesApplicability?: VaccineTypeUpdatespeciesApplicabilityInput | number[]
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    isRequiredByLaw?: BoolFieldUpdateOperationsInput | boolean
    vaccinationRecords?: VaccinationRecordUpdateManyWithoutVaccineTypeNestedInput
  }

  export type VaccineTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vaccineName?: StringFieldUpdateOperationsInput | string
    speciesApplicability?: VaccineTypeUpdatespeciesApplicabilityInput | number[]
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    isRequiredByLaw?: BoolFieldUpdateOperationsInput | boolean
    vaccinationRecords?: VaccinationRecordUncheckedUpdateManyWithoutVaccineTypeNestedInput
  }

  export type VaccineTypeCreateManyInput = {
    id?: number
    vaccineName: string
    speciesApplicability?: VaccineTypeCreatespeciesApplicabilityInput | number[]
    durationMonths?: number | null
    isRequiredByLaw?: boolean
  }

  export type VaccineTypeUpdateManyMutationInput = {
    vaccineName?: StringFieldUpdateOperationsInput | string
    speciesApplicability?: VaccineTypeUpdatespeciesApplicabilityInput | number[]
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    isRequiredByLaw?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VaccineTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vaccineName?: StringFieldUpdateOperationsInput | string
    speciesApplicability?: VaccineTypeUpdatespeciesApplicabilityInput | number[]
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    isRequiredByLaw?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VaccinationRecordCreateInput = {
    id?: string
    administeredDate: Date | string
    expirationDate?: Date | string | null
    batchNumber?: string | null
    veterinarianName?: string | null
    clinicName?: string | null
    notes?: string | null
    certificateUrl?: string | null
    createdAt?: Date | string
    pet: PetCreateNestedOneWithoutVaccinationRecordsInput
    vaccineType: VaccineTypeCreateNestedOneWithoutVaccinationRecordsInput
  }

  export type VaccinationRecordUncheckedCreateInput = {
    id?: string
    petId: string
    vaccineTypeId: number
    administeredDate: Date | string
    expirationDate?: Date | string | null
    batchNumber?: string | null
    veterinarianName?: string | null
    clinicName?: string | null
    notes?: string | null
    certificateUrl?: string | null
    createdAt?: Date | string
  }

  export type VaccinationRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    administeredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    veterinarianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pet?: PetUpdateOneRequiredWithoutVaccinationRecordsNestedInput
    vaccineType?: VaccineTypeUpdateOneRequiredWithoutVaccinationRecordsNestedInput
  }

  export type VaccinationRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    vaccineTypeId?: IntFieldUpdateOperationsInput | number
    administeredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    veterinarianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationRecordCreateManyInput = {
    id?: string
    petId: string
    vaccineTypeId: number
    administeredDate: Date | string
    expirationDate?: Date | string | null
    batchNumber?: string | null
    veterinarianName?: string | null
    clinicName?: string | null
    notes?: string | null
    certificateUrl?: string | null
    createdAt?: Date | string
  }

  export type VaccinationRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    administeredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    veterinarianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    vaccineTypeId?: IntFieldUpdateOperationsInput | number
    administeredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    veterinarianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordCreateInput = {
    id?: string
    visitDate: Date | string
    veterinarianName?: string | null
    clinicName?: string | null
    diagnosis?: string | null
    treatment?: string | null
    medications?: NullableJsonNullValueInput | InputJsonValue
    followUpRequired?: boolean
    followUpDate?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    documentUrls?: MedicalRecordCreatedocumentUrlsInput | string[]
    createdAt?: Date | string
    pet: PetCreateNestedOneWithoutMedicalRecordsInput
  }

  export type MedicalRecordUncheckedCreateInput = {
    id?: string
    petId: string
    visitDate: Date | string
    veterinarianName?: string | null
    clinicName?: string | null
    diagnosis?: string | null
    treatment?: string | null
    medications?: NullableJsonNullValueInput | InputJsonValue
    followUpRequired?: boolean
    followUpDate?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    documentUrls?: MedicalRecordCreatedocumentUrlsInput | string[]
    createdAt?: Date | string
  }

  export type MedicalRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    veterinarianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableJsonNullValueInput | InputJsonValue
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    documentUrls?: MedicalRecordUpdatedocumentUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pet?: PetUpdateOneRequiredWithoutMedicalRecordsNestedInput
  }

  export type MedicalRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    veterinarianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableJsonNullValueInput | InputJsonValue
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    documentUrls?: MedicalRecordUpdatedocumentUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordCreateManyInput = {
    id?: string
    petId: string
    visitDate: Date | string
    veterinarianName?: string | null
    clinicName?: string | null
    diagnosis?: string | null
    treatment?: string | null
    medications?: NullableJsonNullValueInput | InputJsonValue
    followUpRequired?: boolean
    followUpDate?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    documentUrls?: MedicalRecordCreatedocumentUrlsInput | string[]
    createdAt?: Date | string
  }

  export type MedicalRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    veterinarianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableJsonNullValueInput | InputJsonValue
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    documentUrls?: MedicalRecordUpdatedocumentUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    veterinarianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableJsonNullValueInput | InputJsonValue
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    documentUrls?: MedicalRecordUpdatedocumentUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QRCodePoolCreateInput = {
    id?: string
    poolName: string
    totalCapacity: number
    usedCount?: number
    createdAt?: Date | string
    status?: $Enums.PoolStatus
    qrCodes?: QRCodeCreateNestedManyWithoutPoolInput
  }

  export type QRCodePoolUncheckedCreateInput = {
    id?: string
    poolName: string
    totalCapacity: number
    usedCount?: number
    createdAt?: Date | string
    status?: $Enums.PoolStatus
    qrCodes?: QRCodeUncheckedCreateNestedManyWithoutPoolInput
  }

  export type QRCodePoolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    poolName?: StringFieldUpdateOperationsInput | string
    totalCapacity?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPoolStatusFieldUpdateOperationsInput | $Enums.PoolStatus
    qrCodes?: QRCodeUpdateManyWithoutPoolNestedInput
  }

  export type QRCodePoolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    poolName?: StringFieldUpdateOperationsInput | string
    totalCapacity?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPoolStatusFieldUpdateOperationsInput | $Enums.PoolStatus
    qrCodes?: QRCodeUncheckedUpdateManyWithoutPoolNestedInput
  }

  export type QRCodePoolCreateManyInput = {
    id?: string
    poolName: string
    totalCapacity: number
    usedCount?: number
    createdAt?: Date | string
    status?: $Enums.PoolStatus
  }

  export type QRCodePoolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    poolName?: StringFieldUpdateOperationsInput | string
    totalCapacity?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPoolStatusFieldUpdateOperationsInput | $Enums.PoolStatus
  }

  export type QRCodePoolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    poolName?: StringFieldUpdateOperationsInput | string
    totalCapacity?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPoolStatusFieldUpdateOperationsInput | $Enums.PoolStatus
  }

  export type QRCodeCreateInput = {
    id?: string
    qrCodeString: string
    qrCodeHash: string
    qrImageUrl?: string | null
    status?: $Enums.QRStatus
    assignedAt?: Date | string | null
    activatedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    paymentEvents?: PaymentEventCreateNestedManyWithoutQrCodeInput
    pet?: PetCreateNestedOneWithoutQrCodesInput
    pool?: QRCodePoolCreateNestedOneWithoutQrCodesInput
    scanEvents?: QRScanEventCreateNestedManyWithoutQrCodeInput
  }

  export type QRCodeUncheckedCreateInput = {
    id?: string
    poolId?: string | null
    qrCodeString: string
    qrCodeHash: string
    qrImageUrl?: string | null
    status?: $Enums.QRStatus
    assignedToPet?: string | null
    assignedAt?: Date | string | null
    activatedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutQrCodeInput
    scanEvents?: QRScanEventUncheckedCreateNestedManyWithoutQrCodeInput
  }

  export type QRCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrCodeString?: StringFieldUpdateOperationsInput | string
    qrCodeHash?: StringFieldUpdateOperationsInput | string
    qrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQRStatusFieldUpdateOperationsInput | $Enums.QRStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentEvents?: PaymentEventUpdateManyWithoutQrCodeNestedInput
    pet?: PetUpdateOneWithoutQrCodesNestedInput
    pool?: QRCodePoolUpdateOneWithoutQrCodesNestedInput
    scanEvents?: QRScanEventUpdateManyWithoutQrCodeNestedInput
  }

  export type QRCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    poolId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeString?: StringFieldUpdateOperationsInput | string
    qrCodeHash?: StringFieldUpdateOperationsInput | string
    qrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQRStatusFieldUpdateOperationsInput | $Enums.QRStatus
    assignedToPet?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutQrCodeNestedInput
    scanEvents?: QRScanEventUncheckedUpdateManyWithoutQrCodeNestedInput
  }

  export type QRCodeCreateManyInput = {
    id?: string
    poolId?: string | null
    qrCodeString: string
    qrCodeHash: string
    qrImageUrl?: string | null
    status?: $Enums.QRStatus
    assignedToPet?: string | null
    assignedAt?: Date | string | null
    activatedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type QRCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrCodeString?: StringFieldUpdateOperationsInput | string
    qrCodeHash?: StringFieldUpdateOperationsInput | string
    qrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQRStatusFieldUpdateOperationsInput | $Enums.QRStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QRCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    poolId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeString?: StringFieldUpdateOperationsInput | string
    qrCodeHash?: StringFieldUpdateOperationsInput | string
    qrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQRStatusFieldUpdateOperationsInput | $Enums.QRStatus
    assignedToPet?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QRScanEventCreateInput = {
    id?: string
    scanTimestamp?: Date | string
    scannerIp?: string | null
    userAgent?: string | null
    deviceType?: $Enums.DeviceType | null
    scanLocation?: string | null
    locationAccuracy?: Decimal | DecimalJsLike | number | string | null
    locationName?: string | null
    countryCode?: string | null
    city?: string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    scanResult: $Enums.ScanResult
    createdAt?: Date | string
    qrCode: QRCodeCreateNestedOneWithoutScanEventsInput
    pet?: PetCreateNestedOneWithoutQrScanEventsInput
    locationEvents?: PetLocationEventCreateNestedManyWithoutQrScanEventInput
  }

  export type QRScanEventUncheckedCreateInput = {
    id?: string
    qrId: string
    petId?: string | null
    scanTimestamp?: Date | string
    scannerIp?: string | null
    userAgent?: string | null
    deviceType?: $Enums.DeviceType | null
    scanLocation?: string | null
    locationAccuracy?: Decimal | DecimalJsLike | number | string | null
    locationName?: string | null
    countryCode?: string | null
    city?: string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    scanResult: $Enums.ScanResult
    createdAt?: Date | string
    locationEvents?: PetLocationEventUncheckedCreateNestedManyWithoutQrScanEventInput
  }

  export type QRScanEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scanTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    scannerIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableEnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType | null
    scanLocation?: NullableStringFieldUpdateOperationsInput | string | null
    locationAccuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    scanResult?: EnumScanResultFieldUpdateOperationsInput | $Enums.ScanResult
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: QRCodeUpdateOneRequiredWithoutScanEventsNestedInput
    pet?: PetUpdateOneWithoutQrScanEventsNestedInput
    locationEvents?: PetLocationEventUpdateManyWithoutQrScanEventNestedInput
  }

  export type QRScanEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    petId?: NullableStringFieldUpdateOperationsInput | string | null
    scanTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    scannerIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableEnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType | null
    scanLocation?: NullableStringFieldUpdateOperationsInput | string | null
    locationAccuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    scanResult?: EnumScanResultFieldUpdateOperationsInput | $Enums.ScanResult
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationEvents?: PetLocationEventUncheckedUpdateManyWithoutQrScanEventNestedInput
  }

  export type QRScanEventCreateManyInput = {
    id?: string
    qrId: string
    petId?: string | null
    scanTimestamp?: Date | string
    scannerIp?: string | null
    userAgent?: string | null
    deviceType?: $Enums.DeviceType | null
    scanLocation?: string | null
    locationAccuracy?: Decimal | DecimalJsLike | number | string | null
    locationName?: string | null
    countryCode?: string | null
    city?: string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    scanResult: $Enums.ScanResult
    createdAt?: Date | string
  }

  export type QRScanEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scanTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    scannerIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableEnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType | null
    scanLocation?: NullableStringFieldUpdateOperationsInput | string | null
    locationAccuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    scanResult?: EnumScanResultFieldUpdateOperationsInput | $Enums.ScanResult
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QRScanEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    petId?: NullableStringFieldUpdateOperationsInput | string | null
    scanTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    scannerIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableEnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType | null
    scanLocation?: NullableStringFieldUpdateOperationsInput | string | null
    locationAccuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    scanResult?: EnumScanResultFieldUpdateOperationsInput | $Enums.ScanResult
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetLocationEventCreateInput = {
    id?: string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    accuracy?: Decimal | DecimalJsLike | number | string | null
    scannerIp?: string | null
    userAgent?: string | null
    deviceType?: $Enums.DeviceType | null
    locationName?: string | null
    countryCode?: string | null
    city?: string | null
    state?: string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    pet: PetCreateNestedOneWithoutLocationEventsInput
    qrScanEvent?: QRScanEventCreateNestedOneWithoutLocationEventsInput
  }

  export type PetLocationEventUncheckedCreateInput = {
    id?: string
    petId: string
    qrScanId?: string | null
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    accuracy?: Decimal | DecimalJsLike | number | string | null
    scannerIp?: string | null
    userAgent?: string | null
    deviceType?: $Enums.DeviceType | null
    locationName?: string | null
    countryCode?: string | null
    city?: string | null
    state?: string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PetLocationEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    scannerIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableEnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pet?: PetUpdateOneRequiredWithoutLocationEventsNestedInput
    qrScanEvent?: QRScanEventUpdateOneWithoutLocationEventsNestedInput
  }

  export type PetLocationEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    qrScanId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    scannerIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableEnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetLocationEventCreateManyInput = {
    id?: string
    petId: string
    qrScanId?: string | null
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    accuracy?: Decimal | DecimalJsLike | number | string | null
    scannerIp?: string | null
    userAgent?: string | null
    deviceType?: $Enums.DeviceType | null
    locationName?: string | null
    countryCode?: string | null
    city?: string | null
    state?: string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PetLocationEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    scannerIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableEnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetLocationEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    qrScanId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    scannerIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableEnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    razorpayOrderId?: string | null
    receipt?: string | null
    amountInPaise: bigint | number
    currency?: string
    status?: $Enums.OrderStatus
    notes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    rawOrderPayload?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutOrdersInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    razorpayOrderId?: string | null
    userId: string
    receipt?: string | null
    amountInPaise: bigint | number
    currency?: string
    status?: $Enums.OrderStatus
    notes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    rawOrderPayload?: NullableJsonNullValueInput | InputJsonValue
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    receipt?: NullableStringFieldUpdateOperationsInput | string | null
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawOrderPayload?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    receipt?: NullableStringFieldUpdateOperationsInput | string | null
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawOrderPayload?: NullableJsonNullValueInput | InputJsonValue
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    razorpayOrderId?: string | null
    userId: string
    receipt?: string | null
    amountInPaise: bigint | number
    currency?: string
    status?: $Enums.OrderStatus
    notes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    rawOrderPayload?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    receipt?: NullableStringFieldUpdateOperationsInput | string | null
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawOrderPayload?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    receipt?: NullableStringFieldUpdateOperationsInput | string | null
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawOrderPayload?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PaymentCreateInput = {
    id?: string
    razorpayPaymentId: string
    razorpayOrderId: string
    amountInPaise: bigint | number
    currency?: string
    method?: string | null
    status?: $Enums.PaymentStatusNew
    captured?: boolean
    capturedAt?: Date | string | null
    bank?: string | null
    vpa?: string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    fee?: bigint | number | null
    tax?: bigint | number | null
    currencyConversion?: NullableJsonNullValueInput | InputJsonValue
    signatureValid?: boolean | null
    signatureVerifiedAt?: Date | string | null
    verificationMethod?: $Enums.VerificationMethod | null
    rawPaymentPayload?: NullableJsonNullValueInput | InputJsonValue
    clientMeta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutPaymentsInput
    refunds?: RefundCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    localOrderId: string
    razorpayPaymentId: string
    razorpayOrderId: string
    amountInPaise: bigint | number
    currency?: string
    method?: string | null
    status?: $Enums.PaymentStatusNew
    captured?: boolean
    capturedAt?: Date | string | null
    bank?: string | null
    vpa?: string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    fee?: bigint | number | null
    tax?: bigint | number | null
    currencyConversion?: NullableJsonNullValueInput | InputJsonValue
    signatureValid?: boolean | null
    signatureVerifiedAt?: Date | string | null
    verificationMethod?: $Enums.VerificationMethod | null
    rawPaymentPayload?: NullableJsonNullValueInput | InputJsonValue
    clientMeta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    refunds?: RefundUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayPaymentId?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: StringFieldUpdateOperationsInput | string
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusNewFieldUpdateOperationsInput | $Enums.PaymentStatusNew
    captured?: BoolFieldUpdateOperationsInput | boolean
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bank?: NullableStringFieldUpdateOperationsInput | string | null
    vpa?: NullableStringFieldUpdateOperationsInput | string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    fee?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currencyConversion?: NullableJsonNullValueInput | InputJsonValue
    signatureValid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    signatureVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableEnumVerificationMethodFieldUpdateOperationsInput | $Enums.VerificationMethod | null
    rawPaymentPayload?: NullableJsonNullValueInput | InputJsonValue
    clientMeta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutPaymentsNestedInput
    refunds?: RefundUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    localOrderId?: StringFieldUpdateOperationsInput | string
    razorpayPaymentId?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: StringFieldUpdateOperationsInput | string
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusNewFieldUpdateOperationsInput | $Enums.PaymentStatusNew
    captured?: BoolFieldUpdateOperationsInput | boolean
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bank?: NullableStringFieldUpdateOperationsInput | string | null
    vpa?: NullableStringFieldUpdateOperationsInput | string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    fee?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currencyConversion?: NullableJsonNullValueInput | InputJsonValue
    signatureValid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    signatureVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableEnumVerificationMethodFieldUpdateOperationsInput | $Enums.VerificationMethod | null
    rawPaymentPayload?: NullableJsonNullValueInput | InputJsonValue
    clientMeta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refunds?: RefundUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: string
    localOrderId: string
    razorpayPaymentId: string
    razorpayOrderId: string
    amountInPaise: bigint | number
    currency?: string
    method?: string | null
    status?: $Enums.PaymentStatusNew
    captured?: boolean
    capturedAt?: Date | string | null
    bank?: string | null
    vpa?: string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    fee?: bigint | number | null
    tax?: bigint | number | null
    currencyConversion?: NullableJsonNullValueInput | InputJsonValue
    signatureValid?: boolean | null
    signatureVerifiedAt?: Date | string | null
    verificationMethod?: $Enums.VerificationMethod | null
    rawPaymentPayload?: NullableJsonNullValueInput | InputJsonValue
    clientMeta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayPaymentId?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: StringFieldUpdateOperationsInput | string
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusNewFieldUpdateOperationsInput | $Enums.PaymentStatusNew
    captured?: BoolFieldUpdateOperationsInput | boolean
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bank?: NullableStringFieldUpdateOperationsInput | string | null
    vpa?: NullableStringFieldUpdateOperationsInput | string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    fee?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currencyConversion?: NullableJsonNullValueInput | InputJsonValue
    signatureValid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    signatureVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableEnumVerificationMethodFieldUpdateOperationsInput | $Enums.VerificationMethod | null
    rawPaymentPayload?: NullableJsonNullValueInput | InputJsonValue
    clientMeta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    localOrderId?: StringFieldUpdateOperationsInput | string
    razorpayPaymentId?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: StringFieldUpdateOperationsInput | string
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusNewFieldUpdateOperationsInput | $Enums.PaymentStatusNew
    captured?: BoolFieldUpdateOperationsInput | boolean
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bank?: NullableStringFieldUpdateOperationsInput | string | null
    vpa?: NullableStringFieldUpdateOperationsInput | string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    fee?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currencyConversion?: NullableJsonNullValueInput | InputJsonValue
    signatureValid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    signatureVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableEnumVerificationMethodFieldUpdateOperationsInput | $Enums.VerificationMethod | null
    rawPaymentPayload?: NullableJsonNullValueInput | InputJsonValue
    clientMeta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundCreateInput = {
    id?: string
    razorpayRefundId?: string | null
    amountInPaise: bigint | number
    refundAmount?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    initiatedBy?: string | null
    status?: $Enums.RefundStatus
    processedAt?: Date | string | null
    rawRefundPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    payment: PaymentCreateNestedOneWithoutRefundsInput
    paymentEvent?: PaymentEventCreateNestedOneWithoutRefundsInput
  }

  export type RefundUncheckedCreateInput = {
    id?: string
    razorpayRefundId?: string | null
    razorpayPaymentId: string
    paymentEventId?: string | null
    amountInPaise: bigint | number
    refundAmount?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    initiatedBy?: string | null
    status?: $Enums.RefundStatus
    processedAt?: Date | string | null
    rawRefundPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type RefundUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    refundAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    initiatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawRefundPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutRefundsNestedInput
    paymentEvent?: PaymentEventUpdateOneWithoutRefundsNestedInput
  }

  export type RefundUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: StringFieldUpdateOperationsInput | string
    paymentEventId?: NullableStringFieldUpdateOperationsInput | string | null
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    refundAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    initiatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawRefundPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundCreateManyInput = {
    id?: string
    razorpayRefundId?: string | null
    razorpayPaymentId: string
    paymentEventId?: string | null
    amountInPaise: bigint | number
    refundAmount?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    initiatedBy?: string | null
    status?: $Enums.RefundStatus
    processedAt?: Date | string | null
    rawRefundPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type RefundUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    refundAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    initiatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawRefundPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: StringFieldUpdateOperationsInput | string
    paymentEventId?: NullableStringFieldUpdateOperationsInput | string | null
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    refundAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    initiatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawRefundPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEventCreateInput = {
    id?: string
    razorpayEventId?: string | null
    eventType: string
    rawEvent: JsonNullValueInput | InputJsonValue
    headers?: NullableJsonNullValueInput | InputJsonValue
    signatureValid: boolean
    receivedAt?: Date | string
    processedAt?: Date | string | null
    processingResult?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WebhookEventUncheckedCreateInput = {
    id?: string
    razorpayEventId?: string | null
    eventType: string
    rawEvent: JsonNullValueInput | InputJsonValue
    headers?: NullableJsonNullValueInput | InputJsonValue
    signatureValid: boolean
    receivedAt?: Date | string
    processedAt?: Date | string | null
    processingResult?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WebhookEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayEventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    rawEvent?: JsonNullValueInput | InputJsonValue
    headers?: NullableJsonNullValueInput | InputJsonValue
    signatureValid?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingResult?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WebhookEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayEventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    rawEvent?: JsonNullValueInput | InputJsonValue
    headers?: NullableJsonNullValueInput | InputJsonValue
    signatureValid?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingResult?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WebhookEventCreateManyInput = {
    id?: string
    razorpayEventId?: string | null
    eventType: string
    rawEvent: JsonNullValueInput | InputJsonValue
    headers?: NullableJsonNullValueInput | InputJsonValue
    signatureValid: boolean
    receivedAt?: Date | string
    processedAt?: Date | string | null
    processingResult?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WebhookEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayEventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    rawEvent?: JsonNullValueInput | InputJsonValue
    headers?: NullableJsonNullValueInput | InputJsonValue
    signatureValid?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingResult?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WebhookEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayEventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    rawEvent?: JsonNullValueInput | InputJsonValue
    headers?: NullableJsonNullValueInput | InputJsonValue
    signatureValid?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingResult?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PaymentWebhookCreateInput = {
    id?: string
    eventId?: string | null
    eventType: string
    entityType: string
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    signature: string
    signatureVerified: boolean
    processed?: boolean
    processedAt?: Date | string | null
    processingAttempts?: number
    createdAt?: Date | string
  }

  export type PaymentWebhookUncheckedCreateInput = {
    id?: string
    eventId?: string | null
    eventType: string
    entityType: string
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    signature: string
    signatureVerified: boolean
    processed?: boolean
    processedAt?: Date | string | null
    processingAttempts?: number
    createdAt?: Date | string
  }

  export type PaymentWebhookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    signature?: StringFieldUpdateOperationsInput | string
    signatureVerified?: BoolFieldUpdateOperationsInput | boolean
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentWebhookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    signature?: StringFieldUpdateOperationsInput | string
    signatureVerified?: BoolFieldUpdateOperationsInput | boolean
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentWebhookCreateManyInput = {
    id?: string
    eventId?: string | null
    eventType: string
    entityType: string
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    signature: string
    signatureVerified: boolean
    processed?: boolean
    processedAt?: Date | string | null
    processingAttempts?: number
    createdAt?: Date | string
  }

  export type PaymentWebhookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    signature?: StringFieldUpdateOperationsInput | string
    signatureVerified?: BoolFieldUpdateOperationsInput | boolean
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentWebhookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    signature?: StringFieldUpdateOperationsInput | string
    signatureVerified?: BoolFieldUpdateOperationsInput | boolean
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentEventCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentPurpose: $Enums.PaymentPurpose
    status?: $Enums.PaymentStatus
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    razorpaySignature?: string | null
    paymentMethod?: string | null
    failureReason?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    pet?: PetCreateNestedOneWithoutPaymentEventsInput
    qrCode?: QRCodeCreateNestedOneWithoutPaymentEventsInput
    user?: UserCreateNestedOneWithoutPaymentEventsInput
    refunds?: RefundCreateNestedManyWithoutPaymentEventInput
  }

  export type PaymentEventUncheckedCreateInput = {
    id?: string
    userId?: string | null
    petId?: string | null
    qrId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentPurpose: $Enums.PaymentPurpose
    status?: $Enums.PaymentStatus
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    razorpaySignature?: string | null
    paymentMethod?: string | null
    failureReason?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    refunds?: RefundUncheckedCreateNestedManyWithoutPaymentEventInput
  }

  export type PaymentEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentPurpose?: EnumPaymentPurposeFieldUpdateOperationsInput | $Enums.PaymentPurpose
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pet?: PetUpdateOneWithoutPaymentEventsNestedInput
    qrCode?: QRCodeUpdateOneWithoutPaymentEventsNestedInput
    user?: UserUpdateOneWithoutPaymentEventsNestedInput
    refunds?: RefundUpdateManyWithoutPaymentEventNestedInput
  }

  export type PaymentEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    petId?: NullableStringFieldUpdateOperationsInput | string | null
    qrId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentPurpose?: EnumPaymentPurposeFieldUpdateOperationsInput | $Enums.PaymentPurpose
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refunds?: RefundUncheckedUpdateManyWithoutPaymentEventNestedInput
  }

  export type PaymentEventCreateManyInput = {
    id?: string
    userId?: string | null
    petId?: string | null
    qrId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentPurpose: $Enums.PaymentPurpose
    status?: $Enums.PaymentStatus
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    razorpaySignature?: string | null
    paymentMethod?: string | null
    failureReason?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type PaymentEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentPurpose?: EnumPaymentPurposeFieldUpdateOperationsInput | $Enums.PaymentPurpose
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    petId?: NullableStringFieldUpdateOperationsInput | string | null
    qrId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentPurpose?: EnumPaymentPurposeFieldUpdateOperationsInput | $Enums.PaymentPurpose
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LocationTrackCreateInput = {
    id?: string
    locationType: $Enums.LocationType
    position?: string | null
    accuracy?: Decimal | DecimalJsLike | number | string | null
    locationName?: string | null
    countryCode?: string | null
    state?: string | null
    city?: string | null
    ipAddress?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    user?: UserCreateNestedOneWithoutLocationTracksInput
  }

  export type LocationTrackUncheckedCreateInput = {
    id?: string
    userId?: string | null
    locationType: $Enums.LocationType
    position?: string | null
    accuracy?: Decimal | DecimalJsLike | number | string | null
    locationName?: string | null
    countryCode?: string | null
    state?: string | null
    city?: string | null
    ipAddress?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type LocationTrackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    position?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutLocationTracksNestedInput
  }

  export type LocationTrackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    position?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationTrackCreateManyInput = {
    id?: string
    userId?: string | null
    locationType: $Enums.LocationType
    position?: string | null
    accuracy?: Decimal | DecimalJsLike | number | string | null
    locationName?: string | null
    countryCode?: string | null
    state?: string | null
    city?: string | null
    ipAddress?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type LocationTrackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    position?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationTrackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    position?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateInput = {
    pushEnabled?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    scanNotifications?: boolean
    marketingNotifications?: boolean
    quietHoursStart?: Date | string | null
    quietHoursEnd?: Date | string | null
    timezone?: string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationPrefsInput
  }

  export type NotificationPreferenceUncheckedCreateInput = {
    userId: string
    pushEnabled?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    scanNotifications?: boolean
    marketingNotifications?: boolean
    quietHoursStart?: Date | string | null
    quietHoursEnd?: Date | string | null
    timezone?: string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateInput = {
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    scanNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingNotifications?: BoolFieldUpdateOperationsInput | boolean
    quietHoursStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quietHoursEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationPrefsNestedInput
  }

  export type NotificationPreferenceUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    scanNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingNotifications?: BoolFieldUpdateOperationsInput | boolean
    quietHoursStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quietHoursEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateManyInput = {
    userId: string
    pushEnabled?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    scanNotifications?: boolean
    marketingNotifications?: boolean
    quietHoursStart?: Date | string | null
    quietHoursEnd?: Date | string | null
    timezone?: string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateManyMutationInput = {
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    scanNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingNotifications?: BoolFieldUpdateOperationsInput | boolean
    quietHoursStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quietHoursEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    scanNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingNotifications?: BoolFieldUpdateOperationsInput | boolean
    quietHoursStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quietHoursEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    qrScanId?: string | null
    notificationType: $Enums.NotificationType
    title: string
    message: string
    channels?: NotificationCreatechannelsInput | string[]
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    sentAt?: Date | string | null
    readAt?: Date | string | null
    pet?: PetCreateNestedOneWithoutNotificationsInput
    user?: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId?: string | null
    petId?: string | null
    qrScanId?: string | null
    notificationType: $Enums.NotificationType
    title: string
    message: string
    channels?: NotificationCreatechannelsInput | string[]
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    sentAt?: Date | string | null
    readAt?: Date | string | null
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrScanId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    channels?: NotificationUpdatechannelsInput | string[]
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pet?: PetUpdateOneWithoutNotificationsNestedInput
    user?: UserUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    petId?: NullableStringFieldUpdateOperationsInput | string | null
    qrScanId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    channels?: NotificationUpdatechannelsInput | string[]
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId?: string | null
    petId?: string | null
    qrScanId?: string | null
    notificationType: $Enums.NotificationType
    title: string
    message: string
    channels?: NotificationCreatechannelsInput | string[]
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    sentAt?: Date | string | null
    readAt?: Date | string | null
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrScanId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    channels?: NotificationUpdatechannelsInput | string[]
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    petId?: NullableStringFieldUpdateOperationsInput | string | null
    qrScanId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    channels?: NotificationUpdatechannelsInput | string[]
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeviceTokenCreateInput = {
    id?: string
    deviceToken: string
    platform: $Enums.Platform
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    lastUsedAt?: Date | string
    user: UserCreateNestedOneWithoutDeviceTokensInput
  }

  export type DeviceTokenUncheckedCreateInput = {
    id?: string
    userId: string
    deviceToken: string
    platform: $Enums.Platform
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type DeviceTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceToken?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDeviceTokensNestedInput
  }

  export type DeviceTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceToken?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenCreateManyInput = {
    id?: string
    userId: string
    deviceToken: string
    platform: $Enums.Platform
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type DeviceTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceToken?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceToken?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketCreateInput = {
    id?: string
    ticketNumber: string
    subject: string
    description: string
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    messages?: SupportMessageCreateNestedManyWithoutTicketInput
    assignedToUser?: UserCreateNestedOneWithoutAssignedTicketsInput
    pet?: PetCreateNestedOneWithoutSupportTicketsInput
    user?: UserCreateNestedOneWithoutSupportTicketsInput
  }

  export type SupportTicketUncheckedCreateInput = {
    id?: string
    ticketNumber: string
    userId?: string | null
    petId?: string | null
    subject: string
    description: string
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    assignedTo?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    messages?: SupportMessageUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: SupportMessageUpdateManyWithoutTicketNestedInput
    assignedToUser?: UserUpdateOneWithoutAssignedTicketsNestedInput
    pet?: PetUpdateOneWithoutSupportTicketsNestedInput
    user?: UserUpdateOneWithoutSupportTicketsNestedInput
  }

  export type SupportTicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    petId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: SupportMessageUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketCreateManyInput = {
    id?: string
    ticketNumber: string
    userId?: string | null
    petId?: string | null
    subject: string
    description: string
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    assignedTo?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type SupportTicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupportTicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    petId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupportMessageCreateInput = {
    id?: string
    senderType: $Enums.SenderType
    message: string
    attachments?: SupportMessageCreateattachmentsInput | string[]
    isInternal?: boolean
    createdAt?: Date | string
    sender?: UserCreateNestedOneWithoutSupportMessagesInput
    ticket: SupportTicketCreateNestedOneWithoutMessagesInput
  }

  export type SupportMessageUncheckedCreateInput = {
    id?: string
    ticketId: string
    senderId?: string | null
    senderType: $Enums.SenderType
    message: string
    attachments?: SupportMessageCreateattachmentsInput | string[]
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type SupportMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    message?: StringFieldUpdateOperationsInput | string
    attachments?: SupportMessageUpdateattachmentsInput | string[]
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneWithoutSupportMessagesNestedInput
    ticket?: SupportTicketUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type SupportMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    message?: StringFieldUpdateOperationsInput | string
    attachments?: SupportMessageUpdateattachmentsInput | string[]
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportMessageCreateManyInput = {
    id?: string
    ticketId: string
    senderId?: string | null
    senderType: $Enums.SenderType
    message: string
    attachments?: SupportMessageCreateattachmentsInput | string[]
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type SupportMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    message?: StringFieldUpdateOperationsInput | string
    attachments?: SupportMessageUpdateattachmentsInput | string[]
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    message?: StringFieldUpdateOperationsInput | string
    attachments?: SupportMessageUpdateattachmentsInput | string[]
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    tableName: string
    recordId: string
    operationType: $Enums.OperationType
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedColumns?: AuditLogCreatechangedColumnsInput | string[]
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    tableName: string
    recordId: string
    operationType: $Enums.OperationType
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedColumns?: AuditLogCreatechangedColumnsInput | string[]
    userId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    operationType?: EnumOperationTypeFieldUpdateOperationsInput | $Enums.OperationType
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedColumns?: AuditLogUpdatechangedColumnsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    operationType?: EnumOperationTypeFieldUpdateOperationsInput | $Enums.OperationType
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedColumns?: AuditLogUpdatechangedColumnsInput | string[]
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    tableName: string
    recordId: string
    operationType: $Enums.OperationType
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedColumns?: AuditLogCreatechangedColumnsInput | string[]
    userId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    operationType?: EnumOperationTypeFieldUpdateOperationsInput | $Enums.OperationType
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedColumns?: AuditLogUpdatechangedColumnsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    operationType?: EnumOperationTypeFieldUpdateOperationsInput | $Enums.OperationType
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedColumns?: AuditLogUpdatechangedColumnsInput | string[]
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemAnalyticsCreateInput = {
    id?: string
    metricName: string
    metricValue?: Decimal | DecimalJsLike | number | string | null
    metricUnit?: string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type SystemAnalyticsUncheckedCreateInput = {
    id?: string
    metricName: string
    metricValue?: Decimal | DecimalJsLike | number | string | null
    metricUnit?: string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type SystemAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metricUnit?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metricUnit?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemAnalyticsCreateManyInput = {
    id?: string
    metricName: string
    metricValue?: Decimal | DecimalJsLike | number | string | null
    metricUnit?: string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type SystemAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metricUnit?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metricUnit?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetRegistrationApplicationCreateInput = {
    id?: string
    applicationType: $Enums.ApplicationType
    identifierType: $Enums.IdentifierType
    identifierNumber?: string | null
    submittedAt: Date | string
    city: string
    state: string
    country: string
    applicantType: $Enums.ApplicantType
    applicantName: string
    fatherOrHusbandName?: string | null
    applicantEmail: string
    applicantPhone: string
    aadhaarNumber?: string | null
    pincode: string
    address: string
    hasTokenNumber?: boolean
    declarationAcknowledgement: string
    acceptedTerms?: boolean
    registrationFee: Decimal | DecimalJsLike | number | string
    convenienceFee: Decimal | DecimalJsLike | number | string
    gst: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    deliveryAddressLine: string
    deliveryCity: string
    deliveryState: string
    deliveryPincode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: ApplicationDocumentCreateNestedManyWithoutApplicationInput
    checkoutItems?: CheckoutItemCreateNestedManyWithoutApplicationInput
    pets?: RegisteredPetCreateNestedManyWithoutApplicationInput
  }

  export type PetRegistrationApplicationUncheckedCreateInput = {
    id?: string
    applicationType: $Enums.ApplicationType
    identifierType: $Enums.IdentifierType
    identifierNumber?: string | null
    submittedAt: Date | string
    city: string
    state: string
    country: string
    applicantType: $Enums.ApplicantType
    applicantName: string
    fatherOrHusbandName?: string | null
    applicantEmail: string
    applicantPhone: string
    aadhaarNumber?: string | null
    pincode: string
    address: string
    hasTokenNumber?: boolean
    declarationAcknowledgement: string
    acceptedTerms?: boolean
    registrationFee: Decimal | DecimalJsLike | number | string
    convenienceFee: Decimal | DecimalJsLike | number | string
    gst: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    deliveryAddressLine: string
    deliveryCity: string
    deliveryState: string
    deliveryPincode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: ApplicationDocumentUncheckedCreateNestedManyWithoutApplicationInput
    checkoutItems?: CheckoutItemUncheckedCreateNestedManyWithoutApplicationInput
    pets?: RegisteredPetUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type PetRegistrationApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationType?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    identifierType?: EnumIdentifierTypeFieldUpdateOperationsInput | $Enums.IdentifierType
    identifierNumber?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    applicantName?: StringFieldUpdateOperationsInput | string
    fatherOrHusbandName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantEmail?: StringFieldUpdateOperationsInput | string
    applicantPhone?: StringFieldUpdateOperationsInput | string
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    hasTokenNumber?: BoolFieldUpdateOperationsInput | boolean
    declarationAcknowledgement?: StringFieldUpdateOperationsInput | string
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    convenienceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    deliveryAddressLine?: StringFieldUpdateOperationsInput | string
    deliveryCity?: StringFieldUpdateOperationsInput | string
    deliveryState?: StringFieldUpdateOperationsInput | string
    deliveryPincode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: ApplicationDocumentUpdateManyWithoutApplicationNestedInput
    checkoutItems?: CheckoutItemUpdateManyWithoutApplicationNestedInput
    pets?: RegisteredPetUpdateManyWithoutApplicationNestedInput
  }

  export type PetRegistrationApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationType?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    identifierType?: EnumIdentifierTypeFieldUpdateOperationsInput | $Enums.IdentifierType
    identifierNumber?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    applicantName?: StringFieldUpdateOperationsInput | string
    fatherOrHusbandName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantEmail?: StringFieldUpdateOperationsInput | string
    applicantPhone?: StringFieldUpdateOperationsInput | string
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    hasTokenNumber?: BoolFieldUpdateOperationsInput | boolean
    declarationAcknowledgement?: StringFieldUpdateOperationsInput | string
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    convenienceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    deliveryAddressLine?: StringFieldUpdateOperationsInput | string
    deliveryCity?: StringFieldUpdateOperationsInput | string
    deliveryState?: StringFieldUpdateOperationsInput | string
    deliveryPincode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: ApplicationDocumentUncheckedUpdateManyWithoutApplicationNestedInput
    checkoutItems?: CheckoutItemUncheckedUpdateManyWithoutApplicationNestedInput
    pets?: RegisteredPetUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type PetRegistrationApplicationCreateManyInput = {
    id?: string
    applicationType: $Enums.ApplicationType
    identifierType: $Enums.IdentifierType
    identifierNumber?: string | null
    submittedAt: Date | string
    city: string
    state: string
    country: string
    applicantType: $Enums.ApplicantType
    applicantName: string
    fatherOrHusbandName?: string | null
    applicantEmail: string
    applicantPhone: string
    aadhaarNumber?: string | null
    pincode: string
    address: string
    hasTokenNumber?: boolean
    declarationAcknowledgement: string
    acceptedTerms?: boolean
    registrationFee: Decimal | DecimalJsLike | number | string
    convenienceFee: Decimal | DecimalJsLike | number | string
    gst: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    deliveryAddressLine: string
    deliveryCity: string
    deliveryState: string
    deliveryPincode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PetRegistrationApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationType?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    identifierType?: EnumIdentifierTypeFieldUpdateOperationsInput | $Enums.IdentifierType
    identifierNumber?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    applicantName?: StringFieldUpdateOperationsInput | string
    fatherOrHusbandName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantEmail?: StringFieldUpdateOperationsInput | string
    applicantPhone?: StringFieldUpdateOperationsInput | string
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    hasTokenNumber?: BoolFieldUpdateOperationsInput | boolean
    declarationAcknowledgement?: StringFieldUpdateOperationsInput | string
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    convenienceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    deliveryAddressLine?: StringFieldUpdateOperationsInput | string
    deliveryCity?: StringFieldUpdateOperationsInput | string
    deliveryState?: StringFieldUpdateOperationsInput | string
    deliveryPincode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetRegistrationApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationType?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    identifierType?: EnumIdentifierTypeFieldUpdateOperationsInput | $Enums.IdentifierType
    identifierNumber?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    applicantName?: StringFieldUpdateOperationsInput | string
    fatherOrHusbandName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantEmail?: StringFieldUpdateOperationsInput | string
    applicantPhone?: StringFieldUpdateOperationsInput | string
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    hasTokenNumber?: BoolFieldUpdateOperationsInput | boolean
    declarationAcknowledgement?: StringFieldUpdateOperationsInput | string
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    convenienceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    deliveryAddressLine?: StringFieldUpdateOperationsInput | string
    deliveryCity?: StringFieldUpdateOperationsInput | string
    deliveryState?: StringFieldUpdateOperationsInput | string
    deliveryPincode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegisteredPetCreateInput = {
    id?: string
    petName: string
    breed: string
    dateOfBirth: Date | string
    ageOnRegistration: string
    lastRabiesVaccinationDate: Date | string
    veterinaryDoctorName: string
    veterinaryDoctorRegNumber: string
    veterinaryClinicOrHospitalName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gender: $Enums.Gender
    documents?: PetDocumentCreateNestedManyWithoutPetInput
    application: PetRegistrationApplicationCreateNestedOneWithoutPetsInput
  }

  export type RegisteredPetUncheckedCreateInput = {
    id?: string
    applicationId: string
    petName: string
    breed: string
    dateOfBirth: Date | string
    ageOnRegistration: string
    lastRabiesVaccinationDate: Date | string
    veterinaryDoctorName: string
    veterinaryDoctorRegNumber: string
    veterinaryClinicOrHospitalName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gender: $Enums.Gender
    documents?: PetDocumentUncheckedCreateNestedManyWithoutPetInput
  }

  export type RegisteredPetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    petName?: StringFieldUpdateOperationsInput | string
    breed?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    ageOnRegistration?: StringFieldUpdateOperationsInput | string
    lastRabiesVaccinationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    veterinaryDoctorName?: StringFieldUpdateOperationsInput | string
    veterinaryDoctorRegNumber?: StringFieldUpdateOperationsInput | string
    veterinaryClinicOrHospitalName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    documents?: PetDocumentUpdateManyWithoutPetNestedInput
    application?: PetRegistrationApplicationUpdateOneRequiredWithoutPetsNestedInput
  }

  export type RegisteredPetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    petName?: StringFieldUpdateOperationsInput | string
    breed?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    ageOnRegistration?: StringFieldUpdateOperationsInput | string
    lastRabiesVaccinationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    veterinaryDoctorName?: StringFieldUpdateOperationsInput | string
    veterinaryDoctorRegNumber?: StringFieldUpdateOperationsInput | string
    veterinaryClinicOrHospitalName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    documents?: PetDocumentUncheckedUpdateManyWithoutPetNestedInput
  }

  export type RegisteredPetCreateManyInput = {
    id?: string
    applicationId: string
    petName: string
    breed: string
    dateOfBirth: Date | string
    ageOnRegistration: string
    lastRabiesVaccinationDate: Date | string
    veterinaryDoctorName: string
    veterinaryDoctorRegNumber: string
    veterinaryClinicOrHospitalName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gender: $Enums.Gender
  }

  export type RegisteredPetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    petName?: StringFieldUpdateOperationsInput | string
    breed?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    ageOnRegistration?: StringFieldUpdateOperationsInput | string
    lastRabiesVaccinationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    veterinaryDoctorName?: StringFieldUpdateOperationsInput | string
    veterinaryDoctorRegNumber?: StringFieldUpdateOperationsInput | string
    veterinaryClinicOrHospitalName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
  }

  export type RegisteredPetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    petName?: StringFieldUpdateOperationsInput | string
    breed?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    ageOnRegistration?: StringFieldUpdateOperationsInput | string
    lastRabiesVaccinationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    veterinaryDoctorName?: StringFieldUpdateOperationsInput | string
    veterinaryDoctorRegNumber?: StringFieldUpdateOperationsInput | string
    veterinaryClinicOrHospitalName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
  }

  export type ApplicationDocumentCreateInput = {
    id?: string
    documentType: $Enums.DocumentType
    fileName: string
    filePath: string
    mimeType: string
    sizeBytes: bigint | number
    createdAt?: Date | string
    application: PetRegistrationApplicationCreateNestedOneWithoutDocumentsInput
  }

  export type ApplicationDocumentUncheckedCreateInput = {
    id?: string
    applicationId: string
    documentType: $Enums.DocumentType
    fileName: string
    filePath: string
    mimeType: string
    sizeBytes: bigint | number
    createdAt?: Date | string
  }

  export type ApplicationDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: PetRegistrationApplicationUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type ApplicationDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationDocumentCreateManyInput = {
    id?: string
    applicationId: string
    documentType: $Enums.DocumentType
    fileName: string
    filePath: string
    mimeType: string
    sizeBytes: bigint | number
    createdAt?: Date | string
  }

  export type ApplicationDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetDocumentCreateInput = {
    id?: string
    documentType: $Enums.DocumentType
    fileName: string
    filePath: string
    mimeType: string
    sizeBytes: bigint | number
    createdAt?: Date | string
    pet: RegisteredPetCreateNestedOneWithoutDocumentsInput
  }

  export type PetDocumentUncheckedCreateInput = {
    id?: string
    petId: string
    documentType: $Enums.DocumentType
    fileName: string
    filePath: string
    mimeType: string
    sizeBytes: bigint | number
    createdAt?: Date | string
  }

  export type PetDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pet?: RegisteredPetUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type PetDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetDocumentCreateManyInput = {
    id?: string
    petId: string
    documentType: $Enums.DocumentType
    fileName: string
    filePath: string
    mimeType: string
    sizeBytes: bigint | number
    createdAt?: Date | string
  }

  export type PetDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckoutItemCreateInput = {
    id?: string
    sku: string
    itemName: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    application: PetRegistrationApplicationCreateNestedOneWithoutCheckoutItemsInput
  }

  export type CheckoutItemUncheckedCreateInput = {
    id?: string
    applicationId: string
    sku: string
    itemName: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CheckoutItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: PetRegistrationApplicationUpdateOneRequiredWithoutCheckoutItemsNestedInput
  }

  export type CheckoutItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckoutItemCreateManyInput = {
    id?: string
    applicationId: string
    sku: string
    itemName: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CheckoutItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckoutItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumAuthProviderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel> | null
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAuthProviderNullableFilter<$PrismaModel> | $Enums.AuthProvider | null
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type DeviceTokenListRelationFilter = {
    every?: DeviceTokenWhereInput
    some?: DeviceTokenWhereInput
    none?: DeviceTokenWhereInput
  }

  export type ExecutiveNullableScalarRelationFilter = {
    is?: ExecutiveWhereInput | null
    isNot?: ExecutiveWhereInput | null
  }

  export type LocationTrackListRelationFilter = {
    every?: LocationTrackWhereInput
    some?: LocationTrackWhereInput
    none?: LocationTrackWhereInput
  }

  export type NotificationPreferenceNullableScalarRelationFilter = {
    is?: NotificationPreferenceWhereInput | null
    isNot?: NotificationPreferenceWhereInput | null
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type OTPCodeListRelationFilter = {
    every?: OTPCodeWhereInput
    some?: OTPCodeWhereInput
    none?: OTPCodeWhereInput
  }

  export type PaymentEventListRelationFilter = {
    every?: PaymentEventWhereInput
    some?: PaymentEventWhereInput
    none?: PaymentEventWhereInput
  }

  export type PetOwnerNullableScalarRelationFilter = {
    is?: PetOwnerWhereInput | null
    isNot?: PetOwnerWhereInput | null
  }

  export type PetListRelationFilter = {
    every?: PetWhereInput
    some?: PetWhereInput
    none?: PetWhereInput
  }

  export type SupportMessageListRelationFilter = {
    every?: SupportMessageWhereInput
    some?: SupportMessageWhereInput
    none?: SupportMessageWhereInput
  }

  export type SupportTicketListRelationFilter = {
    every?: SupportTicketWhereInput
    some?: SupportTicketWhereInput
    none?: SupportTicketWhereInput
  }

  export type UserSessionListRelationFilter = {
    every?: UserSessionWhereInput
    some?: UserSessionWhereInput
    none?: UserSessionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationTrackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OTPCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupportMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupportTicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    googleId?: SortOrder
    appleId?: SortOrder
    profilePicture?: SortOrder
    authProvider?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    googleId?: SortOrder
    appleId?: SortOrder
    profilePicture?: SortOrder
    authProvider?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    googleId?: SortOrder
    appleId?: SortOrder
    profilePicture?: SortOrder
    authProvider?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumAuthProviderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel> | null
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAuthProviderNullableWithAggregatesFilter<$PrismaModel> | $Enums.AuthProvider | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAuthProviderNullableFilter<$PrismaModel>
    _max?: NestedEnumAuthProviderNullableFilter<$PrismaModel>
  }

  export type EnumOTPPurposeFilter<$PrismaModel = never> = {
    equals?: $Enums.OTPPurpose | EnumOTPPurposeFieldRefInput<$PrismaModel>
    in?: $Enums.OTPPurpose[] | ListEnumOTPPurposeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OTPPurpose[] | ListEnumOTPPurposeFieldRefInput<$PrismaModel>
    not?: NestedEnumOTPPurposeFilter<$PrismaModel> | $Enums.OTPPurpose
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type OTPCodeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    purpose?: SortOrder
    deliveryMethod?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    attemptsCount?: SortOrder
    maxAttempts?: SortOrder
    createdAt?: SortOrder
  }

  export type OTPCodeAvgOrderByAggregateInput = {
    attemptsCount?: SortOrder
    maxAttempts?: SortOrder
  }

  export type OTPCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    purpose?: SortOrder
    deliveryMethod?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    attemptsCount?: SortOrder
    maxAttempts?: SortOrder
    createdAt?: SortOrder
  }

  export type OTPCodeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    purpose?: SortOrder
    deliveryMethod?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    attemptsCount?: SortOrder
    maxAttempts?: SortOrder
    createdAt?: SortOrder
  }

  export type OTPCodeSumOrderByAggregateInput = {
    attemptsCount?: SortOrder
    maxAttempts?: SortOrder
  }

  export type EnumOTPPurposeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OTPPurpose | EnumOTPPurposeFieldRefInput<$PrismaModel>
    in?: $Enums.OTPPurpose[] | ListEnumOTPPurposeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OTPPurpose[] | ListEnumOTPPurposeFieldRefInput<$PrismaModel>
    not?: NestedEnumOTPPurposeWithAggregatesFilter<$PrismaModel> | $Enums.OTPPurpose
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOTPPurposeFilter<$PrismaModel>
    _max?: NestedEnumOTPPurposeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenHash?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenHash?: SortOrder
    ipAddress?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenHash?: SortOrder
    ipAddress?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ExecutiveCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrder
    territory?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ExecutiveMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrder
    territory?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ExecutiveMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrder
    territory?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type PetOwnerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    countryCode?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PetOwnerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    countryCode?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PetOwnerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    countryCode?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PetBreedListRelationFilter = {
    every?: PetBreedWhereInput
    some?: PetBreedWhereInput
    none?: PetBreedWhereInput
  }

  export type PetBreedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PetSpeciesCountOrderByAggregateInput = {
    id?: SortOrder
    speciesName?: SortOrder
    category?: SortOrder
  }

  export type PetSpeciesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PetSpeciesMaxOrderByAggregateInput = {
    id?: SortOrder
    speciesName?: SortOrder
    category?: SortOrder
  }

  export type PetSpeciesMinOrderByAggregateInput = {
    id?: SortOrder
    speciesName?: SortOrder
    category?: SortOrder
  }

  export type PetSpeciesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumSizeCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SizeCategory | EnumSizeCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.SizeCategory[] | ListEnumSizeCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SizeCategory[] | ListEnumSizeCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSizeCategoryNullableFilter<$PrismaModel> | $Enums.SizeCategory | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PetSpeciesScalarRelationFilter = {
    is?: PetSpeciesWhereInput
    isNot?: PetSpeciesWhereInput
  }

  export type PetBreedCountOrderByAggregateInput = {
    id?: SortOrder
    breedName?: SortOrder
    speciesId?: SortOrder
    sizeCategory?: SortOrder
    typicalLifespanYears?: SortOrder
  }

  export type PetBreedAvgOrderByAggregateInput = {
    id?: SortOrder
    speciesId?: SortOrder
    typicalLifespanYears?: SortOrder
  }

  export type PetBreedMaxOrderByAggregateInput = {
    id?: SortOrder
    breedName?: SortOrder
    speciesId?: SortOrder
    sizeCategory?: SortOrder
    typicalLifespanYears?: SortOrder
  }

  export type PetBreedMinOrderByAggregateInput = {
    id?: SortOrder
    breedName?: SortOrder
    speciesId?: SortOrder
    sizeCategory?: SortOrder
    typicalLifespanYears?: SortOrder
  }

  export type PetBreedSumOrderByAggregateInput = {
    id?: SortOrder
    speciesId?: SortOrder
    typicalLifespanYears?: SortOrder
  }

  export type EnumSizeCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SizeCategory | EnumSizeCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.SizeCategory[] | ListEnumSizeCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SizeCategory[] | ListEnumSizeCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSizeCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.SizeCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSizeCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumSizeCategoryNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type EnumPetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PetStatus | EnumPetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PetStatus[] | ListEnumPetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PetStatus[] | ListEnumPetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPetStatusFilter<$PrismaModel> | $Enums.PetStatus
  }

  export type MedicalRecordListRelationFilter = {
    every?: MedicalRecordWhereInput
    some?: MedicalRecordWhereInput
    none?: MedicalRecordWhereInput
  }

  export type PetLocationEventListRelationFilter = {
    every?: PetLocationEventWhereInput
    some?: PetLocationEventWhereInput
    none?: PetLocationEventWhereInput
  }

  export type QRScanEventListRelationFilter = {
    every?: QRScanEventWhereInput
    some?: QRScanEventWhereInput
    none?: QRScanEventWhereInput
  }

  export type PetBreedNullableScalarRelationFilter = {
    is?: PetBreedWhereInput | null
    isNot?: PetBreedWhereInput | null
  }

  export type PetOwnerScalarRelationFilter = {
    is?: PetOwnerWhereInput
    isNot?: PetOwnerWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PetSpeciesNullableScalarRelationFilter = {
    is?: PetSpeciesWhereInput | null
    isNot?: PetSpeciesWhereInput | null
  }

  export type QRCodeListRelationFilter = {
    every?: QRCodeWhereInput
    some?: QRCodeWhereInput
    none?: QRCodeWhereInput
  }

  export type VaccinationRecordListRelationFilter = {
    every?: VaccinationRecordWhereInput
    some?: VaccinationRecordWhereInput
    none?: VaccinationRecordWhereInput
  }

  export type MedicalRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PetLocationEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QRScanEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QRCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VaccinationRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PetCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    registeredBy?: SortOrder
    name?: SortOrder
    speciesId?: SortOrder
    breed_id?: SortOrder
    secondary_breed_id?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    color?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    distinctiveMarks?: SortOrder
    isSpayedNeutered?: SortOrder
    microchip_id?: SortOrder
    registrationNumber?: SortOrder
    status?: SortOrder
    specialNeeds?: SortOrder
    behavioralNotes?: SortOrder
    profileImageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PetAvgOrderByAggregateInput = {
    speciesId?: SortOrder
    breed_id?: SortOrder
    secondary_breed_id?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
  }

  export type PetMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    registeredBy?: SortOrder
    name?: SortOrder
    speciesId?: SortOrder
    breed_id?: SortOrder
    secondary_breed_id?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    color?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    distinctiveMarks?: SortOrder
    isSpayedNeutered?: SortOrder
    microchip_id?: SortOrder
    registrationNumber?: SortOrder
    status?: SortOrder
    specialNeeds?: SortOrder
    behavioralNotes?: SortOrder
    profileImageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PetMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    registeredBy?: SortOrder
    name?: SortOrder
    speciesId?: SortOrder
    breed_id?: SortOrder
    secondary_breed_id?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    color?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    distinctiveMarks?: SortOrder
    isSpayedNeutered?: SortOrder
    microchip_id?: SortOrder
    registrationNumber?: SortOrder
    status?: SortOrder
    specialNeeds?: SortOrder
    behavioralNotes?: SortOrder
    profileImageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PetSumOrderByAggregateInput = {
    speciesId?: SortOrder
    breed_id?: SortOrder
    secondary_breed_id?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumPetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PetStatus | EnumPetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PetStatus[] | ListEnumPetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PetStatus[] | ListEnumPetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPetStatusWithAggregatesFilter<$PrismaModel> | $Enums.PetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPetStatusFilter<$PrismaModel>
    _max?: NestedEnumPetStatusFilter<$PrismaModel>
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type VaccineTypeCountOrderByAggregateInput = {
    id?: SortOrder
    vaccineName?: SortOrder
    speciesApplicability?: SortOrder
    durationMonths?: SortOrder
    isRequiredByLaw?: SortOrder
  }

  export type VaccineTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    speciesApplicability?: SortOrder
    durationMonths?: SortOrder
  }

  export type VaccineTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    vaccineName?: SortOrder
    durationMonths?: SortOrder
    isRequiredByLaw?: SortOrder
  }

  export type VaccineTypeMinOrderByAggregateInput = {
    id?: SortOrder
    vaccineName?: SortOrder
    durationMonths?: SortOrder
    isRequiredByLaw?: SortOrder
  }

  export type VaccineTypeSumOrderByAggregateInput = {
    id?: SortOrder
    speciesApplicability?: SortOrder
    durationMonths?: SortOrder
  }

  export type PetScalarRelationFilter = {
    is?: PetWhereInput
    isNot?: PetWhereInput
  }

  export type VaccineTypeScalarRelationFilter = {
    is?: VaccineTypeWhereInput
    isNot?: VaccineTypeWhereInput
  }

  export type VaccinationRecordCountOrderByAggregateInput = {
    id?: SortOrder
    petId?: SortOrder
    vaccineTypeId?: SortOrder
    administeredDate?: SortOrder
    expirationDate?: SortOrder
    batchNumber?: SortOrder
    veterinarianName?: SortOrder
    clinicName?: SortOrder
    notes?: SortOrder
    certificateUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type VaccinationRecordAvgOrderByAggregateInput = {
    vaccineTypeId?: SortOrder
  }

  export type VaccinationRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    petId?: SortOrder
    vaccineTypeId?: SortOrder
    administeredDate?: SortOrder
    expirationDate?: SortOrder
    batchNumber?: SortOrder
    veterinarianName?: SortOrder
    clinicName?: SortOrder
    notes?: SortOrder
    certificateUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type VaccinationRecordMinOrderByAggregateInput = {
    id?: SortOrder
    petId?: SortOrder
    vaccineTypeId?: SortOrder
    administeredDate?: SortOrder
    expirationDate?: SortOrder
    batchNumber?: SortOrder
    veterinarianName?: SortOrder
    clinicName?: SortOrder
    notes?: SortOrder
    certificateUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type VaccinationRecordSumOrderByAggregateInput = {
    vaccineTypeId?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type MedicalRecordCountOrderByAggregateInput = {
    id?: SortOrder
    petId?: SortOrder
    visitDate?: SortOrder
    veterinarianName?: SortOrder
    clinicName?: SortOrder
    diagnosis?: SortOrder
    treatment?: SortOrder
    medications?: SortOrder
    followUpRequired?: SortOrder
    followUpDate?: SortOrder
    cost?: SortOrder
    documentUrls?: SortOrder
    createdAt?: SortOrder
  }

  export type MedicalRecordAvgOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type MedicalRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    petId?: SortOrder
    visitDate?: SortOrder
    veterinarianName?: SortOrder
    clinicName?: SortOrder
    diagnosis?: SortOrder
    treatment?: SortOrder
    followUpRequired?: SortOrder
    followUpDate?: SortOrder
    cost?: SortOrder
    createdAt?: SortOrder
  }

  export type MedicalRecordMinOrderByAggregateInput = {
    id?: SortOrder
    petId?: SortOrder
    visitDate?: SortOrder
    veterinarianName?: SortOrder
    clinicName?: SortOrder
    diagnosis?: SortOrder
    treatment?: SortOrder
    followUpRequired?: SortOrder
    followUpDate?: SortOrder
    cost?: SortOrder
    createdAt?: SortOrder
  }

  export type MedicalRecordSumOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type EnumPoolStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PoolStatus | EnumPoolStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PoolStatus[] | ListEnumPoolStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoolStatus[] | ListEnumPoolStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPoolStatusFilter<$PrismaModel> | $Enums.PoolStatus
  }

  export type QRCodePoolCountOrderByAggregateInput = {
    id?: SortOrder
    poolName?: SortOrder
    totalCapacity?: SortOrder
    usedCount?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
  }

  export type QRCodePoolAvgOrderByAggregateInput = {
    totalCapacity?: SortOrder
    usedCount?: SortOrder
  }

  export type QRCodePoolMaxOrderByAggregateInput = {
    id?: SortOrder
    poolName?: SortOrder
    totalCapacity?: SortOrder
    usedCount?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
  }

  export type QRCodePoolMinOrderByAggregateInput = {
    id?: SortOrder
    poolName?: SortOrder
    totalCapacity?: SortOrder
    usedCount?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
  }

  export type QRCodePoolSumOrderByAggregateInput = {
    totalCapacity?: SortOrder
    usedCount?: SortOrder
  }

  export type EnumPoolStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PoolStatus | EnumPoolStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PoolStatus[] | ListEnumPoolStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoolStatus[] | ListEnumPoolStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPoolStatusWithAggregatesFilter<$PrismaModel> | $Enums.PoolStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPoolStatusFilter<$PrismaModel>
    _max?: NestedEnumPoolStatusFilter<$PrismaModel>
  }

  export type EnumQRStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QRStatus | EnumQRStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QRStatus[] | ListEnumQRStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QRStatus[] | ListEnumQRStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQRStatusFilter<$PrismaModel> | $Enums.QRStatus
  }

  export type PetNullableScalarRelationFilter = {
    is?: PetWhereInput | null
    isNot?: PetWhereInput | null
  }

  export type QRCodePoolNullableScalarRelationFilter = {
    is?: QRCodePoolWhereInput | null
    isNot?: QRCodePoolWhereInput | null
  }

  export type QRCodeCountOrderByAggregateInput = {
    id?: SortOrder
    poolId?: SortOrder
    qrCodeString?: SortOrder
    qrCodeHash?: SortOrder
    qrImageUrl?: SortOrder
    status?: SortOrder
    assignedToPet?: SortOrder
    assignedAt?: SortOrder
    activatedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type QRCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    poolId?: SortOrder
    qrCodeString?: SortOrder
    qrCodeHash?: SortOrder
    qrImageUrl?: SortOrder
    status?: SortOrder
    assignedToPet?: SortOrder
    assignedAt?: SortOrder
    activatedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type QRCodeMinOrderByAggregateInput = {
    id?: SortOrder
    poolId?: SortOrder
    qrCodeString?: SortOrder
    qrCodeHash?: SortOrder
    qrImageUrl?: SortOrder
    status?: SortOrder
    assignedToPet?: SortOrder
    assignedAt?: SortOrder
    activatedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumQRStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QRStatus | EnumQRStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QRStatus[] | ListEnumQRStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QRStatus[] | ListEnumQRStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQRStatusWithAggregatesFilter<$PrismaModel> | $Enums.QRStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQRStatusFilter<$PrismaModel>
    _max?: NestedEnumQRStatusFilter<$PrismaModel>
  }

  export type EnumDeviceTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceType | EnumDeviceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DeviceType[] | ListEnumDeviceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DeviceType[] | ListEnumDeviceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDeviceTypeNullableFilter<$PrismaModel> | $Enums.DeviceType | null
  }

  export type EnumScanResultFilter<$PrismaModel = never> = {
    equals?: $Enums.ScanResult | EnumScanResultFieldRefInput<$PrismaModel>
    in?: $Enums.ScanResult[] | ListEnumScanResultFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScanResult[] | ListEnumScanResultFieldRefInput<$PrismaModel>
    not?: NestedEnumScanResultFilter<$PrismaModel> | $Enums.ScanResult
  }

  export type QRCodeScalarRelationFilter = {
    is?: QRCodeWhereInput
    isNot?: QRCodeWhereInput
  }

  export type QRScanEventCountOrderByAggregateInput = {
    id?: SortOrder
    qrId?: SortOrder
    petId?: SortOrder
    scanTimestamp?: SortOrder
    scannerIp?: SortOrder
    userAgent?: SortOrder
    deviceType?: SortOrder
    scanLocation?: SortOrder
    locationAccuracy?: SortOrder
    locationName?: SortOrder
    countryCode?: SortOrder
    city?: SortOrder
    scannerContactInfo?: SortOrder
    scanResult?: SortOrder
    createdAt?: SortOrder
  }

  export type QRScanEventAvgOrderByAggregateInput = {
    locationAccuracy?: SortOrder
  }

  export type QRScanEventMaxOrderByAggregateInput = {
    id?: SortOrder
    qrId?: SortOrder
    petId?: SortOrder
    scanTimestamp?: SortOrder
    scannerIp?: SortOrder
    userAgent?: SortOrder
    deviceType?: SortOrder
    scanLocation?: SortOrder
    locationAccuracy?: SortOrder
    locationName?: SortOrder
    countryCode?: SortOrder
    city?: SortOrder
    scanResult?: SortOrder
    createdAt?: SortOrder
  }

  export type QRScanEventMinOrderByAggregateInput = {
    id?: SortOrder
    qrId?: SortOrder
    petId?: SortOrder
    scanTimestamp?: SortOrder
    scannerIp?: SortOrder
    userAgent?: SortOrder
    deviceType?: SortOrder
    scanLocation?: SortOrder
    locationAccuracy?: SortOrder
    locationName?: SortOrder
    countryCode?: SortOrder
    city?: SortOrder
    scanResult?: SortOrder
    createdAt?: SortOrder
  }

  export type QRScanEventSumOrderByAggregateInput = {
    locationAccuracy?: SortOrder
  }

  export type EnumDeviceTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceType | EnumDeviceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DeviceType[] | ListEnumDeviceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DeviceType[] | ListEnumDeviceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDeviceTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.DeviceType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDeviceTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumDeviceTypeNullableFilter<$PrismaModel>
  }

  export type EnumScanResultWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScanResult | EnumScanResultFieldRefInput<$PrismaModel>
    in?: $Enums.ScanResult[] | ListEnumScanResultFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScanResult[] | ListEnumScanResultFieldRefInput<$PrismaModel>
    not?: NestedEnumScanResultWithAggregatesFilter<$PrismaModel> | $Enums.ScanResult
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScanResultFilter<$PrismaModel>
    _max?: NestedEnumScanResultFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type QRScanEventNullableScalarRelationFilter = {
    is?: QRScanEventWhereInput | null
    isNot?: QRScanEventWhereInput | null
  }

  export type PetLocationEventCountOrderByAggregateInput = {
    id?: SortOrder
    petId?: SortOrder
    qrScanId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrder
    scannerIp?: SortOrder
    userAgent?: SortOrder
    deviceType?: SortOrder
    locationName?: SortOrder
    countryCode?: SortOrder
    city?: SortOrder
    state?: SortOrder
    scannerContactInfo?: SortOrder
    createdAt?: SortOrder
  }

  export type PetLocationEventAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrder
  }

  export type PetLocationEventMaxOrderByAggregateInput = {
    id?: SortOrder
    petId?: SortOrder
    qrScanId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrder
    scannerIp?: SortOrder
    userAgent?: SortOrder
    deviceType?: SortOrder
    locationName?: SortOrder
    countryCode?: SortOrder
    city?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
  }

  export type PetLocationEventMinOrderByAggregateInput = {
    id?: SortOrder
    petId?: SortOrder
    qrScanId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrder
    scannerIp?: SortOrder
    userAgent?: SortOrder
    deviceType?: SortOrder
    locationName?: SortOrder
    countryCode?: SortOrder
    city?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
  }

  export type PetLocationEventSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    razorpayOrderId?: SortOrder
    userId?: SortOrder
    receipt?: SortOrder
    amountInPaise?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    rawOrderPayload?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    amountInPaise?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    razorpayOrderId?: SortOrder
    userId?: SortOrder
    receipt?: SortOrder
    amountInPaise?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    razorpayOrderId?: SortOrder
    userId?: SortOrder
    receipt?: SortOrder
    amountInPaise?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    amountInPaise?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type EnumPaymentStatusNewFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatusNew | EnumPaymentStatusNewFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatusNew[] | ListEnumPaymentStatusNewFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatusNew[] | ListEnumPaymentStatusNewFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusNewFilter<$PrismaModel> | $Enums.PaymentStatusNew
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type EnumVerificationMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationMethod | EnumVerificationMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerificationMethod[] | ListEnumVerificationMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerificationMethod[] | ListEnumVerificationMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerificationMethodNullableFilter<$PrismaModel> | $Enums.VerificationMethod | null
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type RefundListRelationFilter = {
    every?: RefundWhereInput
    some?: RefundWhereInput
    none?: RefundWhereInput
  }

  export type RefundOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    localOrderId?: SortOrder
    razorpayPaymentId?: SortOrder
    razorpayOrderId?: SortOrder
    amountInPaise?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    captured?: SortOrder
    capturedAt?: SortOrder
    bank?: SortOrder
    vpa?: SortOrder
    card?: SortOrder
    fee?: SortOrder
    tax?: SortOrder
    currencyConversion?: SortOrder
    signatureValid?: SortOrder
    signatureVerifiedAt?: SortOrder
    verificationMethod?: SortOrder
    rawPaymentPayload?: SortOrder
    clientMeta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amountInPaise?: SortOrder
    fee?: SortOrder
    tax?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    localOrderId?: SortOrder
    razorpayPaymentId?: SortOrder
    razorpayOrderId?: SortOrder
    amountInPaise?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    captured?: SortOrder
    capturedAt?: SortOrder
    bank?: SortOrder
    vpa?: SortOrder
    fee?: SortOrder
    tax?: SortOrder
    signatureValid?: SortOrder
    signatureVerifiedAt?: SortOrder
    verificationMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    localOrderId?: SortOrder
    razorpayPaymentId?: SortOrder
    razorpayOrderId?: SortOrder
    amountInPaise?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    captured?: SortOrder
    capturedAt?: SortOrder
    bank?: SortOrder
    vpa?: SortOrder
    fee?: SortOrder
    tax?: SortOrder
    signatureValid?: SortOrder
    signatureVerifiedAt?: SortOrder
    verificationMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amountInPaise?: SortOrder
    fee?: SortOrder
    tax?: SortOrder
  }

  export type EnumPaymentStatusNewWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatusNew | EnumPaymentStatusNewFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatusNew[] | ListEnumPaymentStatusNewFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatusNew[] | ListEnumPaymentStatusNewFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusNewWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatusNew
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusNewFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusNewFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type EnumVerificationMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationMethod | EnumVerificationMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerificationMethod[] | ListEnumVerificationMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerificationMethod[] | ListEnumVerificationMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerificationMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.VerificationMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVerificationMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumVerificationMethodNullableFilter<$PrismaModel>
  }

  export type EnumRefundStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundStatusFilter<$PrismaModel> | $Enums.RefundStatus
  }

  export type PaymentScalarRelationFilter = {
    is?: PaymentWhereInput
    isNot?: PaymentWhereInput
  }

  export type PaymentEventNullableScalarRelationFilter = {
    is?: PaymentEventWhereInput | null
    isNot?: PaymentEventWhereInput | null
  }

  export type RefundCountOrderByAggregateInput = {
    id?: SortOrder
    razorpayRefundId?: SortOrder
    razorpayPaymentId?: SortOrder
    paymentEventId?: SortOrder
    amountInPaise?: SortOrder
    refundAmount?: SortOrder
    reason?: SortOrder
    initiatedBy?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    rawRefundPayload?: SortOrder
    createdAt?: SortOrder
  }

  export type RefundAvgOrderByAggregateInput = {
    amountInPaise?: SortOrder
    refundAmount?: SortOrder
  }

  export type RefundMaxOrderByAggregateInput = {
    id?: SortOrder
    razorpayRefundId?: SortOrder
    razorpayPaymentId?: SortOrder
    paymentEventId?: SortOrder
    amountInPaise?: SortOrder
    refundAmount?: SortOrder
    reason?: SortOrder
    initiatedBy?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefundMinOrderByAggregateInput = {
    id?: SortOrder
    razorpayRefundId?: SortOrder
    razorpayPaymentId?: SortOrder
    paymentEventId?: SortOrder
    amountInPaise?: SortOrder
    refundAmount?: SortOrder
    reason?: SortOrder
    initiatedBy?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefundSumOrderByAggregateInput = {
    amountInPaise?: SortOrder
    refundAmount?: SortOrder
  }

  export type EnumRefundStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundStatusWithAggregatesFilter<$PrismaModel> | $Enums.RefundStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRefundStatusFilter<$PrismaModel>
    _max?: NestedEnumRefundStatusFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type WebhookEventCountOrderByAggregateInput = {
    id?: SortOrder
    razorpayEventId?: SortOrder
    eventType?: SortOrder
    rawEvent?: SortOrder
    headers?: SortOrder
    signatureValid?: SortOrder
    receivedAt?: SortOrder
    processedAt?: SortOrder
    processingResult?: SortOrder
  }

  export type WebhookEventMaxOrderByAggregateInput = {
    id?: SortOrder
    razorpayEventId?: SortOrder
    eventType?: SortOrder
    signatureValid?: SortOrder
    receivedAt?: SortOrder
    processedAt?: SortOrder
  }

  export type WebhookEventMinOrderByAggregateInput = {
    id?: SortOrder
    razorpayEventId?: SortOrder
    eventType?: SortOrder
    signatureValid?: SortOrder
    receivedAt?: SortOrder
    processedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type PaymentWebhookCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    eventType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    payload?: SortOrder
    signature?: SortOrder
    signatureVerified?: SortOrder
    processed?: SortOrder
    processedAt?: SortOrder
    processingAttempts?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentWebhookAvgOrderByAggregateInput = {
    processingAttempts?: SortOrder
  }

  export type PaymentWebhookMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    eventType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    signature?: SortOrder
    signatureVerified?: SortOrder
    processed?: SortOrder
    processedAt?: SortOrder
    processingAttempts?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentWebhookMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    eventType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    signature?: SortOrder
    signatureVerified?: SortOrder
    processed?: SortOrder
    processedAt?: SortOrder
    processingAttempts?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentWebhookSumOrderByAggregateInput = {
    processingAttempts?: SortOrder
  }

  export type EnumPaymentPurposeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentPurpose | EnumPaymentPurposeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentPurpose[] | ListEnumPaymentPurposeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentPurpose[] | ListEnumPaymentPurposeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentPurposeFilter<$PrismaModel> | $Enums.PaymentPurpose
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type QRCodeNullableScalarRelationFilter = {
    is?: QRCodeWhereInput | null
    isNot?: QRCodeWhereInput | null
  }

  export type PaymentEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    petId?: SortOrder
    qrId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentPurpose?: SortOrder
    status?: SortOrder
    razorpayOrderId?: SortOrder
    razorpayPaymentId?: SortOrder
    razorpaySignature?: SortOrder
    paymentMethod?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type PaymentEventAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    petId?: SortOrder
    qrId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentPurpose?: SortOrder
    status?: SortOrder
    razorpayOrderId?: SortOrder
    razorpayPaymentId?: SortOrder
    razorpaySignature?: SortOrder
    paymentMethod?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type PaymentEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    petId?: SortOrder
    qrId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentPurpose?: SortOrder
    status?: SortOrder
    razorpayOrderId?: SortOrder
    razorpayPaymentId?: SortOrder
    razorpaySignature?: SortOrder
    paymentMethod?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type PaymentEventSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentPurposeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentPurpose | EnumPaymentPurposeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentPurpose[] | ListEnumPaymentPurposeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentPurpose[] | ListEnumPaymentPurposeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentPurposeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentPurpose
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentPurposeFilter<$PrismaModel>
    _max?: NestedEnumPaymentPurposeFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumLocationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationType | EnumLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLocationTypeFilter<$PrismaModel> | $Enums.LocationType
  }

  export type LocationTrackCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationType?: SortOrder
    position?: SortOrder
    accuracy?: SortOrder
    locationName?: SortOrder
    countryCode?: SortOrder
    state?: SortOrder
    city?: SortOrder
    ipAddress?: SortOrder
    deviceInfo?: SortOrder
    timestamp?: SortOrder
  }

  export type LocationTrackAvgOrderByAggregateInput = {
    accuracy?: SortOrder
  }

  export type LocationTrackMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationType?: SortOrder
    position?: SortOrder
    accuracy?: SortOrder
    locationName?: SortOrder
    countryCode?: SortOrder
    state?: SortOrder
    city?: SortOrder
    ipAddress?: SortOrder
    timestamp?: SortOrder
  }

  export type LocationTrackMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationType?: SortOrder
    position?: SortOrder
    accuracy?: SortOrder
    locationName?: SortOrder
    countryCode?: SortOrder
    state?: SortOrder
    city?: SortOrder
    ipAddress?: SortOrder
    timestamp?: SortOrder
  }

  export type LocationTrackSumOrderByAggregateInput = {
    accuracy?: SortOrder
  }

  export type EnumLocationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationType | EnumLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLocationTypeWithAggregatesFilter<$PrismaModel> | $Enums.LocationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLocationTypeFilter<$PrismaModel>
    _max?: NestedEnumLocationTypeFilter<$PrismaModel>
  }

  export type NotificationPreferenceCountOrderByAggregateInput = {
    userId?: SortOrder
    pushEnabled?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    scanNotifications?: SortOrder
    marketingNotifications?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
    timezone?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceMaxOrderByAggregateInput = {
    userId?: SortOrder
    pushEnabled?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    scanNotifications?: SortOrder
    marketingNotifications?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
    timezone?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceMinOrderByAggregateInput = {
    userId?: SortOrder
    pushEnabled?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    scanNotifications?: SortOrder
    marketingNotifications?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
    timezone?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    petId?: SortOrder
    qrScanId?: SortOrder
    notificationType?: SortOrder
    title?: SortOrder
    message?: SortOrder
    channels?: SortOrder
    deliveryStatus?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    petId?: SortOrder
    qrScanId?: SortOrder
    notificationType?: SortOrder
    title?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    petId?: SortOrder
    qrScanId?: SortOrder
    notificationType?: SortOrder
    title?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumPlatformFilter<$PrismaModel = never> = {
    equals?: $Enums.Platform | EnumPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.Platform[] | ListEnumPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.Platform[] | ListEnumPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumPlatformFilter<$PrismaModel> | $Enums.Platform
  }

  export type DeviceTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceToken?: SortOrder
    platform?: SortOrder
    deviceInfo?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type DeviceTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceToken?: SortOrder
    platform?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type DeviceTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceToken?: SortOrder
    platform?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type EnumPlatformWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Platform | EnumPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.Platform[] | ListEnumPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.Platform[] | ListEnumPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumPlatformWithAggregatesFilter<$PrismaModel> | $Enums.Platform
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlatformFilter<$PrismaModel>
    _max?: NestedEnumPlatformFilter<$PrismaModel>
  }

  export type EnumTicketCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketCategory | EnumTicketCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TicketCategory[] | ListEnumTicketCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketCategory[] | ListEnumTicketCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketCategoryFilter<$PrismaModel> | $Enums.TicketCategory
  }

  export type EnumTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityFilter<$PrismaModel> | $Enums.TicketPriority
  }

  export type EnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type SupportTicketCountOrderByAggregateInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    userId?: SortOrder
    petId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type SupportTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    userId?: SortOrder
    petId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type SupportTicketMinOrderByAggregateInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    userId?: SortOrder
    petId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type EnumTicketCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketCategory | EnumTicketCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TicketCategory[] | ListEnumTicketCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketCategory[] | ListEnumTicketCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketCategoryWithAggregatesFilter<$PrismaModel> | $Enums.TicketCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketCategoryFilter<$PrismaModel>
    _max?: NestedEnumTicketCategoryFilter<$PrismaModel>
  }

  export type EnumTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumTicketPriorityFilter<$PrismaModel>
  }

  export type EnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type EnumSenderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeFilter<$PrismaModel> | $Enums.SenderType
  }

  export type SupportTicketScalarRelationFilter = {
    is?: SupportTicketWhereInput
    isNot?: SupportTicketWhereInput
  }

  export type SupportMessageCountOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    message?: SortOrder
    attachments?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
  }

  export type SupportMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    message?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
  }

  export type SupportMessageMinOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    message?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumSenderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel> | $Enums.SenderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSenderTypeFilter<$PrismaModel>
    _max?: NestedEnumSenderTypeFilter<$PrismaModel>
  }

  export type EnumOperationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OperationType | EnumOperationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OperationType[] | ListEnumOperationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OperationType[] | ListEnumOperationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOperationTypeFilter<$PrismaModel> | $Enums.OperationType
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    operationType?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    changedColumns?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    operationType?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    operationType?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    timestamp?: SortOrder
  }

  export type EnumOperationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OperationType | EnumOperationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OperationType[] | ListEnumOperationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OperationType[] | ListEnumOperationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOperationTypeWithAggregatesFilter<$PrismaModel> | $Enums.OperationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOperationTypeFilter<$PrismaModel>
    _max?: NestedEnumOperationTypeFilter<$PrismaModel>
  }

  export type SystemAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrder
    metricUnit?: SortOrder
    dimensions?: SortOrder
    timestamp?: SortOrder
  }

  export type SystemAnalyticsAvgOrderByAggregateInput = {
    metricValue?: SortOrder
  }

  export type SystemAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrder
    metricUnit?: SortOrder
    timestamp?: SortOrder
  }

  export type SystemAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrder
    metricUnit?: SortOrder
    timestamp?: SortOrder
  }

  export type SystemAnalyticsSumOrderByAggregateInput = {
    metricValue?: SortOrder
  }

  export type EnumApplicationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationType | EnumApplicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationType[] | ListEnumApplicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationType[] | ListEnumApplicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationTypeFilter<$PrismaModel> | $Enums.ApplicationType
  }

  export type EnumIdentifierTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IdentifierType | EnumIdentifierTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IdentifierType[] | ListEnumIdentifierTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdentifierType[] | ListEnumIdentifierTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIdentifierTypeFilter<$PrismaModel> | $Enums.IdentifierType
  }

  export type EnumApplicantTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicantType | EnumApplicantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicantType[] | ListEnumApplicantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicantType[] | ListEnumApplicantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicantTypeFilter<$PrismaModel> | $Enums.ApplicantType
  }

  export type ApplicationDocumentListRelationFilter = {
    every?: ApplicationDocumentWhereInput
    some?: ApplicationDocumentWhereInput
    none?: ApplicationDocumentWhereInput
  }

  export type CheckoutItemListRelationFilter = {
    every?: CheckoutItemWhereInput
    some?: CheckoutItemWhereInput
    none?: CheckoutItemWhereInput
  }

  export type RegisteredPetListRelationFilter = {
    every?: RegisteredPetWhereInput
    some?: RegisteredPetWhereInput
    none?: RegisteredPetWhereInput
  }

  export type ApplicationDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CheckoutItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegisteredPetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PetRegistrationApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    applicationType?: SortOrder
    identifierType?: SortOrder
    identifierNumber?: SortOrder
    submittedAt?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    applicantType?: SortOrder
    applicantName?: SortOrder
    fatherOrHusbandName?: SortOrder
    applicantEmail?: SortOrder
    applicantPhone?: SortOrder
    aadhaarNumber?: SortOrder
    pincode?: SortOrder
    address?: SortOrder
    hasTokenNumber?: SortOrder
    declarationAcknowledgement?: SortOrder
    acceptedTerms?: SortOrder
    registrationFee?: SortOrder
    convenienceFee?: SortOrder
    gst?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    deliveryAddressLine?: SortOrder
    deliveryCity?: SortOrder
    deliveryState?: SortOrder
    deliveryPincode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PetRegistrationApplicationAvgOrderByAggregateInput = {
    registrationFee?: SortOrder
    convenienceFee?: SortOrder
    gst?: SortOrder
    totalAmount?: SortOrder
  }

  export type PetRegistrationApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    applicationType?: SortOrder
    identifierType?: SortOrder
    identifierNumber?: SortOrder
    submittedAt?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    applicantType?: SortOrder
    applicantName?: SortOrder
    fatherOrHusbandName?: SortOrder
    applicantEmail?: SortOrder
    applicantPhone?: SortOrder
    aadhaarNumber?: SortOrder
    pincode?: SortOrder
    address?: SortOrder
    hasTokenNumber?: SortOrder
    declarationAcknowledgement?: SortOrder
    acceptedTerms?: SortOrder
    registrationFee?: SortOrder
    convenienceFee?: SortOrder
    gst?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    deliveryAddressLine?: SortOrder
    deliveryCity?: SortOrder
    deliveryState?: SortOrder
    deliveryPincode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PetRegistrationApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    applicationType?: SortOrder
    identifierType?: SortOrder
    identifierNumber?: SortOrder
    submittedAt?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    applicantType?: SortOrder
    applicantName?: SortOrder
    fatherOrHusbandName?: SortOrder
    applicantEmail?: SortOrder
    applicantPhone?: SortOrder
    aadhaarNumber?: SortOrder
    pincode?: SortOrder
    address?: SortOrder
    hasTokenNumber?: SortOrder
    declarationAcknowledgement?: SortOrder
    acceptedTerms?: SortOrder
    registrationFee?: SortOrder
    convenienceFee?: SortOrder
    gst?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    deliveryAddressLine?: SortOrder
    deliveryCity?: SortOrder
    deliveryState?: SortOrder
    deliveryPincode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PetRegistrationApplicationSumOrderByAggregateInput = {
    registrationFee?: SortOrder
    convenienceFee?: SortOrder
    gst?: SortOrder
    totalAmount?: SortOrder
  }

  export type EnumApplicationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationType | EnumApplicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationType[] | ListEnumApplicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationType[] | ListEnumApplicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationTypeFilter<$PrismaModel>
    _max?: NestedEnumApplicationTypeFilter<$PrismaModel>
  }

  export type EnumIdentifierTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IdentifierType | EnumIdentifierTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IdentifierType[] | ListEnumIdentifierTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdentifierType[] | ListEnumIdentifierTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIdentifierTypeWithAggregatesFilter<$PrismaModel> | $Enums.IdentifierType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIdentifierTypeFilter<$PrismaModel>
    _max?: NestedEnumIdentifierTypeFilter<$PrismaModel>
  }

  export type EnumApplicantTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicantType | EnumApplicantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicantType[] | ListEnumApplicantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicantType[] | ListEnumApplicantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicantTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApplicantType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicantTypeFilter<$PrismaModel>
    _max?: NestedEnumApplicantTypeFilter<$PrismaModel>
  }

  export type PetDocumentListRelationFilter = {
    every?: PetDocumentWhereInput
    some?: PetDocumentWhereInput
    none?: PetDocumentWhereInput
  }

  export type PetRegistrationApplicationScalarRelationFilter = {
    is?: PetRegistrationApplicationWhereInput
    isNot?: PetRegistrationApplicationWhereInput
  }

  export type PetDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegisteredPetCountOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    petName?: SortOrder
    breed?: SortOrder
    dateOfBirth?: SortOrder
    ageOnRegistration?: SortOrder
    lastRabiesVaccinationDate?: SortOrder
    veterinaryDoctorName?: SortOrder
    veterinaryDoctorRegNumber?: SortOrder
    veterinaryClinicOrHospitalName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gender?: SortOrder
  }

  export type RegisteredPetMaxOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    petName?: SortOrder
    breed?: SortOrder
    dateOfBirth?: SortOrder
    ageOnRegistration?: SortOrder
    lastRabiesVaccinationDate?: SortOrder
    veterinaryDoctorName?: SortOrder
    veterinaryDoctorRegNumber?: SortOrder
    veterinaryClinicOrHospitalName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gender?: SortOrder
  }

  export type RegisteredPetMinOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    petName?: SortOrder
    breed?: SortOrder
    dateOfBirth?: SortOrder
    ageOnRegistration?: SortOrder
    lastRabiesVaccinationDate?: SortOrder
    veterinaryDoctorName?: SortOrder
    veterinaryDoctorRegNumber?: SortOrder
    veterinaryClinicOrHospitalName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gender?: SortOrder
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type ApplicationDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
  }

  export type ApplicationDocumentAvgOrderByAggregateInput = {
    sizeBytes?: SortOrder
  }

  export type ApplicationDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
  }

  export type ApplicationDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
  }

  export type ApplicationDocumentSumOrderByAggregateInput = {
    sizeBytes?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type RegisteredPetScalarRelationFilter = {
    is?: RegisteredPetWhereInput
    isNot?: RegisteredPetWhereInput
  }

  export type PetDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    petId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
  }

  export type PetDocumentAvgOrderByAggregateInput = {
    sizeBytes?: SortOrder
  }

  export type PetDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    petId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
  }

  export type PetDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    petId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
  }

  export type PetDocumentSumOrderByAggregateInput = {
    sizeBytes?: SortOrder
  }

  export type CheckoutItemCountOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    sku?: SortOrder
    itemName?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    createdAt?: SortOrder
  }

  export type CheckoutItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
  }

  export type CheckoutItemMaxOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    sku?: SortOrder
    itemName?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    createdAt?: SortOrder
  }

  export type CheckoutItemMinOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    sku?: SortOrder
    itemName?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    createdAt?: SortOrder
  }

  export type CheckoutItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DeviceTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<DeviceTokenCreateWithoutUserInput, DeviceTokenUncheckedCreateWithoutUserInput> | DeviceTokenCreateWithoutUserInput[] | DeviceTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceTokenCreateOrConnectWithoutUserInput | DeviceTokenCreateOrConnectWithoutUserInput[]
    createMany?: DeviceTokenCreateManyUserInputEnvelope
    connect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
  }

  export type ExecutiveCreateNestedOneWithoutUserInput = {
    create?: XOR<ExecutiveCreateWithoutUserInput, ExecutiveUncheckedCreateWithoutUserInput>
    connectOrCreate?: ExecutiveCreateOrConnectWithoutUserInput
    connect?: ExecutiveWhereUniqueInput
  }

  export type LocationTrackCreateNestedManyWithoutUserInput = {
    create?: XOR<LocationTrackCreateWithoutUserInput, LocationTrackUncheckedCreateWithoutUserInput> | LocationTrackCreateWithoutUserInput[] | LocationTrackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LocationTrackCreateOrConnectWithoutUserInput | LocationTrackCreateOrConnectWithoutUserInput[]
    createMany?: LocationTrackCreateManyUserInputEnvelope
    connect?: LocationTrackWhereUniqueInput | LocationTrackWhereUniqueInput[]
  }

  export type NotificationPreferenceCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OTPCodeCreateNestedManyWithoutUserInput = {
    create?: XOR<OTPCodeCreateWithoutUserInput, OTPCodeUncheckedCreateWithoutUserInput> | OTPCodeCreateWithoutUserInput[] | OTPCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OTPCodeCreateOrConnectWithoutUserInput | OTPCodeCreateOrConnectWithoutUserInput[]
    createMany?: OTPCodeCreateManyUserInputEnvelope
    connect?: OTPCodeWhereUniqueInput | OTPCodeWhereUniqueInput[]
  }

  export type PaymentEventCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentEventCreateWithoutUserInput, PaymentEventUncheckedCreateWithoutUserInput> | PaymentEventCreateWithoutUserInput[] | PaymentEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentEventCreateOrConnectWithoutUserInput | PaymentEventCreateOrConnectWithoutUserInput[]
    createMany?: PaymentEventCreateManyUserInputEnvelope
    connect?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
  }

  export type PetOwnerCreateNestedOneWithoutUserInput = {
    create?: XOR<PetOwnerCreateWithoutUserInput, PetOwnerUncheckedCreateWithoutUserInput>
    connectOrCreate?: PetOwnerCreateOrConnectWithoutUserInput
    connect?: PetOwnerWhereUniqueInput
  }

  export type PetCreateNestedManyWithoutRegisteredByUserInput = {
    create?: XOR<PetCreateWithoutRegisteredByUserInput, PetUncheckedCreateWithoutRegisteredByUserInput> | PetCreateWithoutRegisteredByUserInput[] | PetUncheckedCreateWithoutRegisteredByUserInput[]
    connectOrCreate?: PetCreateOrConnectWithoutRegisteredByUserInput | PetCreateOrConnectWithoutRegisteredByUserInput[]
    createMany?: PetCreateManyRegisteredByUserInputEnvelope
    connect?: PetWhereUniqueInput | PetWhereUniqueInput[]
  }

  export type SupportMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<SupportMessageCreateWithoutSenderInput, SupportMessageUncheckedCreateWithoutSenderInput> | SupportMessageCreateWithoutSenderInput[] | SupportMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: SupportMessageCreateOrConnectWithoutSenderInput | SupportMessageCreateOrConnectWithoutSenderInput[]
    createMany?: SupportMessageCreateManySenderInputEnvelope
    connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutAssignedToUserInput = {
    create?: XOR<SupportTicketCreateWithoutAssignedToUserInput, SupportTicketUncheckedCreateWithoutAssignedToUserInput> | SupportTicketCreateWithoutAssignedToUserInput[] | SupportTicketUncheckedCreateWithoutAssignedToUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAssignedToUserInput | SupportTicketCreateOrConnectWithoutAssignedToUserInput[]
    createMany?: SupportTicketCreateManyAssignedToUserInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutUserInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type UserSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DeviceTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DeviceTokenCreateWithoutUserInput, DeviceTokenUncheckedCreateWithoutUserInput> | DeviceTokenCreateWithoutUserInput[] | DeviceTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceTokenCreateOrConnectWithoutUserInput | DeviceTokenCreateOrConnectWithoutUserInput[]
    createMany?: DeviceTokenCreateManyUserInputEnvelope
    connect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
  }

  export type ExecutiveUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ExecutiveCreateWithoutUserInput, ExecutiveUncheckedCreateWithoutUserInput>
    connectOrCreate?: ExecutiveCreateOrConnectWithoutUserInput
    connect?: ExecutiveWhereUniqueInput
  }

  export type LocationTrackUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LocationTrackCreateWithoutUserInput, LocationTrackUncheckedCreateWithoutUserInput> | LocationTrackCreateWithoutUserInput[] | LocationTrackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LocationTrackCreateOrConnectWithoutUserInput | LocationTrackCreateOrConnectWithoutUserInput[]
    createMany?: LocationTrackCreateManyUserInputEnvelope
    connect?: LocationTrackWhereUniqueInput | LocationTrackWhereUniqueInput[]
  }

  export type NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OTPCodeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OTPCodeCreateWithoutUserInput, OTPCodeUncheckedCreateWithoutUserInput> | OTPCodeCreateWithoutUserInput[] | OTPCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OTPCodeCreateOrConnectWithoutUserInput | OTPCodeCreateOrConnectWithoutUserInput[]
    createMany?: OTPCodeCreateManyUserInputEnvelope
    connect?: OTPCodeWhereUniqueInput | OTPCodeWhereUniqueInput[]
  }

  export type PaymentEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentEventCreateWithoutUserInput, PaymentEventUncheckedCreateWithoutUserInput> | PaymentEventCreateWithoutUserInput[] | PaymentEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentEventCreateOrConnectWithoutUserInput | PaymentEventCreateOrConnectWithoutUserInput[]
    createMany?: PaymentEventCreateManyUserInputEnvelope
    connect?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
  }

  export type PetOwnerUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PetOwnerCreateWithoutUserInput, PetOwnerUncheckedCreateWithoutUserInput>
    connectOrCreate?: PetOwnerCreateOrConnectWithoutUserInput
    connect?: PetOwnerWhereUniqueInput
  }

  export type PetUncheckedCreateNestedManyWithoutRegisteredByUserInput = {
    create?: XOR<PetCreateWithoutRegisteredByUserInput, PetUncheckedCreateWithoutRegisteredByUserInput> | PetCreateWithoutRegisteredByUserInput[] | PetUncheckedCreateWithoutRegisteredByUserInput[]
    connectOrCreate?: PetCreateOrConnectWithoutRegisteredByUserInput | PetCreateOrConnectWithoutRegisteredByUserInput[]
    createMany?: PetCreateManyRegisteredByUserInputEnvelope
    connect?: PetWhereUniqueInput | PetWhereUniqueInput[]
  }

  export type SupportMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<SupportMessageCreateWithoutSenderInput, SupportMessageUncheckedCreateWithoutSenderInput> | SupportMessageCreateWithoutSenderInput[] | SupportMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: SupportMessageCreateOrConnectWithoutSenderInput | SupportMessageCreateOrConnectWithoutSenderInput[]
    createMany?: SupportMessageCreateManySenderInputEnvelope
    connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutAssignedToUserInput = {
    create?: XOR<SupportTicketCreateWithoutAssignedToUserInput, SupportTicketUncheckedCreateWithoutAssignedToUserInput> | SupportTicketCreateWithoutAssignedToUserInput[] | SupportTicketUncheckedCreateWithoutAssignedToUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAssignedToUserInput | SupportTicketCreateOrConnectWithoutAssignedToUserInput[]
    createMany?: SupportTicketCreateManyAssignedToUserInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type UserSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableEnumAuthProviderFieldUpdateOperationsInput = {
    set?: $Enums.AuthProvider | null
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DeviceTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeviceTokenCreateWithoutUserInput, DeviceTokenUncheckedCreateWithoutUserInput> | DeviceTokenCreateWithoutUserInput[] | DeviceTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceTokenCreateOrConnectWithoutUserInput | DeviceTokenCreateOrConnectWithoutUserInput[]
    upsert?: DeviceTokenUpsertWithWhereUniqueWithoutUserInput | DeviceTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeviceTokenCreateManyUserInputEnvelope
    set?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    disconnect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    delete?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    connect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    update?: DeviceTokenUpdateWithWhereUniqueWithoutUserInput | DeviceTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeviceTokenUpdateManyWithWhereWithoutUserInput | DeviceTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeviceTokenScalarWhereInput | DeviceTokenScalarWhereInput[]
  }

  export type ExecutiveUpdateOneWithoutUserNestedInput = {
    create?: XOR<ExecutiveCreateWithoutUserInput, ExecutiveUncheckedCreateWithoutUserInput>
    connectOrCreate?: ExecutiveCreateOrConnectWithoutUserInput
    upsert?: ExecutiveUpsertWithoutUserInput
    disconnect?: ExecutiveWhereInput | boolean
    delete?: ExecutiveWhereInput | boolean
    connect?: ExecutiveWhereUniqueInput
    update?: XOR<XOR<ExecutiveUpdateToOneWithWhereWithoutUserInput, ExecutiveUpdateWithoutUserInput>, ExecutiveUncheckedUpdateWithoutUserInput>
  }

  export type LocationTrackUpdateManyWithoutUserNestedInput = {
    create?: XOR<LocationTrackCreateWithoutUserInput, LocationTrackUncheckedCreateWithoutUserInput> | LocationTrackCreateWithoutUserInput[] | LocationTrackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LocationTrackCreateOrConnectWithoutUserInput | LocationTrackCreateOrConnectWithoutUserInput[]
    upsert?: LocationTrackUpsertWithWhereUniqueWithoutUserInput | LocationTrackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LocationTrackCreateManyUserInputEnvelope
    set?: LocationTrackWhereUniqueInput | LocationTrackWhereUniqueInput[]
    disconnect?: LocationTrackWhereUniqueInput | LocationTrackWhereUniqueInput[]
    delete?: LocationTrackWhereUniqueInput | LocationTrackWhereUniqueInput[]
    connect?: LocationTrackWhereUniqueInput | LocationTrackWhereUniqueInput[]
    update?: LocationTrackUpdateWithWhereUniqueWithoutUserInput | LocationTrackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LocationTrackUpdateManyWithWhereWithoutUserInput | LocationTrackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LocationTrackScalarWhereInput | LocationTrackScalarWhereInput[]
  }

  export type NotificationPreferenceUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferenceUpsertWithoutUserInput
    disconnect?: NotificationPreferenceWhereInput | boolean
    delete?: NotificationPreferenceWhereInput | boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<XOR<NotificationPreferenceUpdateToOneWithWhereWithoutUserInput, NotificationPreferenceUpdateWithoutUserInput>, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OTPCodeUpdateManyWithoutUserNestedInput = {
    create?: XOR<OTPCodeCreateWithoutUserInput, OTPCodeUncheckedCreateWithoutUserInput> | OTPCodeCreateWithoutUserInput[] | OTPCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OTPCodeCreateOrConnectWithoutUserInput | OTPCodeCreateOrConnectWithoutUserInput[]
    upsert?: OTPCodeUpsertWithWhereUniqueWithoutUserInput | OTPCodeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OTPCodeCreateManyUserInputEnvelope
    set?: OTPCodeWhereUniqueInput | OTPCodeWhereUniqueInput[]
    disconnect?: OTPCodeWhereUniqueInput | OTPCodeWhereUniqueInput[]
    delete?: OTPCodeWhereUniqueInput | OTPCodeWhereUniqueInput[]
    connect?: OTPCodeWhereUniqueInput | OTPCodeWhereUniqueInput[]
    update?: OTPCodeUpdateWithWhereUniqueWithoutUserInput | OTPCodeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OTPCodeUpdateManyWithWhereWithoutUserInput | OTPCodeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OTPCodeScalarWhereInput | OTPCodeScalarWhereInput[]
  }

  export type PaymentEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentEventCreateWithoutUserInput, PaymentEventUncheckedCreateWithoutUserInput> | PaymentEventCreateWithoutUserInput[] | PaymentEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentEventCreateOrConnectWithoutUserInput | PaymentEventCreateOrConnectWithoutUserInput[]
    upsert?: PaymentEventUpsertWithWhereUniqueWithoutUserInput | PaymentEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentEventCreateManyUserInputEnvelope
    set?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    disconnect?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    delete?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    connect?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    update?: PaymentEventUpdateWithWhereUniqueWithoutUserInput | PaymentEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentEventUpdateManyWithWhereWithoutUserInput | PaymentEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentEventScalarWhereInput | PaymentEventScalarWhereInput[]
  }

  export type PetOwnerUpdateOneWithoutUserNestedInput = {
    create?: XOR<PetOwnerCreateWithoutUserInput, PetOwnerUncheckedCreateWithoutUserInput>
    connectOrCreate?: PetOwnerCreateOrConnectWithoutUserInput
    upsert?: PetOwnerUpsertWithoutUserInput
    disconnect?: PetOwnerWhereInput | boolean
    delete?: PetOwnerWhereInput | boolean
    connect?: PetOwnerWhereUniqueInput
    update?: XOR<XOR<PetOwnerUpdateToOneWithWhereWithoutUserInput, PetOwnerUpdateWithoutUserInput>, PetOwnerUncheckedUpdateWithoutUserInput>
  }

  export type PetUpdateManyWithoutRegisteredByUserNestedInput = {
    create?: XOR<PetCreateWithoutRegisteredByUserInput, PetUncheckedCreateWithoutRegisteredByUserInput> | PetCreateWithoutRegisteredByUserInput[] | PetUncheckedCreateWithoutRegisteredByUserInput[]
    connectOrCreate?: PetCreateOrConnectWithoutRegisteredByUserInput | PetCreateOrConnectWithoutRegisteredByUserInput[]
    upsert?: PetUpsertWithWhereUniqueWithoutRegisteredByUserInput | PetUpsertWithWhereUniqueWithoutRegisteredByUserInput[]
    createMany?: PetCreateManyRegisteredByUserInputEnvelope
    set?: PetWhereUniqueInput | PetWhereUniqueInput[]
    disconnect?: PetWhereUniqueInput | PetWhereUniqueInput[]
    delete?: PetWhereUniqueInput | PetWhereUniqueInput[]
    connect?: PetWhereUniqueInput | PetWhereUniqueInput[]
    update?: PetUpdateWithWhereUniqueWithoutRegisteredByUserInput | PetUpdateWithWhereUniqueWithoutRegisteredByUserInput[]
    updateMany?: PetUpdateManyWithWhereWithoutRegisteredByUserInput | PetUpdateManyWithWhereWithoutRegisteredByUserInput[]
    deleteMany?: PetScalarWhereInput | PetScalarWhereInput[]
  }

  export type SupportMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<SupportMessageCreateWithoutSenderInput, SupportMessageUncheckedCreateWithoutSenderInput> | SupportMessageCreateWithoutSenderInput[] | SupportMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: SupportMessageCreateOrConnectWithoutSenderInput | SupportMessageCreateOrConnectWithoutSenderInput[]
    upsert?: SupportMessageUpsertWithWhereUniqueWithoutSenderInput | SupportMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: SupportMessageCreateManySenderInputEnvelope
    set?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    disconnect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    delete?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    update?: SupportMessageUpdateWithWhereUniqueWithoutSenderInput | SupportMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: SupportMessageUpdateManyWithWhereWithoutSenderInput | SupportMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: SupportMessageScalarWhereInput | SupportMessageScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutAssignedToUserNestedInput = {
    create?: XOR<SupportTicketCreateWithoutAssignedToUserInput, SupportTicketUncheckedCreateWithoutAssignedToUserInput> | SupportTicketCreateWithoutAssignedToUserInput[] | SupportTicketUncheckedCreateWithoutAssignedToUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAssignedToUserInput | SupportTicketCreateOrConnectWithoutAssignedToUserInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutAssignedToUserInput | SupportTicketUpsertWithWhereUniqueWithoutAssignedToUserInput[]
    createMany?: SupportTicketCreateManyAssignedToUserInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutAssignedToUserInput | SupportTicketUpdateWithWhereUniqueWithoutAssignedToUserInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutAssignedToUserInput | SupportTicketUpdateManyWithWhereWithoutAssignedToUserInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutUserInput | SupportTicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutUserInput | SupportTicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutUserInput | SupportTicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type UserSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DeviceTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeviceTokenCreateWithoutUserInput, DeviceTokenUncheckedCreateWithoutUserInput> | DeviceTokenCreateWithoutUserInput[] | DeviceTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceTokenCreateOrConnectWithoutUserInput | DeviceTokenCreateOrConnectWithoutUserInput[]
    upsert?: DeviceTokenUpsertWithWhereUniqueWithoutUserInput | DeviceTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeviceTokenCreateManyUserInputEnvelope
    set?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    disconnect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    delete?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    connect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    update?: DeviceTokenUpdateWithWhereUniqueWithoutUserInput | DeviceTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeviceTokenUpdateManyWithWhereWithoutUserInput | DeviceTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeviceTokenScalarWhereInput | DeviceTokenScalarWhereInput[]
  }

  export type ExecutiveUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ExecutiveCreateWithoutUserInput, ExecutiveUncheckedCreateWithoutUserInput>
    connectOrCreate?: ExecutiveCreateOrConnectWithoutUserInput
    upsert?: ExecutiveUpsertWithoutUserInput
    disconnect?: ExecutiveWhereInput | boolean
    delete?: ExecutiveWhereInput | boolean
    connect?: ExecutiveWhereUniqueInput
    update?: XOR<XOR<ExecutiveUpdateToOneWithWhereWithoutUserInput, ExecutiveUpdateWithoutUserInput>, ExecutiveUncheckedUpdateWithoutUserInput>
  }

  export type LocationTrackUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LocationTrackCreateWithoutUserInput, LocationTrackUncheckedCreateWithoutUserInput> | LocationTrackCreateWithoutUserInput[] | LocationTrackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LocationTrackCreateOrConnectWithoutUserInput | LocationTrackCreateOrConnectWithoutUserInput[]
    upsert?: LocationTrackUpsertWithWhereUniqueWithoutUserInput | LocationTrackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LocationTrackCreateManyUserInputEnvelope
    set?: LocationTrackWhereUniqueInput | LocationTrackWhereUniqueInput[]
    disconnect?: LocationTrackWhereUniqueInput | LocationTrackWhereUniqueInput[]
    delete?: LocationTrackWhereUniqueInput | LocationTrackWhereUniqueInput[]
    connect?: LocationTrackWhereUniqueInput | LocationTrackWhereUniqueInput[]
    update?: LocationTrackUpdateWithWhereUniqueWithoutUserInput | LocationTrackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LocationTrackUpdateManyWithWhereWithoutUserInput | LocationTrackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LocationTrackScalarWhereInput | LocationTrackScalarWhereInput[]
  }

  export type NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferenceUpsertWithoutUserInput
    disconnect?: NotificationPreferenceWhereInput | boolean
    delete?: NotificationPreferenceWhereInput | boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<XOR<NotificationPreferenceUpdateToOneWithWhereWithoutUserInput, NotificationPreferenceUpdateWithoutUserInput>, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OTPCodeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OTPCodeCreateWithoutUserInput, OTPCodeUncheckedCreateWithoutUserInput> | OTPCodeCreateWithoutUserInput[] | OTPCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OTPCodeCreateOrConnectWithoutUserInput | OTPCodeCreateOrConnectWithoutUserInput[]
    upsert?: OTPCodeUpsertWithWhereUniqueWithoutUserInput | OTPCodeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OTPCodeCreateManyUserInputEnvelope
    set?: OTPCodeWhereUniqueInput | OTPCodeWhereUniqueInput[]
    disconnect?: OTPCodeWhereUniqueInput | OTPCodeWhereUniqueInput[]
    delete?: OTPCodeWhereUniqueInput | OTPCodeWhereUniqueInput[]
    connect?: OTPCodeWhereUniqueInput | OTPCodeWhereUniqueInput[]
    update?: OTPCodeUpdateWithWhereUniqueWithoutUserInput | OTPCodeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OTPCodeUpdateManyWithWhereWithoutUserInput | OTPCodeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OTPCodeScalarWhereInput | OTPCodeScalarWhereInput[]
  }

  export type PaymentEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentEventCreateWithoutUserInput, PaymentEventUncheckedCreateWithoutUserInput> | PaymentEventCreateWithoutUserInput[] | PaymentEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentEventCreateOrConnectWithoutUserInput | PaymentEventCreateOrConnectWithoutUserInput[]
    upsert?: PaymentEventUpsertWithWhereUniqueWithoutUserInput | PaymentEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentEventCreateManyUserInputEnvelope
    set?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    disconnect?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    delete?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    connect?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    update?: PaymentEventUpdateWithWhereUniqueWithoutUserInput | PaymentEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentEventUpdateManyWithWhereWithoutUserInput | PaymentEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentEventScalarWhereInput | PaymentEventScalarWhereInput[]
  }

  export type PetOwnerUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PetOwnerCreateWithoutUserInput, PetOwnerUncheckedCreateWithoutUserInput>
    connectOrCreate?: PetOwnerCreateOrConnectWithoutUserInput
    upsert?: PetOwnerUpsertWithoutUserInput
    disconnect?: PetOwnerWhereInput | boolean
    delete?: PetOwnerWhereInput | boolean
    connect?: PetOwnerWhereUniqueInput
    update?: XOR<XOR<PetOwnerUpdateToOneWithWhereWithoutUserInput, PetOwnerUpdateWithoutUserInput>, PetOwnerUncheckedUpdateWithoutUserInput>
  }

  export type PetUncheckedUpdateManyWithoutRegisteredByUserNestedInput = {
    create?: XOR<PetCreateWithoutRegisteredByUserInput, PetUncheckedCreateWithoutRegisteredByUserInput> | PetCreateWithoutRegisteredByUserInput[] | PetUncheckedCreateWithoutRegisteredByUserInput[]
    connectOrCreate?: PetCreateOrConnectWithoutRegisteredByUserInput | PetCreateOrConnectWithoutRegisteredByUserInput[]
    upsert?: PetUpsertWithWhereUniqueWithoutRegisteredByUserInput | PetUpsertWithWhereUniqueWithoutRegisteredByUserInput[]
    createMany?: PetCreateManyRegisteredByUserInputEnvelope
    set?: PetWhereUniqueInput | PetWhereUniqueInput[]
    disconnect?: PetWhereUniqueInput | PetWhereUniqueInput[]
    delete?: PetWhereUniqueInput | PetWhereUniqueInput[]
    connect?: PetWhereUniqueInput | PetWhereUniqueInput[]
    update?: PetUpdateWithWhereUniqueWithoutRegisteredByUserInput | PetUpdateWithWhereUniqueWithoutRegisteredByUserInput[]
    updateMany?: PetUpdateManyWithWhereWithoutRegisteredByUserInput | PetUpdateManyWithWhereWithoutRegisteredByUserInput[]
    deleteMany?: PetScalarWhereInput | PetScalarWhereInput[]
  }

  export type SupportMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<SupportMessageCreateWithoutSenderInput, SupportMessageUncheckedCreateWithoutSenderInput> | SupportMessageCreateWithoutSenderInput[] | SupportMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: SupportMessageCreateOrConnectWithoutSenderInput | SupportMessageCreateOrConnectWithoutSenderInput[]
    upsert?: SupportMessageUpsertWithWhereUniqueWithoutSenderInput | SupportMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: SupportMessageCreateManySenderInputEnvelope
    set?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    disconnect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    delete?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    update?: SupportMessageUpdateWithWhereUniqueWithoutSenderInput | SupportMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: SupportMessageUpdateManyWithWhereWithoutSenderInput | SupportMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: SupportMessageScalarWhereInput | SupportMessageScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutAssignedToUserNestedInput = {
    create?: XOR<SupportTicketCreateWithoutAssignedToUserInput, SupportTicketUncheckedCreateWithoutAssignedToUserInput> | SupportTicketCreateWithoutAssignedToUserInput[] | SupportTicketUncheckedCreateWithoutAssignedToUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAssignedToUserInput | SupportTicketCreateOrConnectWithoutAssignedToUserInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutAssignedToUserInput | SupportTicketUpsertWithWhereUniqueWithoutAssignedToUserInput[]
    createMany?: SupportTicketCreateManyAssignedToUserInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutAssignedToUserInput | SupportTicketUpdateWithWhereUniqueWithoutAssignedToUserInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutAssignedToUserInput | SupportTicketUpdateManyWithWhereWithoutAssignedToUserInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutUserInput | SupportTicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutUserInput | SupportTicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutUserInput | SupportTicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type UserSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOtpCodesInput = {
    create?: XOR<UserCreateWithoutOtpCodesInput, UserUncheckedCreateWithoutOtpCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpCodesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumOTPPurposeFieldUpdateOperationsInput = {
    set?: $Enums.OTPPurpose
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutOtpCodesNestedInput = {
    create?: XOR<UserCreateWithoutOtpCodesInput, UserUncheckedCreateWithoutOtpCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpCodesInput
    upsert?: UserUpsertWithoutOtpCodesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOtpCodesInput, UserUpdateWithoutOtpCodesInput>, UserUncheckedUpdateWithoutOtpCodesInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutExecutiveInput = {
    create?: XOR<UserCreateWithoutExecutiveInput, UserUncheckedCreateWithoutExecutiveInput>
    connectOrCreate?: UserCreateOrConnectWithoutExecutiveInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutExecutiveNestedInput = {
    create?: XOR<UserCreateWithoutExecutiveInput, UserUncheckedCreateWithoutExecutiveInput>
    connectOrCreate?: UserCreateOrConnectWithoutExecutiveInput
    upsert?: UserUpsertWithoutExecutiveInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExecutiveInput, UserUpdateWithoutExecutiveInput>, UserUncheckedUpdateWithoutExecutiveInput>
  }

  export type UserCreateNestedOneWithoutPetOwnerInput = {
    create?: XOR<UserCreateWithoutPetOwnerInput, UserUncheckedCreateWithoutPetOwnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutPetOwnerInput
    connect?: UserWhereUniqueInput
  }

  export type PetCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PetCreateWithoutOwnerInput, PetUncheckedCreateWithoutOwnerInput> | PetCreateWithoutOwnerInput[] | PetUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PetCreateOrConnectWithoutOwnerInput | PetCreateOrConnectWithoutOwnerInput[]
    createMany?: PetCreateManyOwnerInputEnvelope
    connect?: PetWhereUniqueInput | PetWhereUniqueInput[]
  }

  export type PetUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PetCreateWithoutOwnerInput, PetUncheckedCreateWithoutOwnerInput> | PetCreateWithoutOwnerInput[] | PetUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PetCreateOrConnectWithoutOwnerInput | PetCreateOrConnectWithoutOwnerInput[]
    createMany?: PetCreateManyOwnerInputEnvelope
    connect?: PetWhereUniqueInput | PetWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPetOwnerNestedInput = {
    create?: XOR<UserCreateWithoutPetOwnerInput, UserUncheckedCreateWithoutPetOwnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutPetOwnerInput
    upsert?: UserUpsertWithoutPetOwnerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPetOwnerInput, UserUpdateWithoutPetOwnerInput>, UserUncheckedUpdateWithoutPetOwnerInput>
  }

  export type PetUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PetCreateWithoutOwnerInput, PetUncheckedCreateWithoutOwnerInput> | PetCreateWithoutOwnerInput[] | PetUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PetCreateOrConnectWithoutOwnerInput | PetCreateOrConnectWithoutOwnerInput[]
    upsert?: PetUpsertWithWhereUniqueWithoutOwnerInput | PetUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PetCreateManyOwnerInputEnvelope
    set?: PetWhereUniqueInput | PetWhereUniqueInput[]
    disconnect?: PetWhereUniqueInput | PetWhereUniqueInput[]
    delete?: PetWhereUniqueInput | PetWhereUniqueInput[]
    connect?: PetWhereUniqueInput | PetWhereUniqueInput[]
    update?: PetUpdateWithWhereUniqueWithoutOwnerInput | PetUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PetUpdateManyWithWhereWithoutOwnerInput | PetUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PetScalarWhereInput | PetScalarWhereInput[]
  }

  export type PetUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PetCreateWithoutOwnerInput, PetUncheckedCreateWithoutOwnerInput> | PetCreateWithoutOwnerInput[] | PetUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PetCreateOrConnectWithoutOwnerInput | PetCreateOrConnectWithoutOwnerInput[]
    upsert?: PetUpsertWithWhereUniqueWithoutOwnerInput | PetUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PetCreateManyOwnerInputEnvelope
    set?: PetWhereUniqueInput | PetWhereUniqueInput[]
    disconnect?: PetWhereUniqueInput | PetWhereUniqueInput[]
    delete?: PetWhereUniqueInput | PetWhereUniqueInput[]
    connect?: PetWhereUniqueInput | PetWhereUniqueInput[]
    update?: PetUpdateWithWhereUniqueWithoutOwnerInput | PetUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PetUpdateManyWithWhereWithoutOwnerInput | PetUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PetScalarWhereInput | PetScalarWhereInput[]
  }

  export type PetBreedCreateNestedManyWithoutSpeciesInput = {
    create?: XOR<PetBreedCreateWithoutSpeciesInput, PetBreedUncheckedCreateWithoutSpeciesInput> | PetBreedCreateWithoutSpeciesInput[] | PetBreedUncheckedCreateWithoutSpeciesInput[]
    connectOrCreate?: PetBreedCreateOrConnectWithoutSpeciesInput | PetBreedCreateOrConnectWithoutSpeciesInput[]
    createMany?: PetBreedCreateManySpeciesInputEnvelope
    connect?: PetBreedWhereUniqueInput | PetBreedWhereUniqueInput[]
  }

  export type PetCreateNestedManyWithoutSpeciesInput = {
    create?: XOR<PetCreateWithoutSpeciesInput, PetUncheckedCreateWithoutSpeciesInput> | PetCreateWithoutSpeciesInput[] | PetUncheckedCreateWithoutSpeciesInput[]
    connectOrCreate?: PetCreateOrConnectWithoutSpeciesInput | PetCreateOrConnectWithoutSpeciesInput[]
    createMany?: PetCreateManySpeciesInputEnvelope
    connect?: PetWhereUniqueInput | PetWhereUniqueInput[]
  }

  export type PetBreedUncheckedCreateNestedManyWithoutSpeciesInput = {
    create?: XOR<PetBreedCreateWithoutSpeciesInput, PetBreedUncheckedCreateWithoutSpeciesInput> | PetBreedCreateWithoutSpeciesInput[] | PetBreedUncheckedCreateWithoutSpeciesInput[]
    connectOrCreate?: PetBreedCreateOrConnectWithoutSpeciesInput | PetBreedCreateOrConnectWithoutSpeciesInput[]
    createMany?: PetBreedCreateManySpeciesInputEnvelope
    connect?: PetBreedWhereUniqueInput | PetBreedWhereUniqueInput[]
  }

  export type PetUncheckedCreateNestedManyWithoutSpeciesInput = {
    create?: XOR<PetCreateWithoutSpeciesInput, PetUncheckedCreateWithoutSpeciesInput> | PetCreateWithoutSpeciesInput[] | PetUncheckedCreateWithoutSpeciesInput[]
    connectOrCreate?: PetCreateOrConnectWithoutSpeciesInput | PetCreateOrConnectWithoutSpeciesInput[]
    createMany?: PetCreateManySpeciesInputEnvelope
    connect?: PetWhereUniqueInput | PetWhereUniqueInput[]
  }

  export type PetBreedUpdateManyWithoutSpeciesNestedInput = {
    create?: XOR<PetBreedCreateWithoutSpeciesInput, PetBreedUncheckedCreateWithoutSpeciesInput> | PetBreedCreateWithoutSpeciesInput[] | PetBreedUncheckedCreateWithoutSpeciesInput[]
    connectOrCreate?: PetBreedCreateOrConnectWithoutSpeciesInput | PetBreedCreateOrConnectWithoutSpeciesInput[]
    upsert?: PetBreedUpsertWithWhereUniqueWithoutSpeciesInput | PetBreedUpsertWithWhereUniqueWithoutSpeciesInput[]
    createMany?: PetBreedCreateManySpeciesInputEnvelope
    set?: PetBreedWhereUniqueInput | PetBreedWhereUniqueInput[]
    disconnect?: PetBreedWhereUniqueInput | PetBreedWhereUniqueInput[]
    delete?: PetBreedWhereUniqueInput | PetBreedWhereUniqueInput[]
    connect?: PetBreedWhereUniqueInput | PetBreedWhereUniqueInput[]
    update?: PetBreedUpdateWithWhereUniqueWithoutSpeciesInput | PetBreedUpdateWithWhereUniqueWithoutSpeciesInput[]
    updateMany?: PetBreedUpdateManyWithWhereWithoutSpeciesInput | PetBreedUpdateManyWithWhereWithoutSpeciesInput[]
    deleteMany?: PetBreedScalarWhereInput | PetBreedScalarWhereInput[]
  }

  export type PetUpdateManyWithoutSpeciesNestedInput = {
    create?: XOR<PetCreateWithoutSpeciesInput, PetUncheckedCreateWithoutSpeciesInput> | PetCreateWithoutSpeciesInput[] | PetUncheckedCreateWithoutSpeciesInput[]
    connectOrCreate?: PetCreateOrConnectWithoutSpeciesInput | PetCreateOrConnectWithoutSpeciesInput[]
    upsert?: PetUpsertWithWhereUniqueWithoutSpeciesInput | PetUpsertWithWhereUniqueWithoutSpeciesInput[]
    createMany?: PetCreateManySpeciesInputEnvelope
    set?: PetWhereUniqueInput | PetWhereUniqueInput[]
    disconnect?: PetWhereUniqueInput | PetWhereUniqueInput[]
    delete?: PetWhereUniqueInput | PetWhereUniqueInput[]
    connect?: PetWhereUniqueInput | PetWhereUniqueInput[]
    update?: PetUpdateWithWhereUniqueWithoutSpeciesInput | PetUpdateWithWhereUniqueWithoutSpeciesInput[]
    updateMany?: PetUpdateManyWithWhereWithoutSpeciesInput | PetUpdateManyWithWhereWithoutSpeciesInput[]
    deleteMany?: PetScalarWhereInput | PetScalarWhereInput[]
  }

  export type PetBreedUncheckedUpdateManyWithoutSpeciesNestedInput = {
    create?: XOR<PetBreedCreateWithoutSpeciesInput, PetBreedUncheckedCreateWithoutSpeciesInput> | PetBreedCreateWithoutSpeciesInput[] | PetBreedUncheckedCreateWithoutSpeciesInput[]
    connectOrCreate?: PetBreedCreateOrConnectWithoutSpeciesInput | PetBreedCreateOrConnectWithoutSpeciesInput[]
    upsert?: PetBreedUpsertWithWhereUniqueWithoutSpeciesInput | PetBreedUpsertWithWhereUniqueWithoutSpeciesInput[]
    createMany?: PetBreedCreateManySpeciesInputEnvelope
    set?: PetBreedWhereUniqueInput | PetBreedWhereUniqueInput[]
    disconnect?: PetBreedWhereUniqueInput | PetBreedWhereUniqueInput[]
    delete?: PetBreedWhereUniqueInput | PetBreedWhereUniqueInput[]
    connect?: PetBreedWhereUniqueInput | PetBreedWhereUniqueInput[]
    update?: PetBreedUpdateWithWhereUniqueWithoutSpeciesInput | PetBreedUpdateWithWhereUniqueWithoutSpeciesInput[]
    updateMany?: PetBreedUpdateManyWithWhereWithoutSpeciesInput | PetBreedUpdateManyWithWhereWithoutSpeciesInput[]
    deleteMany?: PetBreedScalarWhereInput | PetBreedScalarWhereInput[]
  }

  export type PetUncheckedUpdateManyWithoutSpeciesNestedInput = {
    create?: XOR<PetCreateWithoutSpeciesInput, PetUncheckedCreateWithoutSpeciesInput> | PetCreateWithoutSpeciesInput[] | PetUncheckedCreateWithoutSpeciesInput[]
    connectOrCreate?: PetCreateOrConnectWithoutSpeciesInput | PetCreateOrConnectWithoutSpeciesInput[]
    upsert?: PetUpsertWithWhereUniqueWithoutSpeciesInput | PetUpsertWithWhereUniqueWithoutSpeciesInput[]
    createMany?: PetCreateManySpeciesInputEnvelope
    set?: PetWhereUniqueInput | PetWhereUniqueInput[]
    disconnect?: PetWhereUniqueInput | PetWhereUniqueInput[]
    delete?: PetWhereUniqueInput | PetWhereUniqueInput[]
    connect?: PetWhereUniqueInput | PetWhereUniqueInput[]
    update?: PetUpdateWithWhereUniqueWithoutSpeciesInput | PetUpdateWithWhereUniqueWithoutSpeciesInput[]
    updateMany?: PetUpdateManyWithWhereWithoutSpeciesInput | PetUpdateManyWithWhereWithoutSpeciesInput[]
    deleteMany?: PetScalarWhereInput | PetScalarWhereInput[]
  }

  export type PetSpeciesCreateNestedOneWithoutBreedsInput = {
    create?: XOR<PetSpeciesCreateWithoutBreedsInput, PetSpeciesUncheckedCreateWithoutBreedsInput>
    connectOrCreate?: PetSpeciesCreateOrConnectWithoutBreedsInput
    connect?: PetSpeciesWhereUniqueInput
  }

  export type PetCreateNestedManyWithoutPet_breeds_pets_breed_idTopet_breedsInput = {
    create?: XOR<PetCreateWithoutPet_breeds_pets_breed_idTopet_breedsInput, PetUncheckedCreateWithoutPet_breeds_pets_breed_idTopet_breedsInput> | PetCreateWithoutPet_breeds_pets_breed_idTopet_breedsInput[] | PetUncheckedCreateWithoutPet_breeds_pets_breed_idTopet_breedsInput[]
    connectOrCreate?: PetCreateOrConnectWithoutPet_breeds_pets_breed_idTopet_breedsInput | PetCreateOrConnectWithoutPet_breeds_pets_breed_idTopet_breedsInput[]
    createMany?: PetCreateManyPet_breeds_pets_breed_idTopet_breedsInputEnvelope
    connect?: PetWhereUniqueInput | PetWhereUniqueInput[]
  }

  export type PetCreateNestedManyWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput = {
    create?: XOR<PetCreateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput, PetUncheckedCreateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput> | PetCreateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput[] | PetUncheckedCreateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput[]
    connectOrCreate?: PetCreateOrConnectWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput | PetCreateOrConnectWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput[]
    createMany?: PetCreateManyPet_breeds_pets_secondary_breed_idTopet_breedsInputEnvelope
    connect?: PetWhereUniqueInput | PetWhereUniqueInput[]
  }

  export type PetUncheckedCreateNestedManyWithoutPet_breeds_pets_breed_idTopet_breedsInput = {
    create?: XOR<PetCreateWithoutPet_breeds_pets_breed_idTopet_breedsInput, PetUncheckedCreateWithoutPet_breeds_pets_breed_idTopet_breedsInput> | PetCreateWithoutPet_breeds_pets_breed_idTopet_breedsInput[] | PetUncheckedCreateWithoutPet_breeds_pets_breed_idTopet_breedsInput[]
    connectOrCreate?: PetCreateOrConnectWithoutPet_breeds_pets_breed_idTopet_breedsInput | PetCreateOrConnectWithoutPet_breeds_pets_breed_idTopet_breedsInput[]
    createMany?: PetCreateManyPet_breeds_pets_breed_idTopet_breedsInputEnvelope
    connect?: PetWhereUniqueInput | PetWhereUniqueInput[]
  }

  export type PetUncheckedCreateNestedManyWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput = {
    create?: XOR<PetCreateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput, PetUncheckedCreateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput> | PetCreateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput[] | PetUncheckedCreateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput[]
    connectOrCreate?: PetCreateOrConnectWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput | PetCreateOrConnectWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput[]
    createMany?: PetCreateManyPet_breeds_pets_secondary_breed_idTopet_breedsInputEnvelope
    connect?: PetWhereUniqueInput | PetWhereUniqueInput[]
  }

  export type NullableEnumSizeCategoryFieldUpdateOperationsInput = {
    set?: $Enums.SizeCategory | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PetSpeciesUpdateOneRequiredWithoutBreedsNestedInput = {
    create?: XOR<PetSpeciesCreateWithoutBreedsInput, PetSpeciesUncheckedCreateWithoutBreedsInput>
    connectOrCreate?: PetSpeciesCreateOrConnectWithoutBreedsInput
    upsert?: PetSpeciesUpsertWithoutBreedsInput
    connect?: PetSpeciesWhereUniqueInput
    update?: XOR<XOR<PetSpeciesUpdateToOneWithWhereWithoutBreedsInput, PetSpeciesUpdateWithoutBreedsInput>, PetSpeciesUncheckedUpdateWithoutBreedsInput>
  }

  export type PetUpdateManyWithoutPet_breeds_pets_breed_idTopet_breedsNestedInput = {
    create?: XOR<PetCreateWithoutPet_breeds_pets_breed_idTopet_breedsInput, PetUncheckedCreateWithoutPet_breeds_pets_breed_idTopet_breedsInput> | PetCreateWithoutPet_breeds_pets_breed_idTopet_breedsInput[] | PetUncheckedCreateWithoutPet_breeds_pets_breed_idTopet_breedsInput[]
    connectOrCreate?: PetCreateOrConnectWithoutPet_breeds_pets_breed_idTopet_breedsInput | PetCreateOrConnectWithoutPet_breeds_pets_breed_idTopet_breedsInput[]
    upsert?: PetUpsertWithWhereUniqueWithoutPet_breeds_pets_breed_idTopet_breedsInput | PetUpsertWithWhereUniqueWithoutPet_breeds_pets_breed_idTopet_breedsInput[]
    createMany?: PetCreateManyPet_breeds_pets_breed_idTopet_breedsInputEnvelope
    set?: PetWhereUniqueInput | PetWhereUniqueInput[]
    disconnect?: PetWhereUniqueInput | PetWhereUniqueInput[]
    delete?: PetWhereUniqueInput | PetWhereUniqueInput[]
    connect?: PetWhereUniqueInput | PetWhereUniqueInput[]
    update?: PetUpdateWithWhereUniqueWithoutPet_breeds_pets_breed_idTopet_breedsInput | PetUpdateWithWhereUniqueWithoutPet_breeds_pets_breed_idTopet_breedsInput[]
    updateMany?: PetUpdateManyWithWhereWithoutPet_breeds_pets_breed_idTopet_breedsInput | PetUpdateManyWithWhereWithoutPet_breeds_pets_breed_idTopet_breedsInput[]
    deleteMany?: PetScalarWhereInput | PetScalarWhereInput[]
  }

  export type PetUpdateManyWithoutPet_breeds_pets_secondary_breed_idTopet_breedsNestedInput = {
    create?: XOR<PetCreateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput, PetUncheckedCreateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput> | PetCreateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput[] | PetUncheckedCreateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput[]
    connectOrCreate?: PetCreateOrConnectWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput | PetCreateOrConnectWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput[]
    upsert?: PetUpsertWithWhereUniqueWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput | PetUpsertWithWhereUniqueWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput[]
    createMany?: PetCreateManyPet_breeds_pets_secondary_breed_idTopet_breedsInputEnvelope
    set?: PetWhereUniqueInput | PetWhereUniqueInput[]
    disconnect?: PetWhereUniqueInput | PetWhereUniqueInput[]
    delete?: PetWhereUniqueInput | PetWhereUniqueInput[]
    connect?: PetWhereUniqueInput | PetWhereUniqueInput[]
    update?: PetUpdateWithWhereUniqueWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput | PetUpdateWithWhereUniqueWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput[]
    updateMany?: PetUpdateManyWithWhereWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput | PetUpdateManyWithWhereWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput[]
    deleteMany?: PetScalarWhereInput | PetScalarWhereInput[]
  }

  export type PetUncheckedUpdateManyWithoutPet_breeds_pets_breed_idTopet_breedsNestedInput = {
    create?: XOR<PetCreateWithoutPet_breeds_pets_breed_idTopet_breedsInput, PetUncheckedCreateWithoutPet_breeds_pets_breed_idTopet_breedsInput> | PetCreateWithoutPet_breeds_pets_breed_idTopet_breedsInput[] | PetUncheckedCreateWithoutPet_breeds_pets_breed_idTopet_breedsInput[]
    connectOrCreate?: PetCreateOrConnectWithoutPet_breeds_pets_breed_idTopet_breedsInput | PetCreateOrConnectWithoutPet_breeds_pets_breed_idTopet_breedsInput[]
    upsert?: PetUpsertWithWhereUniqueWithoutPet_breeds_pets_breed_idTopet_breedsInput | PetUpsertWithWhereUniqueWithoutPet_breeds_pets_breed_idTopet_breedsInput[]
    createMany?: PetCreateManyPet_breeds_pets_breed_idTopet_breedsInputEnvelope
    set?: PetWhereUniqueInput | PetWhereUniqueInput[]
    disconnect?: PetWhereUniqueInput | PetWhereUniqueInput[]
    delete?: PetWhereUniqueInput | PetWhereUniqueInput[]
    connect?: PetWhereUniqueInput | PetWhereUniqueInput[]
    update?: PetUpdateWithWhereUniqueWithoutPet_breeds_pets_breed_idTopet_breedsInput | PetUpdateWithWhereUniqueWithoutPet_breeds_pets_breed_idTopet_breedsInput[]
    updateMany?: PetUpdateManyWithWhereWithoutPet_breeds_pets_breed_idTopet_breedsInput | PetUpdateManyWithWhereWithoutPet_breeds_pets_breed_idTopet_breedsInput[]
    deleteMany?: PetScalarWhereInput | PetScalarWhereInput[]
  }

  export type PetUncheckedUpdateManyWithoutPet_breeds_pets_secondary_breed_idTopet_breedsNestedInput = {
    create?: XOR<PetCreateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput, PetUncheckedCreateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput> | PetCreateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput[] | PetUncheckedCreateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput[]
    connectOrCreate?: PetCreateOrConnectWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput | PetCreateOrConnectWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput[]
    upsert?: PetUpsertWithWhereUniqueWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput | PetUpsertWithWhereUniqueWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput[]
    createMany?: PetCreateManyPet_breeds_pets_secondary_breed_idTopet_breedsInputEnvelope
    set?: PetWhereUniqueInput | PetWhereUniqueInput[]
    disconnect?: PetWhereUniqueInput | PetWhereUniqueInput[]
    delete?: PetWhereUniqueInput | PetWhereUniqueInput[]
    connect?: PetWhereUniqueInput | PetWhereUniqueInput[]
    update?: PetUpdateWithWhereUniqueWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput | PetUpdateWithWhereUniqueWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput[]
    updateMany?: PetUpdateManyWithWhereWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput | PetUpdateManyWithWhereWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput[]
    deleteMany?: PetScalarWhereInput | PetScalarWhereInput[]
  }

  export type MedicalRecordCreateNestedManyWithoutPetInput = {
    create?: XOR<MedicalRecordCreateWithoutPetInput, MedicalRecordUncheckedCreateWithoutPetInput> | MedicalRecordCreateWithoutPetInput[] | MedicalRecordUncheckedCreateWithoutPetInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutPetInput | MedicalRecordCreateOrConnectWithoutPetInput[]
    createMany?: MedicalRecordCreateManyPetInputEnvelope
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutPetInput = {
    create?: XOR<NotificationCreateWithoutPetInput, NotificationUncheckedCreateWithoutPetInput> | NotificationCreateWithoutPetInput[] | NotificationUncheckedCreateWithoutPetInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPetInput | NotificationCreateOrConnectWithoutPetInput[]
    createMany?: NotificationCreateManyPetInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PaymentEventCreateNestedManyWithoutPetInput = {
    create?: XOR<PaymentEventCreateWithoutPetInput, PaymentEventUncheckedCreateWithoutPetInput> | PaymentEventCreateWithoutPetInput[] | PaymentEventUncheckedCreateWithoutPetInput[]
    connectOrCreate?: PaymentEventCreateOrConnectWithoutPetInput | PaymentEventCreateOrConnectWithoutPetInput[]
    createMany?: PaymentEventCreateManyPetInputEnvelope
    connect?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
  }

  export type PetLocationEventCreateNestedManyWithoutPetInput = {
    create?: XOR<PetLocationEventCreateWithoutPetInput, PetLocationEventUncheckedCreateWithoutPetInput> | PetLocationEventCreateWithoutPetInput[] | PetLocationEventUncheckedCreateWithoutPetInput[]
    connectOrCreate?: PetLocationEventCreateOrConnectWithoutPetInput | PetLocationEventCreateOrConnectWithoutPetInput[]
    createMany?: PetLocationEventCreateManyPetInputEnvelope
    connect?: PetLocationEventWhereUniqueInput | PetLocationEventWhereUniqueInput[]
  }

  export type QRScanEventCreateNestedManyWithoutPetInput = {
    create?: XOR<QRScanEventCreateWithoutPetInput, QRScanEventUncheckedCreateWithoutPetInput> | QRScanEventCreateWithoutPetInput[] | QRScanEventUncheckedCreateWithoutPetInput[]
    connectOrCreate?: QRScanEventCreateOrConnectWithoutPetInput | QRScanEventCreateOrConnectWithoutPetInput[]
    createMany?: QRScanEventCreateManyPetInputEnvelope
    connect?: QRScanEventWhereUniqueInput | QRScanEventWhereUniqueInput[]
  }

  export type PetBreedCreateNestedOneWithoutPets_pets_breed_idTopet_breedsInput = {
    create?: XOR<PetBreedCreateWithoutPets_pets_breed_idTopet_breedsInput, PetBreedUncheckedCreateWithoutPets_pets_breed_idTopet_breedsInput>
    connectOrCreate?: PetBreedCreateOrConnectWithoutPets_pets_breed_idTopet_breedsInput
    connect?: PetBreedWhereUniqueInput
  }

  export type PetOwnerCreateNestedOneWithoutPetsInput = {
    create?: XOR<PetOwnerCreateWithoutPetsInput, PetOwnerUncheckedCreateWithoutPetsInput>
    connectOrCreate?: PetOwnerCreateOrConnectWithoutPetsInput
    connect?: PetOwnerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRegisteredPetsInput = {
    create?: XOR<UserCreateWithoutRegisteredPetsInput, UserUncheckedCreateWithoutRegisteredPetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRegisteredPetsInput
    connect?: UserWhereUniqueInput
  }

  export type PetBreedCreateNestedOneWithoutPets_pets_secondary_breed_idTopet_breedsInput = {
    create?: XOR<PetBreedCreateWithoutPets_pets_secondary_breed_idTopet_breedsInput, PetBreedUncheckedCreateWithoutPets_pets_secondary_breed_idTopet_breedsInput>
    connectOrCreate?: PetBreedCreateOrConnectWithoutPets_pets_secondary_breed_idTopet_breedsInput
    connect?: PetBreedWhereUniqueInput
  }

  export type PetSpeciesCreateNestedOneWithoutPetsInput = {
    create?: XOR<PetSpeciesCreateWithoutPetsInput, PetSpeciesUncheckedCreateWithoutPetsInput>
    connectOrCreate?: PetSpeciesCreateOrConnectWithoutPetsInput
    connect?: PetSpeciesWhereUniqueInput
  }

  export type QRCodeCreateNestedManyWithoutPetInput = {
    create?: XOR<QRCodeCreateWithoutPetInput, QRCodeUncheckedCreateWithoutPetInput> | QRCodeCreateWithoutPetInput[] | QRCodeUncheckedCreateWithoutPetInput[]
    connectOrCreate?: QRCodeCreateOrConnectWithoutPetInput | QRCodeCreateOrConnectWithoutPetInput[]
    createMany?: QRCodeCreateManyPetInputEnvelope
    connect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutPetInput = {
    create?: XOR<SupportTicketCreateWithoutPetInput, SupportTicketUncheckedCreateWithoutPetInput> | SupportTicketCreateWithoutPetInput[] | SupportTicketUncheckedCreateWithoutPetInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutPetInput | SupportTicketCreateOrConnectWithoutPetInput[]
    createMany?: SupportTicketCreateManyPetInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type VaccinationRecordCreateNestedManyWithoutPetInput = {
    create?: XOR<VaccinationRecordCreateWithoutPetInput, VaccinationRecordUncheckedCreateWithoutPetInput> | VaccinationRecordCreateWithoutPetInput[] | VaccinationRecordUncheckedCreateWithoutPetInput[]
    connectOrCreate?: VaccinationRecordCreateOrConnectWithoutPetInput | VaccinationRecordCreateOrConnectWithoutPetInput[]
    createMany?: VaccinationRecordCreateManyPetInputEnvelope
    connect?: VaccinationRecordWhereUniqueInput | VaccinationRecordWhereUniqueInput[]
  }

  export type MedicalRecordUncheckedCreateNestedManyWithoutPetInput = {
    create?: XOR<MedicalRecordCreateWithoutPetInput, MedicalRecordUncheckedCreateWithoutPetInput> | MedicalRecordCreateWithoutPetInput[] | MedicalRecordUncheckedCreateWithoutPetInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutPetInput | MedicalRecordCreateOrConnectWithoutPetInput[]
    createMany?: MedicalRecordCreateManyPetInputEnvelope
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutPetInput = {
    create?: XOR<NotificationCreateWithoutPetInput, NotificationUncheckedCreateWithoutPetInput> | NotificationCreateWithoutPetInput[] | NotificationUncheckedCreateWithoutPetInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPetInput | NotificationCreateOrConnectWithoutPetInput[]
    createMany?: NotificationCreateManyPetInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PaymentEventUncheckedCreateNestedManyWithoutPetInput = {
    create?: XOR<PaymentEventCreateWithoutPetInput, PaymentEventUncheckedCreateWithoutPetInput> | PaymentEventCreateWithoutPetInput[] | PaymentEventUncheckedCreateWithoutPetInput[]
    connectOrCreate?: PaymentEventCreateOrConnectWithoutPetInput | PaymentEventCreateOrConnectWithoutPetInput[]
    createMany?: PaymentEventCreateManyPetInputEnvelope
    connect?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
  }

  export type PetLocationEventUncheckedCreateNestedManyWithoutPetInput = {
    create?: XOR<PetLocationEventCreateWithoutPetInput, PetLocationEventUncheckedCreateWithoutPetInput> | PetLocationEventCreateWithoutPetInput[] | PetLocationEventUncheckedCreateWithoutPetInput[]
    connectOrCreate?: PetLocationEventCreateOrConnectWithoutPetInput | PetLocationEventCreateOrConnectWithoutPetInput[]
    createMany?: PetLocationEventCreateManyPetInputEnvelope
    connect?: PetLocationEventWhereUniqueInput | PetLocationEventWhereUniqueInput[]
  }

  export type QRScanEventUncheckedCreateNestedManyWithoutPetInput = {
    create?: XOR<QRScanEventCreateWithoutPetInput, QRScanEventUncheckedCreateWithoutPetInput> | QRScanEventCreateWithoutPetInput[] | QRScanEventUncheckedCreateWithoutPetInput[]
    connectOrCreate?: QRScanEventCreateOrConnectWithoutPetInput | QRScanEventCreateOrConnectWithoutPetInput[]
    createMany?: QRScanEventCreateManyPetInputEnvelope
    connect?: QRScanEventWhereUniqueInput | QRScanEventWhereUniqueInput[]
  }

  export type QRCodeUncheckedCreateNestedManyWithoutPetInput = {
    create?: XOR<QRCodeCreateWithoutPetInput, QRCodeUncheckedCreateWithoutPetInput> | QRCodeCreateWithoutPetInput[] | QRCodeUncheckedCreateWithoutPetInput[]
    connectOrCreate?: QRCodeCreateOrConnectWithoutPetInput | QRCodeCreateOrConnectWithoutPetInput[]
    createMany?: QRCodeCreateManyPetInputEnvelope
    connect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutPetInput = {
    create?: XOR<SupportTicketCreateWithoutPetInput, SupportTicketUncheckedCreateWithoutPetInput> | SupportTicketCreateWithoutPetInput[] | SupportTicketUncheckedCreateWithoutPetInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutPetInput | SupportTicketCreateOrConnectWithoutPetInput[]
    createMany?: SupportTicketCreateManyPetInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type VaccinationRecordUncheckedCreateNestedManyWithoutPetInput = {
    create?: XOR<VaccinationRecordCreateWithoutPetInput, VaccinationRecordUncheckedCreateWithoutPetInput> | VaccinationRecordCreateWithoutPetInput[] | VaccinationRecordUncheckedCreateWithoutPetInput[]
    connectOrCreate?: VaccinationRecordCreateOrConnectWithoutPetInput | VaccinationRecordCreateOrConnectWithoutPetInput[]
    createMany?: VaccinationRecordCreateManyPetInputEnvelope
    connect?: VaccinationRecordWhereUniqueInput | VaccinationRecordWhereUniqueInput[]
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type EnumPetStatusFieldUpdateOperationsInput = {
    set?: $Enums.PetStatus
  }

  export type MedicalRecordUpdateManyWithoutPetNestedInput = {
    create?: XOR<MedicalRecordCreateWithoutPetInput, MedicalRecordUncheckedCreateWithoutPetInput> | MedicalRecordCreateWithoutPetInput[] | MedicalRecordUncheckedCreateWithoutPetInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutPetInput | MedicalRecordCreateOrConnectWithoutPetInput[]
    upsert?: MedicalRecordUpsertWithWhereUniqueWithoutPetInput | MedicalRecordUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: MedicalRecordCreateManyPetInputEnvelope
    set?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    disconnect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    delete?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    update?: MedicalRecordUpdateWithWhereUniqueWithoutPetInput | MedicalRecordUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: MedicalRecordUpdateManyWithWhereWithoutPetInput | MedicalRecordUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: MedicalRecordScalarWhereInput | MedicalRecordScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutPetNestedInput = {
    create?: XOR<NotificationCreateWithoutPetInput, NotificationUncheckedCreateWithoutPetInput> | NotificationCreateWithoutPetInput[] | NotificationUncheckedCreateWithoutPetInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPetInput | NotificationCreateOrConnectWithoutPetInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutPetInput | NotificationUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: NotificationCreateManyPetInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutPetInput | NotificationUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutPetInput | NotificationUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PaymentEventUpdateManyWithoutPetNestedInput = {
    create?: XOR<PaymentEventCreateWithoutPetInput, PaymentEventUncheckedCreateWithoutPetInput> | PaymentEventCreateWithoutPetInput[] | PaymentEventUncheckedCreateWithoutPetInput[]
    connectOrCreate?: PaymentEventCreateOrConnectWithoutPetInput | PaymentEventCreateOrConnectWithoutPetInput[]
    upsert?: PaymentEventUpsertWithWhereUniqueWithoutPetInput | PaymentEventUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: PaymentEventCreateManyPetInputEnvelope
    set?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    disconnect?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    delete?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    connect?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    update?: PaymentEventUpdateWithWhereUniqueWithoutPetInput | PaymentEventUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: PaymentEventUpdateManyWithWhereWithoutPetInput | PaymentEventUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: PaymentEventScalarWhereInput | PaymentEventScalarWhereInput[]
  }

  export type PetLocationEventUpdateManyWithoutPetNestedInput = {
    create?: XOR<PetLocationEventCreateWithoutPetInput, PetLocationEventUncheckedCreateWithoutPetInput> | PetLocationEventCreateWithoutPetInput[] | PetLocationEventUncheckedCreateWithoutPetInput[]
    connectOrCreate?: PetLocationEventCreateOrConnectWithoutPetInput | PetLocationEventCreateOrConnectWithoutPetInput[]
    upsert?: PetLocationEventUpsertWithWhereUniqueWithoutPetInput | PetLocationEventUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: PetLocationEventCreateManyPetInputEnvelope
    set?: PetLocationEventWhereUniqueInput | PetLocationEventWhereUniqueInput[]
    disconnect?: PetLocationEventWhereUniqueInput | PetLocationEventWhereUniqueInput[]
    delete?: PetLocationEventWhereUniqueInput | PetLocationEventWhereUniqueInput[]
    connect?: PetLocationEventWhereUniqueInput | PetLocationEventWhereUniqueInput[]
    update?: PetLocationEventUpdateWithWhereUniqueWithoutPetInput | PetLocationEventUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: PetLocationEventUpdateManyWithWhereWithoutPetInput | PetLocationEventUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: PetLocationEventScalarWhereInput | PetLocationEventScalarWhereInput[]
  }

  export type QRScanEventUpdateManyWithoutPetNestedInput = {
    create?: XOR<QRScanEventCreateWithoutPetInput, QRScanEventUncheckedCreateWithoutPetInput> | QRScanEventCreateWithoutPetInput[] | QRScanEventUncheckedCreateWithoutPetInput[]
    connectOrCreate?: QRScanEventCreateOrConnectWithoutPetInput | QRScanEventCreateOrConnectWithoutPetInput[]
    upsert?: QRScanEventUpsertWithWhereUniqueWithoutPetInput | QRScanEventUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: QRScanEventCreateManyPetInputEnvelope
    set?: QRScanEventWhereUniqueInput | QRScanEventWhereUniqueInput[]
    disconnect?: QRScanEventWhereUniqueInput | QRScanEventWhereUniqueInput[]
    delete?: QRScanEventWhereUniqueInput | QRScanEventWhereUniqueInput[]
    connect?: QRScanEventWhereUniqueInput | QRScanEventWhereUniqueInput[]
    update?: QRScanEventUpdateWithWhereUniqueWithoutPetInput | QRScanEventUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: QRScanEventUpdateManyWithWhereWithoutPetInput | QRScanEventUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: QRScanEventScalarWhereInput | QRScanEventScalarWhereInput[]
  }

  export type PetBreedUpdateOneWithoutPets_pets_breed_idTopet_breedsNestedInput = {
    create?: XOR<PetBreedCreateWithoutPets_pets_breed_idTopet_breedsInput, PetBreedUncheckedCreateWithoutPets_pets_breed_idTopet_breedsInput>
    connectOrCreate?: PetBreedCreateOrConnectWithoutPets_pets_breed_idTopet_breedsInput
    upsert?: PetBreedUpsertWithoutPets_pets_breed_idTopet_breedsInput
    disconnect?: PetBreedWhereInput | boolean
    delete?: PetBreedWhereInput | boolean
    connect?: PetBreedWhereUniqueInput
    update?: XOR<XOR<PetBreedUpdateToOneWithWhereWithoutPets_pets_breed_idTopet_breedsInput, PetBreedUpdateWithoutPets_pets_breed_idTopet_breedsInput>, PetBreedUncheckedUpdateWithoutPets_pets_breed_idTopet_breedsInput>
  }

  export type PetOwnerUpdateOneRequiredWithoutPetsNestedInput = {
    create?: XOR<PetOwnerCreateWithoutPetsInput, PetOwnerUncheckedCreateWithoutPetsInput>
    connectOrCreate?: PetOwnerCreateOrConnectWithoutPetsInput
    upsert?: PetOwnerUpsertWithoutPetsInput
    connect?: PetOwnerWhereUniqueInput
    update?: XOR<XOR<PetOwnerUpdateToOneWithWhereWithoutPetsInput, PetOwnerUpdateWithoutPetsInput>, PetOwnerUncheckedUpdateWithoutPetsInput>
  }

  export type UserUpdateOneWithoutRegisteredPetsNestedInput = {
    create?: XOR<UserCreateWithoutRegisteredPetsInput, UserUncheckedCreateWithoutRegisteredPetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRegisteredPetsInput
    upsert?: UserUpsertWithoutRegisteredPetsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRegisteredPetsInput, UserUpdateWithoutRegisteredPetsInput>, UserUncheckedUpdateWithoutRegisteredPetsInput>
  }

  export type PetBreedUpdateOneWithoutPets_pets_secondary_breed_idTopet_breedsNestedInput = {
    create?: XOR<PetBreedCreateWithoutPets_pets_secondary_breed_idTopet_breedsInput, PetBreedUncheckedCreateWithoutPets_pets_secondary_breed_idTopet_breedsInput>
    connectOrCreate?: PetBreedCreateOrConnectWithoutPets_pets_secondary_breed_idTopet_breedsInput
    upsert?: PetBreedUpsertWithoutPets_pets_secondary_breed_idTopet_breedsInput
    disconnect?: PetBreedWhereInput | boolean
    delete?: PetBreedWhereInput | boolean
    connect?: PetBreedWhereUniqueInput
    update?: XOR<XOR<PetBreedUpdateToOneWithWhereWithoutPets_pets_secondary_breed_idTopet_breedsInput, PetBreedUpdateWithoutPets_pets_secondary_breed_idTopet_breedsInput>, PetBreedUncheckedUpdateWithoutPets_pets_secondary_breed_idTopet_breedsInput>
  }

  export type PetSpeciesUpdateOneWithoutPetsNestedInput = {
    create?: XOR<PetSpeciesCreateWithoutPetsInput, PetSpeciesUncheckedCreateWithoutPetsInput>
    connectOrCreate?: PetSpeciesCreateOrConnectWithoutPetsInput
    upsert?: PetSpeciesUpsertWithoutPetsInput
    disconnect?: PetSpeciesWhereInput | boolean
    delete?: PetSpeciesWhereInput | boolean
    connect?: PetSpeciesWhereUniqueInput
    update?: XOR<XOR<PetSpeciesUpdateToOneWithWhereWithoutPetsInput, PetSpeciesUpdateWithoutPetsInput>, PetSpeciesUncheckedUpdateWithoutPetsInput>
  }

  export type QRCodeUpdateManyWithoutPetNestedInput = {
    create?: XOR<QRCodeCreateWithoutPetInput, QRCodeUncheckedCreateWithoutPetInput> | QRCodeCreateWithoutPetInput[] | QRCodeUncheckedCreateWithoutPetInput[]
    connectOrCreate?: QRCodeCreateOrConnectWithoutPetInput | QRCodeCreateOrConnectWithoutPetInput[]
    upsert?: QRCodeUpsertWithWhereUniqueWithoutPetInput | QRCodeUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: QRCodeCreateManyPetInputEnvelope
    set?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    disconnect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    delete?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    connect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    update?: QRCodeUpdateWithWhereUniqueWithoutPetInput | QRCodeUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: QRCodeUpdateManyWithWhereWithoutPetInput | QRCodeUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: QRCodeScalarWhereInput | QRCodeScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutPetNestedInput = {
    create?: XOR<SupportTicketCreateWithoutPetInput, SupportTicketUncheckedCreateWithoutPetInput> | SupportTicketCreateWithoutPetInput[] | SupportTicketUncheckedCreateWithoutPetInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutPetInput | SupportTicketCreateOrConnectWithoutPetInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutPetInput | SupportTicketUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: SupportTicketCreateManyPetInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutPetInput | SupportTicketUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutPetInput | SupportTicketUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type VaccinationRecordUpdateManyWithoutPetNestedInput = {
    create?: XOR<VaccinationRecordCreateWithoutPetInput, VaccinationRecordUncheckedCreateWithoutPetInput> | VaccinationRecordCreateWithoutPetInput[] | VaccinationRecordUncheckedCreateWithoutPetInput[]
    connectOrCreate?: VaccinationRecordCreateOrConnectWithoutPetInput | VaccinationRecordCreateOrConnectWithoutPetInput[]
    upsert?: VaccinationRecordUpsertWithWhereUniqueWithoutPetInput | VaccinationRecordUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: VaccinationRecordCreateManyPetInputEnvelope
    set?: VaccinationRecordWhereUniqueInput | VaccinationRecordWhereUniqueInput[]
    disconnect?: VaccinationRecordWhereUniqueInput | VaccinationRecordWhereUniqueInput[]
    delete?: VaccinationRecordWhereUniqueInput | VaccinationRecordWhereUniqueInput[]
    connect?: VaccinationRecordWhereUniqueInput | VaccinationRecordWhereUniqueInput[]
    update?: VaccinationRecordUpdateWithWhereUniqueWithoutPetInput | VaccinationRecordUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: VaccinationRecordUpdateManyWithWhereWithoutPetInput | VaccinationRecordUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: VaccinationRecordScalarWhereInput | VaccinationRecordScalarWhereInput[]
  }

  export type MedicalRecordUncheckedUpdateManyWithoutPetNestedInput = {
    create?: XOR<MedicalRecordCreateWithoutPetInput, MedicalRecordUncheckedCreateWithoutPetInput> | MedicalRecordCreateWithoutPetInput[] | MedicalRecordUncheckedCreateWithoutPetInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutPetInput | MedicalRecordCreateOrConnectWithoutPetInput[]
    upsert?: MedicalRecordUpsertWithWhereUniqueWithoutPetInput | MedicalRecordUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: MedicalRecordCreateManyPetInputEnvelope
    set?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    disconnect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    delete?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    update?: MedicalRecordUpdateWithWhereUniqueWithoutPetInput | MedicalRecordUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: MedicalRecordUpdateManyWithWhereWithoutPetInput | MedicalRecordUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: MedicalRecordScalarWhereInput | MedicalRecordScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutPetNestedInput = {
    create?: XOR<NotificationCreateWithoutPetInput, NotificationUncheckedCreateWithoutPetInput> | NotificationCreateWithoutPetInput[] | NotificationUncheckedCreateWithoutPetInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPetInput | NotificationCreateOrConnectWithoutPetInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutPetInput | NotificationUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: NotificationCreateManyPetInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutPetInput | NotificationUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutPetInput | NotificationUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PaymentEventUncheckedUpdateManyWithoutPetNestedInput = {
    create?: XOR<PaymentEventCreateWithoutPetInput, PaymentEventUncheckedCreateWithoutPetInput> | PaymentEventCreateWithoutPetInput[] | PaymentEventUncheckedCreateWithoutPetInput[]
    connectOrCreate?: PaymentEventCreateOrConnectWithoutPetInput | PaymentEventCreateOrConnectWithoutPetInput[]
    upsert?: PaymentEventUpsertWithWhereUniqueWithoutPetInput | PaymentEventUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: PaymentEventCreateManyPetInputEnvelope
    set?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    disconnect?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    delete?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    connect?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    update?: PaymentEventUpdateWithWhereUniqueWithoutPetInput | PaymentEventUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: PaymentEventUpdateManyWithWhereWithoutPetInput | PaymentEventUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: PaymentEventScalarWhereInput | PaymentEventScalarWhereInput[]
  }

  export type PetLocationEventUncheckedUpdateManyWithoutPetNestedInput = {
    create?: XOR<PetLocationEventCreateWithoutPetInput, PetLocationEventUncheckedCreateWithoutPetInput> | PetLocationEventCreateWithoutPetInput[] | PetLocationEventUncheckedCreateWithoutPetInput[]
    connectOrCreate?: PetLocationEventCreateOrConnectWithoutPetInput | PetLocationEventCreateOrConnectWithoutPetInput[]
    upsert?: PetLocationEventUpsertWithWhereUniqueWithoutPetInput | PetLocationEventUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: PetLocationEventCreateManyPetInputEnvelope
    set?: PetLocationEventWhereUniqueInput | PetLocationEventWhereUniqueInput[]
    disconnect?: PetLocationEventWhereUniqueInput | PetLocationEventWhereUniqueInput[]
    delete?: PetLocationEventWhereUniqueInput | PetLocationEventWhereUniqueInput[]
    connect?: PetLocationEventWhereUniqueInput | PetLocationEventWhereUniqueInput[]
    update?: PetLocationEventUpdateWithWhereUniqueWithoutPetInput | PetLocationEventUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: PetLocationEventUpdateManyWithWhereWithoutPetInput | PetLocationEventUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: PetLocationEventScalarWhereInput | PetLocationEventScalarWhereInput[]
  }

  export type QRScanEventUncheckedUpdateManyWithoutPetNestedInput = {
    create?: XOR<QRScanEventCreateWithoutPetInput, QRScanEventUncheckedCreateWithoutPetInput> | QRScanEventCreateWithoutPetInput[] | QRScanEventUncheckedCreateWithoutPetInput[]
    connectOrCreate?: QRScanEventCreateOrConnectWithoutPetInput | QRScanEventCreateOrConnectWithoutPetInput[]
    upsert?: QRScanEventUpsertWithWhereUniqueWithoutPetInput | QRScanEventUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: QRScanEventCreateManyPetInputEnvelope
    set?: QRScanEventWhereUniqueInput | QRScanEventWhereUniqueInput[]
    disconnect?: QRScanEventWhereUniqueInput | QRScanEventWhereUniqueInput[]
    delete?: QRScanEventWhereUniqueInput | QRScanEventWhereUniqueInput[]
    connect?: QRScanEventWhereUniqueInput | QRScanEventWhereUniqueInput[]
    update?: QRScanEventUpdateWithWhereUniqueWithoutPetInput | QRScanEventUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: QRScanEventUpdateManyWithWhereWithoutPetInput | QRScanEventUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: QRScanEventScalarWhereInput | QRScanEventScalarWhereInput[]
  }

  export type QRCodeUncheckedUpdateManyWithoutPetNestedInput = {
    create?: XOR<QRCodeCreateWithoutPetInput, QRCodeUncheckedCreateWithoutPetInput> | QRCodeCreateWithoutPetInput[] | QRCodeUncheckedCreateWithoutPetInput[]
    connectOrCreate?: QRCodeCreateOrConnectWithoutPetInput | QRCodeCreateOrConnectWithoutPetInput[]
    upsert?: QRCodeUpsertWithWhereUniqueWithoutPetInput | QRCodeUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: QRCodeCreateManyPetInputEnvelope
    set?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    disconnect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    delete?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    connect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    update?: QRCodeUpdateWithWhereUniqueWithoutPetInput | QRCodeUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: QRCodeUpdateManyWithWhereWithoutPetInput | QRCodeUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: QRCodeScalarWhereInput | QRCodeScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutPetNestedInput = {
    create?: XOR<SupportTicketCreateWithoutPetInput, SupportTicketUncheckedCreateWithoutPetInput> | SupportTicketCreateWithoutPetInput[] | SupportTicketUncheckedCreateWithoutPetInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutPetInput | SupportTicketCreateOrConnectWithoutPetInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutPetInput | SupportTicketUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: SupportTicketCreateManyPetInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutPetInput | SupportTicketUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutPetInput | SupportTicketUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type VaccinationRecordUncheckedUpdateManyWithoutPetNestedInput = {
    create?: XOR<VaccinationRecordCreateWithoutPetInput, VaccinationRecordUncheckedCreateWithoutPetInput> | VaccinationRecordCreateWithoutPetInput[] | VaccinationRecordUncheckedCreateWithoutPetInput[]
    connectOrCreate?: VaccinationRecordCreateOrConnectWithoutPetInput | VaccinationRecordCreateOrConnectWithoutPetInput[]
    upsert?: VaccinationRecordUpsertWithWhereUniqueWithoutPetInput | VaccinationRecordUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: VaccinationRecordCreateManyPetInputEnvelope
    set?: VaccinationRecordWhereUniqueInput | VaccinationRecordWhereUniqueInput[]
    disconnect?: VaccinationRecordWhereUniqueInput | VaccinationRecordWhereUniqueInput[]
    delete?: VaccinationRecordWhereUniqueInput | VaccinationRecordWhereUniqueInput[]
    connect?: VaccinationRecordWhereUniqueInput | VaccinationRecordWhereUniqueInput[]
    update?: VaccinationRecordUpdateWithWhereUniqueWithoutPetInput | VaccinationRecordUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: VaccinationRecordUpdateManyWithWhereWithoutPetInput | VaccinationRecordUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: VaccinationRecordScalarWhereInput | VaccinationRecordScalarWhereInput[]
  }

  export type VaccineTypeCreatespeciesApplicabilityInput = {
    set: number[]
  }

  export type VaccinationRecordCreateNestedManyWithoutVaccineTypeInput = {
    create?: XOR<VaccinationRecordCreateWithoutVaccineTypeInput, VaccinationRecordUncheckedCreateWithoutVaccineTypeInput> | VaccinationRecordCreateWithoutVaccineTypeInput[] | VaccinationRecordUncheckedCreateWithoutVaccineTypeInput[]
    connectOrCreate?: VaccinationRecordCreateOrConnectWithoutVaccineTypeInput | VaccinationRecordCreateOrConnectWithoutVaccineTypeInput[]
    createMany?: VaccinationRecordCreateManyVaccineTypeInputEnvelope
    connect?: VaccinationRecordWhereUniqueInput | VaccinationRecordWhereUniqueInput[]
  }

  export type VaccinationRecordUncheckedCreateNestedManyWithoutVaccineTypeInput = {
    create?: XOR<VaccinationRecordCreateWithoutVaccineTypeInput, VaccinationRecordUncheckedCreateWithoutVaccineTypeInput> | VaccinationRecordCreateWithoutVaccineTypeInput[] | VaccinationRecordUncheckedCreateWithoutVaccineTypeInput[]
    connectOrCreate?: VaccinationRecordCreateOrConnectWithoutVaccineTypeInput | VaccinationRecordCreateOrConnectWithoutVaccineTypeInput[]
    createMany?: VaccinationRecordCreateManyVaccineTypeInputEnvelope
    connect?: VaccinationRecordWhereUniqueInput | VaccinationRecordWhereUniqueInput[]
  }

  export type VaccineTypeUpdatespeciesApplicabilityInput = {
    set?: number[]
    push?: number | number[]
  }

  export type VaccinationRecordUpdateManyWithoutVaccineTypeNestedInput = {
    create?: XOR<VaccinationRecordCreateWithoutVaccineTypeInput, VaccinationRecordUncheckedCreateWithoutVaccineTypeInput> | VaccinationRecordCreateWithoutVaccineTypeInput[] | VaccinationRecordUncheckedCreateWithoutVaccineTypeInput[]
    connectOrCreate?: VaccinationRecordCreateOrConnectWithoutVaccineTypeInput | VaccinationRecordCreateOrConnectWithoutVaccineTypeInput[]
    upsert?: VaccinationRecordUpsertWithWhereUniqueWithoutVaccineTypeInput | VaccinationRecordUpsertWithWhereUniqueWithoutVaccineTypeInput[]
    createMany?: VaccinationRecordCreateManyVaccineTypeInputEnvelope
    set?: VaccinationRecordWhereUniqueInput | VaccinationRecordWhereUniqueInput[]
    disconnect?: VaccinationRecordWhereUniqueInput | VaccinationRecordWhereUniqueInput[]
    delete?: VaccinationRecordWhereUniqueInput | VaccinationRecordWhereUniqueInput[]
    connect?: VaccinationRecordWhereUniqueInput | VaccinationRecordWhereUniqueInput[]
    update?: VaccinationRecordUpdateWithWhereUniqueWithoutVaccineTypeInput | VaccinationRecordUpdateWithWhereUniqueWithoutVaccineTypeInput[]
    updateMany?: VaccinationRecordUpdateManyWithWhereWithoutVaccineTypeInput | VaccinationRecordUpdateManyWithWhereWithoutVaccineTypeInput[]
    deleteMany?: VaccinationRecordScalarWhereInput | VaccinationRecordScalarWhereInput[]
  }

  export type VaccinationRecordUncheckedUpdateManyWithoutVaccineTypeNestedInput = {
    create?: XOR<VaccinationRecordCreateWithoutVaccineTypeInput, VaccinationRecordUncheckedCreateWithoutVaccineTypeInput> | VaccinationRecordCreateWithoutVaccineTypeInput[] | VaccinationRecordUncheckedCreateWithoutVaccineTypeInput[]
    connectOrCreate?: VaccinationRecordCreateOrConnectWithoutVaccineTypeInput | VaccinationRecordCreateOrConnectWithoutVaccineTypeInput[]
    upsert?: VaccinationRecordUpsertWithWhereUniqueWithoutVaccineTypeInput | VaccinationRecordUpsertWithWhereUniqueWithoutVaccineTypeInput[]
    createMany?: VaccinationRecordCreateManyVaccineTypeInputEnvelope
    set?: VaccinationRecordWhereUniqueInput | VaccinationRecordWhereUniqueInput[]
    disconnect?: VaccinationRecordWhereUniqueInput | VaccinationRecordWhereUniqueInput[]
    delete?: VaccinationRecordWhereUniqueInput | VaccinationRecordWhereUniqueInput[]
    connect?: VaccinationRecordWhereUniqueInput | VaccinationRecordWhereUniqueInput[]
    update?: VaccinationRecordUpdateWithWhereUniqueWithoutVaccineTypeInput | VaccinationRecordUpdateWithWhereUniqueWithoutVaccineTypeInput[]
    updateMany?: VaccinationRecordUpdateManyWithWhereWithoutVaccineTypeInput | VaccinationRecordUpdateManyWithWhereWithoutVaccineTypeInput[]
    deleteMany?: VaccinationRecordScalarWhereInput | VaccinationRecordScalarWhereInput[]
  }

  export type PetCreateNestedOneWithoutVaccinationRecordsInput = {
    create?: XOR<PetCreateWithoutVaccinationRecordsInput, PetUncheckedCreateWithoutVaccinationRecordsInput>
    connectOrCreate?: PetCreateOrConnectWithoutVaccinationRecordsInput
    connect?: PetWhereUniqueInput
  }

  export type VaccineTypeCreateNestedOneWithoutVaccinationRecordsInput = {
    create?: XOR<VaccineTypeCreateWithoutVaccinationRecordsInput, VaccineTypeUncheckedCreateWithoutVaccinationRecordsInput>
    connectOrCreate?: VaccineTypeCreateOrConnectWithoutVaccinationRecordsInput
    connect?: VaccineTypeWhereUniqueInput
  }

  export type PetUpdateOneRequiredWithoutVaccinationRecordsNestedInput = {
    create?: XOR<PetCreateWithoutVaccinationRecordsInput, PetUncheckedCreateWithoutVaccinationRecordsInput>
    connectOrCreate?: PetCreateOrConnectWithoutVaccinationRecordsInput
    upsert?: PetUpsertWithoutVaccinationRecordsInput
    connect?: PetWhereUniqueInput
    update?: XOR<XOR<PetUpdateToOneWithWhereWithoutVaccinationRecordsInput, PetUpdateWithoutVaccinationRecordsInput>, PetUncheckedUpdateWithoutVaccinationRecordsInput>
  }

  export type VaccineTypeUpdateOneRequiredWithoutVaccinationRecordsNestedInput = {
    create?: XOR<VaccineTypeCreateWithoutVaccinationRecordsInput, VaccineTypeUncheckedCreateWithoutVaccinationRecordsInput>
    connectOrCreate?: VaccineTypeCreateOrConnectWithoutVaccinationRecordsInput
    upsert?: VaccineTypeUpsertWithoutVaccinationRecordsInput
    connect?: VaccineTypeWhereUniqueInput
    update?: XOR<XOR<VaccineTypeUpdateToOneWithWhereWithoutVaccinationRecordsInput, VaccineTypeUpdateWithoutVaccinationRecordsInput>, VaccineTypeUncheckedUpdateWithoutVaccinationRecordsInput>
  }

  export type MedicalRecordCreatedocumentUrlsInput = {
    set: string[]
  }

  export type PetCreateNestedOneWithoutMedicalRecordsInput = {
    create?: XOR<PetCreateWithoutMedicalRecordsInput, PetUncheckedCreateWithoutMedicalRecordsInput>
    connectOrCreate?: PetCreateOrConnectWithoutMedicalRecordsInput
    connect?: PetWhereUniqueInput
  }

  export type MedicalRecordUpdatedocumentUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PetUpdateOneRequiredWithoutMedicalRecordsNestedInput = {
    create?: XOR<PetCreateWithoutMedicalRecordsInput, PetUncheckedCreateWithoutMedicalRecordsInput>
    connectOrCreate?: PetCreateOrConnectWithoutMedicalRecordsInput
    upsert?: PetUpsertWithoutMedicalRecordsInput
    connect?: PetWhereUniqueInput
    update?: XOR<XOR<PetUpdateToOneWithWhereWithoutMedicalRecordsInput, PetUpdateWithoutMedicalRecordsInput>, PetUncheckedUpdateWithoutMedicalRecordsInput>
  }

  export type QRCodeCreateNestedManyWithoutPoolInput = {
    create?: XOR<QRCodeCreateWithoutPoolInput, QRCodeUncheckedCreateWithoutPoolInput> | QRCodeCreateWithoutPoolInput[] | QRCodeUncheckedCreateWithoutPoolInput[]
    connectOrCreate?: QRCodeCreateOrConnectWithoutPoolInput | QRCodeCreateOrConnectWithoutPoolInput[]
    createMany?: QRCodeCreateManyPoolInputEnvelope
    connect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
  }

  export type QRCodeUncheckedCreateNestedManyWithoutPoolInput = {
    create?: XOR<QRCodeCreateWithoutPoolInput, QRCodeUncheckedCreateWithoutPoolInput> | QRCodeCreateWithoutPoolInput[] | QRCodeUncheckedCreateWithoutPoolInput[]
    connectOrCreate?: QRCodeCreateOrConnectWithoutPoolInput | QRCodeCreateOrConnectWithoutPoolInput[]
    createMany?: QRCodeCreateManyPoolInputEnvelope
    connect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
  }

  export type EnumPoolStatusFieldUpdateOperationsInput = {
    set?: $Enums.PoolStatus
  }

  export type QRCodeUpdateManyWithoutPoolNestedInput = {
    create?: XOR<QRCodeCreateWithoutPoolInput, QRCodeUncheckedCreateWithoutPoolInput> | QRCodeCreateWithoutPoolInput[] | QRCodeUncheckedCreateWithoutPoolInput[]
    connectOrCreate?: QRCodeCreateOrConnectWithoutPoolInput | QRCodeCreateOrConnectWithoutPoolInput[]
    upsert?: QRCodeUpsertWithWhereUniqueWithoutPoolInput | QRCodeUpsertWithWhereUniqueWithoutPoolInput[]
    createMany?: QRCodeCreateManyPoolInputEnvelope
    set?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    disconnect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    delete?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    connect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    update?: QRCodeUpdateWithWhereUniqueWithoutPoolInput | QRCodeUpdateWithWhereUniqueWithoutPoolInput[]
    updateMany?: QRCodeUpdateManyWithWhereWithoutPoolInput | QRCodeUpdateManyWithWhereWithoutPoolInput[]
    deleteMany?: QRCodeScalarWhereInput | QRCodeScalarWhereInput[]
  }

  export type QRCodeUncheckedUpdateManyWithoutPoolNestedInput = {
    create?: XOR<QRCodeCreateWithoutPoolInput, QRCodeUncheckedCreateWithoutPoolInput> | QRCodeCreateWithoutPoolInput[] | QRCodeUncheckedCreateWithoutPoolInput[]
    connectOrCreate?: QRCodeCreateOrConnectWithoutPoolInput | QRCodeCreateOrConnectWithoutPoolInput[]
    upsert?: QRCodeUpsertWithWhereUniqueWithoutPoolInput | QRCodeUpsertWithWhereUniqueWithoutPoolInput[]
    createMany?: QRCodeCreateManyPoolInputEnvelope
    set?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    disconnect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    delete?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    connect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    update?: QRCodeUpdateWithWhereUniqueWithoutPoolInput | QRCodeUpdateWithWhereUniqueWithoutPoolInput[]
    updateMany?: QRCodeUpdateManyWithWhereWithoutPoolInput | QRCodeUpdateManyWithWhereWithoutPoolInput[]
    deleteMany?: QRCodeScalarWhereInput | QRCodeScalarWhereInput[]
  }

  export type PaymentEventCreateNestedManyWithoutQrCodeInput = {
    create?: XOR<PaymentEventCreateWithoutQrCodeInput, PaymentEventUncheckedCreateWithoutQrCodeInput> | PaymentEventCreateWithoutQrCodeInput[] | PaymentEventUncheckedCreateWithoutQrCodeInput[]
    connectOrCreate?: PaymentEventCreateOrConnectWithoutQrCodeInput | PaymentEventCreateOrConnectWithoutQrCodeInput[]
    createMany?: PaymentEventCreateManyQrCodeInputEnvelope
    connect?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
  }

  export type PetCreateNestedOneWithoutQrCodesInput = {
    create?: XOR<PetCreateWithoutQrCodesInput, PetUncheckedCreateWithoutQrCodesInput>
    connectOrCreate?: PetCreateOrConnectWithoutQrCodesInput
    connect?: PetWhereUniqueInput
  }

  export type QRCodePoolCreateNestedOneWithoutQrCodesInput = {
    create?: XOR<QRCodePoolCreateWithoutQrCodesInput, QRCodePoolUncheckedCreateWithoutQrCodesInput>
    connectOrCreate?: QRCodePoolCreateOrConnectWithoutQrCodesInput
    connect?: QRCodePoolWhereUniqueInput
  }

  export type QRScanEventCreateNestedManyWithoutQrCodeInput = {
    create?: XOR<QRScanEventCreateWithoutQrCodeInput, QRScanEventUncheckedCreateWithoutQrCodeInput> | QRScanEventCreateWithoutQrCodeInput[] | QRScanEventUncheckedCreateWithoutQrCodeInput[]
    connectOrCreate?: QRScanEventCreateOrConnectWithoutQrCodeInput | QRScanEventCreateOrConnectWithoutQrCodeInput[]
    createMany?: QRScanEventCreateManyQrCodeInputEnvelope
    connect?: QRScanEventWhereUniqueInput | QRScanEventWhereUniqueInput[]
  }

  export type PaymentEventUncheckedCreateNestedManyWithoutQrCodeInput = {
    create?: XOR<PaymentEventCreateWithoutQrCodeInput, PaymentEventUncheckedCreateWithoutQrCodeInput> | PaymentEventCreateWithoutQrCodeInput[] | PaymentEventUncheckedCreateWithoutQrCodeInput[]
    connectOrCreate?: PaymentEventCreateOrConnectWithoutQrCodeInput | PaymentEventCreateOrConnectWithoutQrCodeInput[]
    createMany?: PaymentEventCreateManyQrCodeInputEnvelope
    connect?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
  }

  export type QRScanEventUncheckedCreateNestedManyWithoutQrCodeInput = {
    create?: XOR<QRScanEventCreateWithoutQrCodeInput, QRScanEventUncheckedCreateWithoutQrCodeInput> | QRScanEventCreateWithoutQrCodeInput[] | QRScanEventUncheckedCreateWithoutQrCodeInput[]
    connectOrCreate?: QRScanEventCreateOrConnectWithoutQrCodeInput | QRScanEventCreateOrConnectWithoutQrCodeInput[]
    createMany?: QRScanEventCreateManyQrCodeInputEnvelope
    connect?: QRScanEventWhereUniqueInput | QRScanEventWhereUniqueInput[]
  }

  export type EnumQRStatusFieldUpdateOperationsInput = {
    set?: $Enums.QRStatus
  }

  export type PaymentEventUpdateManyWithoutQrCodeNestedInput = {
    create?: XOR<PaymentEventCreateWithoutQrCodeInput, PaymentEventUncheckedCreateWithoutQrCodeInput> | PaymentEventCreateWithoutQrCodeInput[] | PaymentEventUncheckedCreateWithoutQrCodeInput[]
    connectOrCreate?: PaymentEventCreateOrConnectWithoutQrCodeInput | PaymentEventCreateOrConnectWithoutQrCodeInput[]
    upsert?: PaymentEventUpsertWithWhereUniqueWithoutQrCodeInput | PaymentEventUpsertWithWhereUniqueWithoutQrCodeInput[]
    createMany?: PaymentEventCreateManyQrCodeInputEnvelope
    set?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    disconnect?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    delete?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    connect?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    update?: PaymentEventUpdateWithWhereUniqueWithoutQrCodeInput | PaymentEventUpdateWithWhereUniqueWithoutQrCodeInput[]
    updateMany?: PaymentEventUpdateManyWithWhereWithoutQrCodeInput | PaymentEventUpdateManyWithWhereWithoutQrCodeInput[]
    deleteMany?: PaymentEventScalarWhereInput | PaymentEventScalarWhereInput[]
  }

  export type PetUpdateOneWithoutQrCodesNestedInput = {
    create?: XOR<PetCreateWithoutQrCodesInput, PetUncheckedCreateWithoutQrCodesInput>
    connectOrCreate?: PetCreateOrConnectWithoutQrCodesInput
    upsert?: PetUpsertWithoutQrCodesInput
    disconnect?: PetWhereInput | boolean
    delete?: PetWhereInput | boolean
    connect?: PetWhereUniqueInput
    update?: XOR<XOR<PetUpdateToOneWithWhereWithoutQrCodesInput, PetUpdateWithoutQrCodesInput>, PetUncheckedUpdateWithoutQrCodesInput>
  }

  export type QRCodePoolUpdateOneWithoutQrCodesNestedInput = {
    create?: XOR<QRCodePoolCreateWithoutQrCodesInput, QRCodePoolUncheckedCreateWithoutQrCodesInput>
    connectOrCreate?: QRCodePoolCreateOrConnectWithoutQrCodesInput
    upsert?: QRCodePoolUpsertWithoutQrCodesInput
    disconnect?: QRCodePoolWhereInput | boolean
    delete?: QRCodePoolWhereInput | boolean
    connect?: QRCodePoolWhereUniqueInput
    update?: XOR<XOR<QRCodePoolUpdateToOneWithWhereWithoutQrCodesInput, QRCodePoolUpdateWithoutQrCodesInput>, QRCodePoolUncheckedUpdateWithoutQrCodesInput>
  }

  export type QRScanEventUpdateManyWithoutQrCodeNestedInput = {
    create?: XOR<QRScanEventCreateWithoutQrCodeInput, QRScanEventUncheckedCreateWithoutQrCodeInput> | QRScanEventCreateWithoutQrCodeInput[] | QRScanEventUncheckedCreateWithoutQrCodeInput[]
    connectOrCreate?: QRScanEventCreateOrConnectWithoutQrCodeInput | QRScanEventCreateOrConnectWithoutQrCodeInput[]
    upsert?: QRScanEventUpsertWithWhereUniqueWithoutQrCodeInput | QRScanEventUpsertWithWhereUniqueWithoutQrCodeInput[]
    createMany?: QRScanEventCreateManyQrCodeInputEnvelope
    set?: QRScanEventWhereUniqueInput | QRScanEventWhereUniqueInput[]
    disconnect?: QRScanEventWhereUniqueInput | QRScanEventWhereUniqueInput[]
    delete?: QRScanEventWhereUniqueInput | QRScanEventWhereUniqueInput[]
    connect?: QRScanEventWhereUniqueInput | QRScanEventWhereUniqueInput[]
    update?: QRScanEventUpdateWithWhereUniqueWithoutQrCodeInput | QRScanEventUpdateWithWhereUniqueWithoutQrCodeInput[]
    updateMany?: QRScanEventUpdateManyWithWhereWithoutQrCodeInput | QRScanEventUpdateManyWithWhereWithoutQrCodeInput[]
    deleteMany?: QRScanEventScalarWhereInput | QRScanEventScalarWhereInput[]
  }

  export type PaymentEventUncheckedUpdateManyWithoutQrCodeNestedInput = {
    create?: XOR<PaymentEventCreateWithoutQrCodeInput, PaymentEventUncheckedCreateWithoutQrCodeInput> | PaymentEventCreateWithoutQrCodeInput[] | PaymentEventUncheckedCreateWithoutQrCodeInput[]
    connectOrCreate?: PaymentEventCreateOrConnectWithoutQrCodeInput | PaymentEventCreateOrConnectWithoutQrCodeInput[]
    upsert?: PaymentEventUpsertWithWhereUniqueWithoutQrCodeInput | PaymentEventUpsertWithWhereUniqueWithoutQrCodeInput[]
    createMany?: PaymentEventCreateManyQrCodeInputEnvelope
    set?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    disconnect?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    delete?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    connect?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    update?: PaymentEventUpdateWithWhereUniqueWithoutQrCodeInput | PaymentEventUpdateWithWhereUniqueWithoutQrCodeInput[]
    updateMany?: PaymentEventUpdateManyWithWhereWithoutQrCodeInput | PaymentEventUpdateManyWithWhereWithoutQrCodeInput[]
    deleteMany?: PaymentEventScalarWhereInput | PaymentEventScalarWhereInput[]
  }

  export type QRScanEventUncheckedUpdateManyWithoutQrCodeNestedInput = {
    create?: XOR<QRScanEventCreateWithoutQrCodeInput, QRScanEventUncheckedCreateWithoutQrCodeInput> | QRScanEventCreateWithoutQrCodeInput[] | QRScanEventUncheckedCreateWithoutQrCodeInput[]
    connectOrCreate?: QRScanEventCreateOrConnectWithoutQrCodeInput | QRScanEventCreateOrConnectWithoutQrCodeInput[]
    upsert?: QRScanEventUpsertWithWhereUniqueWithoutQrCodeInput | QRScanEventUpsertWithWhereUniqueWithoutQrCodeInput[]
    createMany?: QRScanEventCreateManyQrCodeInputEnvelope
    set?: QRScanEventWhereUniqueInput | QRScanEventWhereUniqueInput[]
    disconnect?: QRScanEventWhereUniqueInput | QRScanEventWhereUniqueInput[]
    delete?: QRScanEventWhereUniqueInput | QRScanEventWhereUniqueInput[]
    connect?: QRScanEventWhereUniqueInput | QRScanEventWhereUniqueInput[]
    update?: QRScanEventUpdateWithWhereUniqueWithoutQrCodeInput | QRScanEventUpdateWithWhereUniqueWithoutQrCodeInput[]
    updateMany?: QRScanEventUpdateManyWithWhereWithoutQrCodeInput | QRScanEventUpdateManyWithWhereWithoutQrCodeInput[]
    deleteMany?: QRScanEventScalarWhereInput | QRScanEventScalarWhereInput[]
  }

  export type QRCodeCreateNestedOneWithoutScanEventsInput = {
    create?: XOR<QRCodeCreateWithoutScanEventsInput, QRCodeUncheckedCreateWithoutScanEventsInput>
    connectOrCreate?: QRCodeCreateOrConnectWithoutScanEventsInput
    connect?: QRCodeWhereUniqueInput
  }

  export type PetCreateNestedOneWithoutQrScanEventsInput = {
    create?: XOR<PetCreateWithoutQrScanEventsInput, PetUncheckedCreateWithoutQrScanEventsInput>
    connectOrCreate?: PetCreateOrConnectWithoutQrScanEventsInput
    connect?: PetWhereUniqueInput
  }

  export type PetLocationEventCreateNestedManyWithoutQrScanEventInput = {
    create?: XOR<PetLocationEventCreateWithoutQrScanEventInput, PetLocationEventUncheckedCreateWithoutQrScanEventInput> | PetLocationEventCreateWithoutQrScanEventInput[] | PetLocationEventUncheckedCreateWithoutQrScanEventInput[]
    connectOrCreate?: PetLocationEventCreateOrConnectWithoutQrScanEventInput | PetLocationEventCreateOrConnectWithoutQrScanEventInput[]
    createMany?: PetLocationEventCreateManyQrScanEventInputEnvelope
    connect?: PetLocationEventWhereUniqueInput | PetLocationEventWhereUniqueInput[]
  }

  export type PetLocationEventUncheckedCreateNestedManyWithoutQrScanEventInput = {
    create?: XOR<PetLocationEventCreateWithoutQrScanEventInput, PetLocationEventUncheckedCreateWithoutQrScanEventInput> | PetLocationEventCreateWithoutQrScanEventInput[] | PetLocationEventUncheckedCreateWithoutQrScanEventInput[]
    connectOrCreate?: PetLocationEventCreateOrConnectWithoutQrScanEventInput | PetLocationEventCreateOrConnectWithoutQrScanEventInput[]
    createMany?: PetLocationEventCreateManyQrScanEventInputEnvelope
    connect?: PetLocationEventWhereUniqueInput | PetLocationEventWhereUniqueInput[]
  }

  export type NullableEnumDeviceTypeFieldUpdateOperationsInput = {
    set?: $Enums.DeviceType | null
  }

  export type EnumScanResultFieldUpdateOperationsInput = {
    set?: $Enums.ScanResult
  }

  export type QRCodeUpdateOneRequiredWithoutScanEventsNestedInput = {
    create?: XOR<QRCodeCreateWithoutScanEventsInput, QRCodeUncheckedCreateWithoutScanEventsInput>
    connectOrCreate?: QRCodeCreateOrConnectWithoutScanEventsInput
    upsert?: QRCodeUpsertWithoutScanEventsInput
    connect?: QRCodeWhereUniqueInput
    update?: XOR<XOR<QRCodeUpdateToOneWithWhereWithoutScanEventsInput, QRCodeUpdateWithoutScanEventsInput>, QRCodeUncheckedUpdateWithoutScanEventsInput>
  }

  export type PetUpdateOneWithoutQrScanEventsNestedInput = {
    create?: XOR<PetCreateWithoutQrScanEventsInput, PetUncheckedCreateWithoutQrScanEventsInput>
    connectOrCreate?: PetCreateOrConnectWithoutQrScanEventsInput
    upsert?: PetUpsertWithoutQrScanEventsInput
    disconnect?: PetWhereInput | boolean
    delete?: PetWhereInput | boolean
    connect?: PetWhereUniqueInput
    update?: XOR<XOR<PetUpdateToOneWithWhereWithoutQrScanEventsInput, PetUpdateWithoutQrScanEventsInput>, PetUncheckedUpdateWithoutQrScanEventsInput>
  }

  export type PetLocationEventUpdateManyWithoutQrScanEventNestedInput = {
    create?: XOR<PetLocationEventCreateWithoutQrScanEventInput, PetLocationEventUncheckedCreateWithoutQrScanEventInput> | PetLocationEventCreateWithoutQrScanEventInput[] | PetLocationEventUncheckedCreateWithoutQrScanEventInput[]
    connectOrCreate?: PetLocationEventCreateOrConnectWithoutQrScanEventInput | PetLocationEventCreateOrConnectWithoutQrScanEventInput[]
    upsert?: PetLocationEventUpsertWithWhereUniqueWithoutQrScanEventInput | PetLocationEventUpsertWithWhereUniqueWithoutQrScanEventInput[]
    createMany?: PetLocationEventCreateManyQrScanEventInputEnvelope
    set?: PetLocationEventWhereUniqueInput | PetLocationEventWhereUniqueInput[]
    disconnect?: PetLocationEventWhereUniqueInput | PetLocationEventWhereUniqueInput[]
    delete?: PetLocationEventWhereUniqueInput | PetLocationEventWhereUniqueInput[]
    connect?: PetLocationEventWhereUniqueInput | PetLocationEventWhereUniqueInput[]
    update?: PetLocationEventUpdateWithWhereUniqueWithoutQrScanEventInput | PetLocationEventUpdateWithWhereUniqueWithoutQrScanEventInput[]
    updateMany?: PetLocationEventUpdateManyWithWhereWithoutQrScanEventInput | PetLocationEventUpdateManyWithWhereWithoutQrScanEventInput[]
    deleteMany?: PetLocationEventScalarWhereInput | PetLocationEventScalarWhereInput[]
  }

  export type PetLocationEventUncheckedUpdateManyWithoutQrScanEventNestedInput = {
    create?: XOR<PetLocationEventCreateWithoutQrScanEventInput, PetLocationEventUncheckedCreateWithoutQrScanEventInput> | PetLocationEventCreateWithoutQrScanEventInput[] | PetLocationEventUncheckedCreateWithoutQrScanEventInput[]
    connectOrCreate?: PetLocationEventCreateOrConnectWithoutQrScanEventInput | PetLocationEventCreateOrConnectWithoutQrScanEventInput[]
    upsert?: PetLocationEventUpsertWithWhereUniqueWithoutQrScanEventInput | PetLocationEventUpsertWithWhereUniqueWithoutQrScanEventInput[]
    createMany?: PetLocationEventCreateManyQrScanEventInputEnvelope
    set?: PetLocationEventWhereUniqueInput | PetLocationEventWhereUniqueInput[]
    disconnect?: PetLocationEventWhereUniqueInput | PetLocationEventWhereUniqueInput[]
    delete?: PetLocationEventWhereUniqueInput | PetLocationEventWhereUniqueInput[]
    connect?: PetLocationEventWhereUniqueInput | PetLocationEventWhereUniqueInput[]
    update?: PetLocationEventUpdateWithWhereUniqueWithoutQrScanEventInput | PetLocationEventUpdateWithWhereUniqueWithoutQrScanEventInput[]
    updateMany?: PetLocationEventUpdateManyWithWhereWithoutQrScanEventInput | PetLocationEventUpdateManyWithWhereWithoutQrScanEventInput[]
    deleteMany?: PetLocationEventScalarWhereInput | PetLocationEventScalarWhereInput[]
  }

  export type PetCreateNestedOneWithoutLocationEventsInput = {
    create?: XOR<PetCreateWithoutLocationEventsInput, PetUncheckedCreateWithoutLocationEventsInput>
    connectOrCreate?: PetCreateOrConnectWithoutLocationEventsInput
    connect?: PetWhereUniqueInput
  }

  export type QRScanEventCreateNestedOneWithoutLocationEventsInput = {
    create?: XOR<QRScanEventCreateWithoutLocationEventsInput, QRScanEventUncheckedCreateWithoutLocationEventsInput>
    connectOrCreate?: QRScanEventCreateOrConnectWithoutLocationEventsInput
    connect?: QRScanEventWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type PetUpdateOneRequiredWithoutLocationEventsNestedInput = {
    create?: XOR<PetCreateWithoutLocationEventsInput, PetUncheckedCreateWithoutLocationEventsInput>
    connectOrCreate?: PetCreateOrConnectWithoutLocationEventsInput
    upsert?: PetUpsertWithoutLocationEventsInput
    connect?: PetWhereUniqueInput
    update?: XOR<XOR<PetUpdateToOneWithWhereWithoutLocationEventsInput, PetUpdateWithoutLocationEventsInput>, PetUncheckedUpdateWithoutLocationEventsInput>
  }

  export type QRScanEventUpdateOneWithoutLocationEventsNestedInput = {
    create?: XOR<QRScanEventCreateWithoutLocationEventsInput, QRScanEventUncheckedCreateWithoutLocationEventsInput>
    connectOrCreate?: QRScanEventCreateOrConnectWithoutLocationEventsInput
    upsert?: QRScanEventUpsertWithoutLocationEventsInput
    disconnect?: QRScanEventWhereInput | boolean
    delete?: QRScanEventWhereInput | boolean
    connect?: QRScanEventWhereUniqueInput
    update?: XOR<XOR<QRScanEventUpdateToOneWithWhereWithoutLocationEventsInput, QRScanEventUpdateWithoutLocationEventsInput>, QRScanEventUncheckedUpdateWithoutLocationEventsInput>
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type PaymentUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentsInput
    connect?: OrderWhereUniqueInput
  }

  export type RefundCreateNestedManyWithoutPaymentInput = {
    create?: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput> | RefundCreateWithoutPaymentInput[] | RefundUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentInput | RefundCreateOrConnectWithoutPaymentInput[]
    createMany?: RefundCreateManyPaymentInputEnvelope
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
  }

  export type RefundUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput> | RefundCreateWithoutPaymentInput[] | RefundUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentInput | RefundCreateOrConnectWithoutPaymentInput[]
    createMany?: RefundCreateManyPaymentInputEnvelope
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
  }

  export type EnumPaymentStatusNewFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatusNew
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableEnumVerificationMethodFieldUpdateOperationsInput = {
    set?: $Enums.VerificationMethod | null
  }

  export type OrderUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentsInput
    upsert?: OrderUpsertWithoutPaymentsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPaymentsInput, OrderUpdateWithoutPaymentsInput>, OrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type RefundUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput> | RefundCreateWithoutPaymentInput[] | RefundUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentInput | RefundCreateOrConnectWithoutPaymentInput[]
    upsert?: RefundUpsertWithWhereUniqueWithoutPaymentInput | RefundUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: RefundCreateManyPaymentInputEnvelope
    set?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    disconnect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    delete?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    update?: RefundUpdateWithWhereUniqueWithoutPaymentInput | RefundUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: RefundUpdateManyWithWhereWithoutPaymentInput | RefundUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: RefundScalarWhereInput | RefundScalarWhereInput[]
  }

  export type RefundUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput> | RefundCreateWithoutPaymentInput[] | RefundUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentInput | RefundCreateOrConnectWithoutPaymentInput[]
    upsert?: RefundUpsertWithWhereUniqueWithoutPaymentInput | RefundUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: RefundCreateManyPaymentInputEnvelope
    set?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    disconnect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    delete?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    update?: RefundUpdateWithWhereUniqueWithoutPaymentInput | RefundUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: RefundUpdateManyWithWhereWithoutPaymentInput | RefundUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: RefundScalarWhereInput | RefundScalarWhereInput[]
  }

  export type PaymentCreateNestedOneWithoutRefundsInput = {
    create?: XOR<PaymentCreateWithoutRefundsInput, PaymentUncheckedCreateWithoutRefundsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutRefundsInput
    connect?: PaymentWhereUniqueInput
  }

  export type PaymentEventCreateNestedOneWithoutRefundsInput = {
    create?: XOR<PaymentEventCreateWithoutRefundsInput, PaymentEventUncheckedCreateWithoutRefundsInput>
    connectOrCreate?: PaymentEventCreateOrConnectWithoutRefundsInput
    connect?: PaymentEventWhereUniqueInput
  }

  export type EnumRefundStatusFieldUpdateOperationsInput = {
    set?: $Enums.RefundStatus
  }

  export type PaymentUpdateOneRequiredWithoutRefundsNestedInput = {
    create?: XOR<PaymentCreateWithoutRefundsInput, PaymentUncheckedCreateWithoutRefundsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutRefundsInput
    upsert?: PaymentUpsertWithoutRefundsInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutRefundsInput, PaymentUpdateWithoutRefundsInput>, PaymentUncheckedUpdateWithoutRefundsInput>
  }

  export type PaymentEventUpdateOneWithoutRefundsNestedInput = {
    create?: XOR<PaymentEventCreateWithoutRefundsInput, PaymentEventUncheckedCreateWithoutRefundsInput>
    connectOrCreate?: PaymentEventCreateOrConnectWithoutRefundsInput
    upsert?: PaymentEventUpsertWithoutRefundsInput
    disconnect?: PaymentEventWhereInput | boolean
    delete?: PaymentEventWhereInput | boolean
    connect?: PaymentEventWhereUniqueInput
    update?: XOR<XOR<PaymentEventUpdateToOneWithWhereWithoutRefundsInput, PaymentEventUpdateWithoutRefundsInput>, PaymentEventUncheckedUpdateWithoutRefundsInput>
  }

  export type PetCreateNestedOneWithoutPaymentEventsInput = {
    create?: XOR<PetCreateWithoutPaymentEventsInput, PetUncheckedCreateWithoutPaymentEventsInput>
    connectOrCreate?: PetCreateOrConnectWithoutPaymentEventsInput
    connect?: PetWhereUniqueInput
  }

  export type QRCodeCreateNestedOneWithoutPaymentEventsInput = {
    create?: XOR<QRCodeCreateWithoutPaymentEventsInput, QRCodeUncheckedCreateWithoutPaymentEventsInput>
    connectOrCreate?: QRCodeCreateOrConnectWithoutPaymentEventsInput
    connect?: QRCodeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPaymentEventsInput = {
    create?: XOR<UserCreateWithoutPaymentEventsInput, UserUncheckedCreateWithoutPaymentEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentEventsInput
    connect?: UserWhereUniqueInput
  }

  export type RefundCreateNestedManyWithoutPaymentEventInput = {
    create?: XOR<RefundCreateWithoutPaymentEventInput, RefundUncheckedCreateWithoutPaymentEventInput> | RefundCreateWithoutPaymentEventInput[] | RefundUncheckedCreateWithoutPaymentEventInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentEventInput | RefundCreateOrConnectWithoutPaymentEventInput[]
    createMany?: RefundCreateManyPaymentEventInputEnvelope
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
  }

  export type RefundUncheckedCreateNestedManyWithoutPaymentEventInput = {
    create?: XOR<RefundCreateWithoutPaymentEventInput, RefundUncheckedCreateWithoutPaymentEventInput> | RefundCreateWithoutPaymentEventInput[] | RefundUncheckedCreateWithoutPaymentEventInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentEventInput | RefundCreateOrConnectWithoutPaymentEventInput[]
    createMany?: RefundCreateManyPaymentEventInputEnvelope
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
  }

  export type EnumPaymentPurposeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentPurpose
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type PetUpdateOneWithoutPaymentEventsNestedInput = {
    create?: XOR<PetCreateWithoutPaymentEventsInput, PetUncheckedCreateWithoutPaymentEventsInput>
    connectOrCreate?: PetCreateOrConnectWithoutPaymentEventsInput
    upsert?: PetUpsertWithoutPaymentEventsInput
    disconnect?: PetWhereInput | boolean
    delete?: PetWhereInput | boolean
    connect?: PetWhereUniqueInput
    update?: XOR<XOR<PetUpdateToOneWithWhereWithoutPaymentEventsInput, PetUpdateWithoutPaymentEventsInput>, PetUncheckedUpdateWithoutPaymentEventsInput>
  }

  export type QRCodeUpdateOneWithoutPaymentEventsNestedInput = {
    create?: XOR<QRCodeCreateWithoutPaymentEventsInput, QRCodeUncheckedCreateWithoutPaymentEventsInput>
    connectOrCreate?: QRCodeCreateOrConnectWithoutPaymentEventsInput
    upsert?: QRCodeUpsertWithoutPaymentEventsInput
    disconnect?: QRCodeWhereInput | boolean
    delete?: QRCodeWhereInput | boolean
    connect?: QRCodeWhereUniqueInput
    update?: XOR<XOR<QRCodeUpdateToOneWithWhereWithoutPaymentEventsInput, QRCodeUpdateWithoutPaymentEventsInput>, QRCodeUncheckedUpdateWithoutPaymentEventsInput>
  }

  export type UserUpdateOneWithoutPaymentEventsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentEventsInput, UserUncheckedCreateWithoutPaymentEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentEventsInput
    upsert?: UserUpsertWithoutPaymentEventsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentEventsInput, UserUpdateWithoutPaymentEventsInput>, UserUncheckedUpdateWithoutPaymentEventsInput>
  }

  export type RefundUpdateManyWithoutPaymentEventNestedInput = {
    create?: XOR<RefundCreateWithoutPaymentEventInput, RefundUncheckedCreateWithoutPaymentEventInput> | RefundCreateWithoutPaymentEventInput[] | RefundUncheckedCreateWithoutPaymentEventInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentEventInput | RefundCreateOrConnectWithoutPaymentEventInput[]
    upsert?: RefundUpsertWithWhereUniqueWithoutPaymentEventInput | RefundUpsertWithWhereUniqueWithoutPaymentEventInput[]
    createMany?: RefundCreateManyPaymentEventInputEnvelope
    set?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    disconnect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    delete?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    update?: RefundUpdateWithWhereUniqueWithoutPaymentEventInput | RefundUpdateWithWhereUniqueWithoutPaymentEventInput[]
    updateMany?: RefundUpdateManyWithWhereWithoutPaymentEventInput | RefundUpdateManyWithWhereWithoutPaymentEventInput[]
    deleteMany?: RefundScalarWhereInput | RefundScalarWhereInput[]
  }

  export type RefundUncheckedUpdateManyWithoutPaymentEventNestedInput = {
    create?: XOR<RefundCreateWithoutPaymentEventInput, RefundUncheckedCreateWithoutPaymentEventInput> | RefundCreateWithoutPaymentEventInput[] | RefundUncheckedCreateWithoutPaymentEventInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentEventInput | RefundCreateOrConnectWithoutPaymentEventInput[]
    upsert?: RefundUpsertWithWhereUniqueWithoutPaymentEventInput | RefundUpsertWithWhereUniqueWithoutPaymentEventInput[]
    createMany?: RefundCreateManyPaymentEventInputEnvelope
    set?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    disconnect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    delete?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    update?: RefundUpdateWithWhereUniqueWithoutPaymentEventInput | RefundUpdateWithWhereUniqueWithoutPaymentEventInput[]
    updateMany?: RefundUpdateManyWithWhereWithoutPaymentEventInput | RefundUpdateManyWithWhereWithoutPaymentEventInput[]
    deleteMany?: RefundScalarWhereInput | RefundScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLocationTracksInput = {
    create?: XOR<UserCreateWithoutLocationTracksInput, UserUncheckedCreateWithoutLocationTracksInput>
    connectOrCreate?: UserCreateOrConnectWithoutLocationTracksInput
    connect?: UserWhereUniqueInput
  }

  export type EnumLocationTypeFieldUpdateOperationsInput = {
    set?: $Enums.LocationType
  }

  export type UserUpdateOneWithoutLocationTracksNestedInput = {
    create?: XOR<UserCreateWithoutLocationTracksInput, UserUncheckedCreateWithoutLocationTracksInput>
    connectOrCreate?: UserCreateOrConnectWithoutLocationTracksInput
    upsert?: UserUpsertWithoutLocationTracksInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLocationTracksInput, UserUpdateWithoutLocationTracksInput>, UserUncheckedUpdateWithoutLocationTracksInput>
  }

  export type UserCreateNestedOneWithoutNotificationPrefsInput = {
    create?: XOR<UserCreateWithoutNotificationPrefsInput, UserUncheckedCreateWithoutNotificationPrefsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPrefsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationPrefsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationPrefsInput, UserUncheckedCreateWithoutNotificationPrefsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPrefsInput
    upsert?: UserUpsertWithoutNotificationPrefsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationPrefsInput, UserUpdateWithoutNotificationPrefsInput>, UserUncheckedUpdateWithoutNotificationPrefsInput>
  }

  export type NotificationCreatechannelsInput = {
    set: string[]
  }

  export type PetCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<PetCreateWithoutNotificationsInput, PetUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: PetCreateOrConnectWithoutNotificationsInput
    connect?: PetWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type NotificationUpdatechannelsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PetUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<PetCreateWithoutNotificationsInput, PetUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: PetCreateOrConnectWithoutNotificationsInput
    upsert?: PetUpsertWithoutNotificationsInput
    disconnect?: PetWhereInput | boolean
    delete?: PetWhereInput | boolean
    connect?: PetWhereUniqueInput
    update?: XOR<XOR<PetUpdateToOneWithWhereWithoutNotificationsInput, PetUpdateWithoutNotificationsInput>, PetUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutDeviceTokensInput = {
    create?: XOR<UserCreateWithoutDeviceTokensInput, UserUncheckedCreateWithoutDeviceTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeviceTokensInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPlatformFieldUpdateOperationsInput = {
    set?: $Enums.Platform
  }

  export type UserUpdateOneRequiredWithoutDeviceTokensNestedInput = {
    create?: XOR<UserCreateWithoutDeviceTokensInput, UserUncheckedCreateWithoutDeviceTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeviceTokensInput
    upsert?: UserUpsertWithoutDeviceTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeviceTokensInput, UserUpdateWithoutDeviceTokensInput>, UserUncheckedUpdateWithoutDeviceTokensInput>
  }

  export type SupportMessageCreateNestedManyWithoutTicketInput = {
    create?: XOR<SupportMessageCreateWithoutTicketInput, SupportMessageUncheckedCreateWithoutTicketInput> | SupportMessageCreateWithoutTicketInput[] | SupportMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: SupportMessageCreateOrConnectWithoutTicketInput | SupportMessageCreateOrConnectWithoutTicketInput[]
    createMany?: SupportMessageCreateManyTicketInputEnvelope
    connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutAssignedTicketsInput = {
    create?: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type PetCreateNestedOneWithoutSupportTicketsInput = {
    create?: XOR<PetCreateWithoutSupportTicketsInput, PetUncheckedCreateWithoutSupportTicketsInput>
    connectOrCreate?: PetCreateOrConnectWithoutSupportTicketsInput
    connect?: PetWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSupportTicketsInput = {
    create?: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupportTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type SupportMessageUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<SupportMessageCreateWithoutTicketInput, SupportMessageUncheckedCreateWithoutTicketInput> | SupportMessageCreateWithoutTicketInput[] | SupportMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: SupportMessageCreateOrConnectWithoutTicketInput | SupportMessageCreateOrConnectWithoutTicketInput[]
    createMany?: SupportMessageCreateManyTicketInputEnvelope
    connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
  }

  export type EnumTicketCategoryFieldUpdateOperationsInput = {
    set?: $Enums.TicketCategory
  }

  export type EnumTicketPriorityFieldUpdateOperationsInput = {
    set?: $Enums.TicketPriority
  }

  export type EnumTicketStatusFieldUpdateOperationsInput = {
    set?: $Enums.TicketStatus
  }

  export type SupportMessageUpdateManyWithoutTicketNestedInput = {
    create?: XOR<SupportMessageCreateWithoutTicketInput, SupportMessageUncheckedCreateWithoutTicketInput> | SupportMessageCreateWithoutTicketInput[] | SupportMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: SupportMessageCreateOrConnectWithoutTicketInput | SupportMessageCreateOrConnectWithoutTicketInput[]
    upsert?: SupportMessageUpsertWithWhereUniqueWithoutTicketInput | SupportMessageUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: SupportMessageCreateManyTicketInputEnvelope
    set?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    disconnect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    delete?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    update?: SupportMessageUpdateWithWhereUniqueWithoutTicketInput | SupportMessageUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: SupportMessageUpdateManyWithWhereWithoutTicketInput | SupportMessageUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: SupportMessageScalarWhereInput | SupportMessageScalarWhereInput[]
  }

  export type UserUpdateOneWithoutAssignedTicketsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTicketsInput
    upsert?: UserUpsertWithoutAssignedTicketsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedTicketsInput, UserUpdateWithoutAssignedTicketsInput>, UserUncheckedUpdateWithoutAssignedTicketsInput>
  }

  export type PetUpdateOneWithoutSupportTicketsNestedInput = {
    create?: XOR<PetCreateWithoutSupportTicketsInput, PetUncheckedCreateWithoutSupportTicketsInput>
    connectOrCreate?: PetCreateOrConnectWithoutSupportTicketsInput
    upsert?: PetUpsertWithoutSupportTicketsInput
    disconnect?: PetWhereInput | boolean
    delete?: PetWhereInput | boolean
    connect?: PetWhereUniqueInput
    update?: XOR<XOR<PetUpdateToOneWithWhereWithoutSupportTicketsInput, PetUpdateWithoutSupportTicketsInput>, PetUncheckedUpdateWithoutSupportTicketsInput>
  }

  export type UserUpdateOneWithoutSupportTicketsNestedInput = {
    create?: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupportTicketsInput
    upsert?: UserUpsertWithoutSupportTicketsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSupportTicketsInput, UserUpdateWithoutSupportTicketsInput>, UserUncheckedUpdateWithoutSupportTicketsInput>
  }

  export type SupportMessageUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<SupportMessageCreateWithoutTicketInput, SupportMessageUncheckedCreateWithoutTicketInput> | SupportMessageCreateWithoutTicketInput[] | SupportMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: SupportMessageCreateOrConnectWithoutTicketInput | SupportMessageCreateOrConnectWithoutTicketInput[]
    upsert?: SupportMessageUpsertWithWhereUniqueWithoutTicketInput | SupportMessageUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: SupportMessageCreateManyTicketInputEnvelope
    set?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    disconnect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    delete?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    update?: SupportMessageUpdateWithWhereUniqueWithoutTicketInput | SupportMessageUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: SupportMessageUpdateManyWithWhereWithoutTicketInput | SupportMessageUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: SupportMessageScalarWhereInput | SupportMessageScalarWhereInput[]
  }

  export type SupportMessageCreateattachmentsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutSupportMessagesInput = {
    create?: XOR<UserCreateWithoutSupportMessagesInput, UserUncheckedCreateWithoutSupportMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupportMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type SupportTicketCreateNestedOneWithoutMessagesInput = {
    create?: XOR<SupportTicketCreateWithoutMessagesInput, SupportTicketUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: SupportTicketCreateOrConnectWithoutMessagesInput
    connect?: SupportTicketWhereUniqueInput
  }

  export type EnumSenderTypeFieldUpdateOperationsInput = {
    set?: $Enums.SenderType
  }

  export type SupportMessageUpdateattachmentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneWithoutSupportMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSupportMessagesInput, UserUncheckedCreateWithoutSupportMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupportMessagesInput
    upsert?: UserUpsertWithoutSupportMessagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSupportMessagesInput, UserUpdateWithoutSupportMessagesInput>, UserUncheckedUpdateWithoutSupportMessagesInput>
  }

  export type SupportTicketUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<SupportTicketCreateWithoutMessagesInput, SupportTicketUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: SupportTicketCreateOrConnectWithoutMessagesInput
    upsert?: SupportTicketUpsertWithoutMessagesInput
    connect?: SupportTicketWhereUniqueInput
    update?: XOR<XOR<SupportTicketUpdateToOneWithWhereWithoutMessagesInput, SupportTicketUpdateWithoutMessagesInput>, SupportTicketUncheckedUpdateWithoutMessagesInput>
  }

  export type AuditLogCreatechangedColumnsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumOperationTypeFieldUpdateOperationsInput = {
    set?: $Enums.OperationType
  }

  export type AuditLogUpdatechangedColumnsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ApplicationDocumentCreateNestedManyWithoutApplicationInput = {
    create?: XOR<ApplicationDocumentCreateWithoutApplicationInput, ApplicationDocumentUncheckedCreateWithoutApplicationInput> | ApplicationDocumentCreateWithoutApplicationInput[] | ApplicationDocumentUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: ApplicationDocumentCreateOrConnectWithoutApplicationInput | ApplicationDocumentCreateOrConnectWithoutApplicationInput[]
    createMany?: ApplicationDocumentCreateManyApplicationInputEnvelope
    connect?: ApplicationDocumentWhereUniqueInput | ApplicationDocumentWhereUniqueInput[]
  }

  export type CheckoutItemCreateNestedManyWithoutApplicationInput = {
    create?: XOR<CheckoutItemCreateWithoutApplicationInput, CheckoutItemUncheckedCreateWithoutApplicationInput> | CheckoutItemCreateWithoutApplicationInput[] | CheckoutItemUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: CheckoutItemCreateOrConnectWithoutApplicationInput | CheckoutItemCreateOrConnectWithoutApplicationInput[]
    createMany?: CheckoutItemCreateManyApplicationInputEnvelope
    connect?: CheckoutItemWhereUniqueInput | CheckoutItemWhereUniqueInput[]
  }

  export type RegisteredPetCreateNestedManyWithoutApplicationInput = {
    create?: XOR<RegisteredPetCreateWithoutApplicationInput, RegisteredPetUncheckedCreateWithoutApplicationInput> | RegisteredPetCreateWithoutApplicationInput[] | RegisteredPetUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: RegisteredPetCreateOrConnectWithoutApplicationInput | RegisteredPetCreateOrConnectWithoutApplicationInput[]
    createMany?: RegisteredPetCreateManyApplicationInputEnvelope
    connect?: RegisteredPetWhereUniqueInput | RegisteredPetWhereUniqueInput[]
  }

  export type ApplicationDocumentUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<ApplicationDocumentCreateWithoutApplicationInput, ApplicationDocumentUncheckedCreateWithoutApplicationInput> | ApplicationDocumentCreateWithoutApplicationInput[] | ApplicationDocumentUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: ApplicationDocumentCreateOrConnectWithoutApplicationInput | ApplicationDocumentCreateOrConnectWithoutApplicationInput[]
    createMany?: ApplicationDocumentCreateManyApplicationInputEnvelope
    connect?: ApplicationDocumentWhereUniqueInput | ApplicationDocumentWhereUniqueInput[]
  }

  export type CheckoutItemUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<CheckoutItemCreateWithoutApplicationInput, CheckoutItemUncheckedCreateWithoutApplicationInput> | CheckoutItemCreateWithoutApplicationInput[] | CheckoutItemUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: CheckoutItemCreateOrConnectWithoutApplicationInput | CheckoutItemCreateOrConnectWithoutApplicationInput[]
    createMany?: CheckoutItemCreateManyApplicationInputEnvelope
    connect?: CheckoutItemWhereUniqueInput | CheckoutItemWhereUniqueInput[]
  }

  export type RegisteredPetUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<RegisteredPetCreateWithoutApplicationInput, RegisteredPetUncheckedCreateWithoutApplicationInput> | RegisteredPetCreateWithoutApplicationInput[] | RegisteredPetUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: RegisteredPetCreateOrConnectWithoutApplicationInput | RegisteredPetCreateOrConnectWithoutApplicationInput[]
    createMany?: RegisteredPetCreateManyApplicationInputEnvelope
    connect?: RegisteredPetWhereUniqueInput | RegisteredPetWhereUniqueInput[]
  }

  export type EnumApplicationTypeFieldUpdateOperationsInput = {
    set?: $Enums.ApplicationType
  }

  export type EnumIdentifierTypeFieldUpdateOperationsInput = {
    set?: $Enums.IdentifierType
  }

  export type EnumApplicantTypeFieldUpdateOperationsInput = {
    set?: $Enums.ApplicantType
  }

  export type ApplicationDocumentUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<ApplicationDocumentCreateWithoutApplicationInput, ApplicationDocumentUncheckedCreateWithoutApplicationInput> | ApplicationDocumentCreateWithoutApplicationInput[] | ApplicationDocumentUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: ApplicationDocumentCreateOrConnectWithoutApplicationInput | ApplicationDocumentCreateOrConnectWithoutApplicationInput[]
    upsert?: ApplicationDocumentUpsertWithWhereUniqueWithoutApplicationInput | ApplicationDocumentUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: ApplicationDocumentCreateManyApplicationInputEnvelope
    set?: ApplicationDocumentWhereUniqueInput | ApplicationDocumentWhereUniqueInput[]
    disconnect?: ApplicationDocumentWhereUniqueInput | ApplicationDocumentWhereUniqueInput[]
    delete?: ApplicationDocumentWhereUniqueInput | ApplicationDocumentWhereUniqueInput[]
    connect?: ApplicationDocumentWhereUniqueInput | ApplicationDocumentWhereUniqueInput[]
    update?: ApplicationDocumentUpdateWithWhereUniqueWithoutApplicationInput | ApplicationDocumentUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: ApplicationDocumentUpdateManyWithWhereWithoutApplicationInput | ApplicationDocumentUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: ApplicationDocumentScalarWhereInput | ApplicationDocumentScalarWhereInput[]
  }

  export type CheckoutItemUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<CheckoutItemCreateWithoutApplicationInput, CheckoutItemUncheckedCreateWithoutApplicationInput> | CheckoutItemCreateWithoutApplicationInput[] | CheckoutItemUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: CheckoutItemCreateOrConnectWithoutApplicationInput | CheckoutItemCreateOrConnectWithoutApplicationInput[]
    upsert?: CheckoutItemUpsertWithWhereUniqueWithoutApplicationInput | CheckoutItemUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: CheckoutItemCreateManyApplicationInputEnvelope
    set?: CheckoutItemWhereUniqueInput | CheckoutItemWhereUniqueInput[]
    disconnect?: CheckoutItemWhereUniqueInput | CheckoutItemWhereUniqueInput[]
    delete?: CheckoutItemWhereUniqueInput | CheckoutItemWhereUniqueInput[]
    connect?: CheckoutItemWhereUniqueInput | CheckoutItemWhereUniqueInput[]
    update?: CheckoutItemUpdateWithWhereUniqueWithoutApplicationInput | CheckoutItemUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: CheckoutItemUpdateManyWithWhereWithoutApplicationInput | CheckoutItemUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: CheckoutItemScalarWhereInput | CheckoutItemScalarWhereInput[]
  }

  export type RegisteredPetUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<RegisteredPetCreateWithoutApplicationInput, RegisteredPetUncheckedCreateWithoutApplicationInput> | RegisteredPetCreateWithoutApplicationInput[] | RegisteredPetUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: RegisteredPetCreateOrConnectWithoutApplicationInput | RegisteredPetCreateOrConnectWithoutApplicationInput[]
    upsert?: RegisteredPetUpsertWithWhereUniqueWithoutApplicationInput | RegisteredPetUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: RegisteredPetCreateManyApplicationInputEnvelope
    set?: RegisteredPetWhereUniqueInput | RegisteredPetWhereUniqueInput[]
    disconnect?: RegisteredPetWhereUniqueInput | RegisteredPetWhereUniqueInput[]
    delete?: RegisteredPetWhereUniqueInput | RegisteredPetWhereUniqueInput[]
    connect?: RegisteredPetWhereUniqueInput | RegisteredPetWhereUniqueInput[]
    update?: RegisteredPetUpdateWithWhereUniqueWithoutApplicationInput | RegisteredPetUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: RegisteredPetUpdateManyWithWhereWithoutApplicationInput | RegisteredPetUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: RegisteredPetScalarWhereInput | RegisteredPetScalarWhereInput[]
  }

  export type ApplicationDocumentUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<ApplicationDocumentCreateWithoutApplicationInput, ApplicationDocumentUncheckedCreateWithoutApplicationInput> | ApplicationDocumentCreateWithoutApplicationInput[] | ApplicationDocumentUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: ApplicationDocumentCreateOrConnectWithoutApplicationInput | ApplicationDocumentCreateOrConnectWithoutApplicationInput[]
    upsert?: ApplicationDocumentUpsertWithWhereUniqueWithoutApplicationInput | ApplicationDocumentUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: ApplicationDocumentCreateManyApplicationInputEnvelope
    set?: ApplicationDocumentWhereUniqueInput | ApplicationDocumentWhereUniqueInput[]
    disconnect?: ApplicationDocumentWhereUniqueInput | ApplicationDocumentWhereUniqueInput[]
    delete?: ApplicationDocumentWhereUniqueInput | ApplicationDocumentWhereUniqueInput[]
    connect?: ApplicationDocumentWhereUniqueInput | ApplicationDocumentWhereUniqueInput[]
    update?: ApplicationDocumentUpdateWithWhereUniqueWithoutApplicationInput | ApplicationDocumentUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: ApplicationDocumentUpdateManyWithWhereWithoutApplicationInput | ApplicationDocumentUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: ApplicationDocumentScalarWhereInput | ApplicationDocumentScalarWhereInput[]
  }

  export type CheckoutItemUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<CheckoutItemCreateWithoutApplicationInput, CheckoutItemUncheckedCreateWithoutApplicationInput> | CheckoutItemCreateWithoutApplicationInput[] | CheckoutItemUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: CheckoutItemCreateOrConnectWithoutApplicationInput | CheckoutItemCreateOrConnectWithoutApplicationInput[]
    upsert?: CheckoutItemUpsertWithWhereUniqueWithoutApplicationInput | CheckoutItemUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: CheckoutItemCreateManyApplicationInputEnvelope
    set?: CheckoutItemWhereUniqueInput | CheckoutItemWhereUniqueInput[]
    disconnect?: CheckoutItemWhereUniqueInput | CheckoutItemWhereUniqueInput[]
    delete?: CheckoutItemWhereUniqueInput | CheckoutItemWhereUniqueInput[]
    connect?: CheckoutItemWhereUniqueInput | CheckoutItemWhereUniqueInput[]
    update?: CheckoutItemUpdateWithWhereUniqueWithoutApplicationInput | CheckoutItemUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: CheckoutItemUpdateManyWithWhereWithoutApplicationInput | CheckoutItemUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: CheckoutItemScalarWhereInput | CheckoutItemScalarWhereInput[]
  }

  export type RegisteredPetUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<RegisteredPetCreateWithoutApplicationInput, RegisteredPetUncheckedCreateWithoutApplicationInput> | RegisteredPetCreateWithoutApplicationInput[] | RegisteredPetUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: RegisteredPetCreateOrConnectWithoutApplicationInput | RegisteredPetCreateOrConnectWithoutApplicationInput[]
    upsert?: RegisteredPetUpsertWithWhereUniqueWithoutApplicationInput | RegisteredPetUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: RegisteredPetCreateManyApplicationInputEnvelope
    set?: RegisteredPetWhereUniqueInput | RegisteredPetWhereUniqueInput[]
    disconnect?: RegisteredPetWhereUniqueInput | RegisteredPetWhereUniqueInput[]
    delete?: RegisteredPetWhereUniqueInput | RegisteredPetWhereUniqueInput[]
    connect?: RegisteredPetWhereUniqueInput | RegisteredPetWhereUniqueInput[]
    update?: RegisteredPetUpdateWithWhereUniqueWithoutApplicationInput | RegisteredPetUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: RegisteredPetUpdateManyWithWhereWithoutApplicationInput | RegisteredPetUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: RegisteredPetScalarWhereInput | RegisteredPetScalarWhereInput[]
  }

  export type PetDocumentCreateNestedManyWithoutPetInput = {
    create?: XOR<PetDocumentCreateWithoutPetInput, PetDocumentUncheckedCreateWithoutPetInput> | PetDocumentCreateWithoutPetInput[] | PetDocumentUncheckedCreateWithoutPetInput[]
    connectOrCreate?: PetDocumentCreateOrConnectWithoutPetInput | PetDocumentCreateOrConnectWithoutPetInput[]
    createMany?: PetDocumentCreateManyPetInputEnvelope
    connect?: PetDocumentWhereUniqueInput | PetDocumentWhereUniqueInput[]
  }

  export type PetRegistrationApplicationCreateNestedOneWithoutPetsInput = {
    create?: XOR<PetRegistrationApplicationCreateWithoutPetsInput, PetRegistrationApplicationUncheckedCreateWithoutPetsInput>
    connectOrCreate?: PetRegistrationApplicationCreateOrConnectWithoutPetsInput
    connect?: PetRegistrationApplicationWhereUniqueInput
  }

  export type PetDocumentUncheckedCreateNestedManyWithoutPetInput = {
    create?: XOR<PetDocumentCreateWithoutPetInput, PetDocumentUncheckedCreateWithoutPetInput> | PetDocumentCreateWithoutPetInput[] | PetDocumentUncheckedCreateWithoutPetInput[]
    connectOrCreate?: PetDocumentCreateOrConnectWithoutPetInput | PetDocumentCreateOrConnectWithoutPetInput[]
    createMany?: PetDocumentCreateManyPetInputEnvelope
    connect?: PetDocumentWhereUniqueInput | PetDocumentWhereUniqueInput[]
  }

  export type PetDocumentUpdateManyWithoutPetNestedInput = {
    create?: XOR<PetDocumentCreateWithoutPetInput, PetDocumentUncheckedCreateWithoutPetInput> | PetDocumentCreateWithoutPetInput[] | PetDocumentUncheckedCreateWithoutPetInput[]
    connectOrCreate?: PetDocumentCreateOrConnectWithoutPetInput | PetDocumentCreateOrConnectWithoutPetInput[]
    upsert?: PetDocumentUpsertWithWhereUniqueWithoutPetInput | PetDocumentUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: PetDocumentCreateManyPetInputEnvelope
    set?: PetDocumentWhereUniqueInput | PetDocumentWhereUniqueInput[]
    disconnect?: PetDocumentWhereUniqueInput | PetDocumentWhereUniqueInput[]
    delete?: PetDocumentWhereUniqueInput | PetDocumentWhereUniqueInput[]
    connect?: PetDocumentWhereUniqueInput | PetDocumentWhereUniqueInput[]
    update?: PetDocumentUpdateWithWhereUniqueWithoutPetInput | PetDocumentUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: PetDocumentUpdateManyWithWhereWithoutPetInput | PetDocumentUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: PetDocumentScalarWhereInput | PetDocumentScalarWhereInput[]
  }

  export type PetRegistrationApplicationUpdateOneRequiredWithoutPetsNestedInput = {
    create?: XOR<PetRegistrationApplicationCreateWithoutPetsInput, PetRegistrationApplicationUncheckedCreateWithoutPetsInput>
    connectOrCreate?: PetRegistrationApplicationCreateOrConnectWithoutPetsInput
    upsert?: PetRegistrationApplicationUpsertWithoutPetsInput
    connect?: PetRegistrationApplicationWhereUniqueInput
    update?: XOR<XOR<PetRegistrationApplicationUpdateToOneWithWhereWithoutPetsInput, PetRegistrationApplicationUpdateWithoutPetsInput>, PetRegistrationApplicationUncheckedUpdateWithoutPetsInput>
  }

  export type PetDocumentUncheckedUpdateManyWithoutPetNestedInput = {
    create?: XOR<PetDocumentCreateWithoutPetInput, PetDocumentUncheckedCreateWithoutPetInput> | PetDocumentCreateWithoutPetInput[] | PetDocumentUncheckedCreateWithoutPetInput[]
    connectOrCreate?: PetDocumentCreateOrConnectWithoutPetInput | PetDocumentCreateOrConnectWithoutPetInput[]
    upsert?: PetDocumentUpsertWithWhereUniqueWithoutPetInput | PetDocumentUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: PetDocumentCreateManyPetInputEnvelope
    set?: PetDocumentWhereUniqueInput | PetDocumentWhereUniqueInput[]
    disconnect?: PetDocumentWhereUniqueInput | PetDocumentWhereUniqueInput[]
    delete?: PetDocumentWhereUniqueInput | PetDocumentWhereUniqueInput[]
    connect?: PetDocumentWhereUniqueInput | PetDocumentWhereUniqueInput[]
    update?: PetDocumentUpdateWithWhereUniqueWithoutPetInput | PetDocumentUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: PetDocumentUpdateManyWithWhereWithoutPetInput | PetDocumentUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: PetDocumentScalarWhereInput | PetDocumentScalarWhereInput[]
  }

  export type PetRegistrationApplicationCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<PetRegistrationApplicationCreateWithoutDocumentsInput, PetRegistrationApplicationUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: PetRegistrationApplicationCreateOrConnectWithoutDocumentsInput
    connect?: PetRegistrationApplicationWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type PetRegistrationApplicationUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<PetRegistrationApplicationCreateWithoutDocumentsInput, PetRegistrationApplicationUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: PetRegistrationApplicationCreateOrConnectWithoutDocumentsInput
    upsert?: PetRegistrationApplicationUpsertWithoutDocumentsInput
    connect?: PetRegistrationApplicationWhereUniqueInput
    update?: XOR<XOR<PetRegistrationApplicationUpdateToOneWithWhereWithoutDocumentsInput, PetRegistrationApplicationUpdateWithoutDocumentsInput>, PetRegistrationApplicationUncheckedUpdateWithoutDocumentsInput>
  }

  export type RegisteredPetCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<RegisteredPetCreateWithoutDocumentsInput, RegisteredPetUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: RegisteredPetCreateOrConnectWithoutDocumentsInput
    connect?: RegisteredPetWhereUniqueInput
  }

  export type RegisteredPetUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<RegisteredPetCreateWithoutDocumentsInput, RegisteredPetUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: RegisteredPetCreateOrConnectWithoutDocumentsInput
    upsert?: RegisteredPetUpsertWithoutDocumentsInput
    connect?: RegisteredPetWhereUniqueInput
    update?: XOR<XOR<RegisteredPetUpdateToOneWithWhereWithoutDocumentsInput, RegisteredPetUpdateWithoutDocumentsInput>, RegisteredPetUncheckedUpdateWithoutDocumentsInput>
  }

  export type PetRegistrationApplicationCreateNestedOneWithoutCheckoutItemsInput = {
    create?: XOR<PetRegistrationApplicationCreateWithoutCheckoutItemsInput, PetRegistrationApplicationUncheckedCreateWithoutCheckoutItemsInput>
    connectOrCreate?: PetRegistrationApplicationCreateOrConnectWithoutCheckoutItemsInput
    connect?: PetRegistrationApplicationWhereUniqueInput
  }

  export type PetRegistrationApplicationUpdateOneRequiredWithoutCheckoutItemsNestedInput = {
    create?: XOR<PetRegistrationApplicationCreateWithoutCheckoutItemsInput, PetRegistrationApplicationUncheckedCreateWithoutCheckoutItemsInput>
    connectOrCreate?: PetRegistrationApplicationCreateOrConnectWithoutCheckoutItemsInput
    upsert?: PetRegistrationApplicationUpsertWithoutCheckoutItemsInput
    connect?: PetRegistrationApplicationWhereUniqueInput
    update?: XOR<XOR<PetRegistrationApplicationUpdateToOneWithWhereWithoutCheckoutItemsInput, PetRegistrationApplicationUpdateWithoutCheckoutItemsInput>, PetRegistrationApplicationUncheckedUpdateWithoutCheckoutItemsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumAuthProviderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel> | null
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAuthProviderNullableFilter<$PrismaModel> | $Enums.AuthProvider | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumAuthProviderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel> | null
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAuthProviderNullableWithAggregatesFilter<$PrismaModel> | $Enums.AuthProvider | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAuthProviderNullableFilter<$PrismaModel>
    _max?: NestedEnumAuthProviderNullableFilter<$PrismaModel>
  }

  export type NestedEnumOTPPurposeFilter<$PrismaModel = never> = {
    equals?: $Enums.OTPPurpose | EnumOTPPurposeFieldRefInput<$PrismaModel>
    in?: $Enums.OTPPurpose[] | ListEnumOTPPurposeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OTPPurpose[] | ListEnumOTPPurposeFieldRefInput<$PrismaModel>
    not?: NestedEnumOTPPurposeFilter<$PrismaModel> | $Enums.OTPPurpose
  }

  export type NestedEnumOTPPurposeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OTPPurpose | EnumOTPPurposeFieldRefInput<$PrismaModel>
    in?: $Enums.OTPPurpose[] | ListEnumOTPPurposeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OTPPurpose[] | ListEnumOTPPurposeFieldRefInput<$PrismaModel>
    not?: NestedEnumOTPPurposeWithAggregatesFilter<$PrismaModel> | $Enums.OTPPurpose
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOTPPurposeFilter<$PrismaModel>
    _max?: NestedEnumOTPPurposeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumSizeCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SizeCategory | EnumSizeCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.SizeCategory[] | ListEnumSizeCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SizeCategory[] | ListEnumSizeCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSizeCategoryNullableFilter<$PrismaModel> | $Enums.SizeCategory | null
  }

  export type NestedEnumSizeCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SizeCategory | EnumSizeCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.SizeCategory[] | ListEnumSizeCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SizeCategory[] | ListEnumSizeCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSizeCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.SizeCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSizeCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumSizeCategoryNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumPetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PetStatus | EnumPetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PetStatus[] | ListEnumPetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PetStatus[] | ListEnumPetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPetStatusFilter<$PrismaModel> | $Enums.PetStatus
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumPetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PetStatus | EnumPetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PetStatus[] | ListEnumPetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PetStatus[] | ListEnumPetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPetStatusWithAggregatesFilter<$PrismaModel> | $Enums.PetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPetStatusFilter<$PrismaModel>
    _max?: NestedEnumPetStatusFilter<$PrismaModel>
  }

  export type NestedEnumPoolStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PoolStatus | EnumPoolStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PoolStatus[] | ListEnumPoolStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoolStatus[] | ListEnumPoolStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPoolStatusFilter<$PrismaModel> | $Enums.PoolStatus
  }

  export type NestedEnumPoolStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PoolStatus | EnumPoolStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PoolStatus[] | ListEnumPoolStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoolStatus[] | ListEnumPoolStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPoolStatusWithAggregatesFilter<$PrismaModel> | $Enums.PoolStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPoolStatusFilter<$PrismaModel>
    _max?: NestedEnumPoolStatusFilter<$PrismaModel>
  }

  export type NestedEnumQRStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QRStatus | EnumQRStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QRStatus[] | ListEnumQRStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QRStatus[] | ListEnumQRStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQRStatusFilter<$PrismaModel> | $Enums.QRStatus
  }

  export type NestedEnumQRStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QRStatus | EnumQRStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QRStatus[] | ListEnumQRStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QRStatus[] | ListEnumQRStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQRStatusWithAggregatesFilter<$PrismaModel> | $Enums.QRStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQRStatusFilter<$PrismaModel>
    _max?: NestedEnumQRStatusFilter<$PrismaModel>
  }

  export type NestedEnumDeviceTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceType | EnumDeviceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DeviceType[] | ListEnumDeviceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DeviceType[] | ListEnumDeviceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDeviceTypeNullableFilter<$PrismaModel> | $Enums.DeviceType | null
  }

  export type NestedEnumScanResultFilter<$PrismaModel = never> = {
    equals?: $Enums.ScanResult | EnumScanResultFieldRefInput<$PrismaModel>
    in?: $Enums.ScanResult[] | ListEnumScanResultFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScanResult[] | ListEnumScanResultFieldRefInput<$PrismaModel>
    not?: NestedEnumScanResultFilter<$PrismaModel> | $Enums.ScanResult
  }

  export type NestedEnumDeviceTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceType | EnumDeviceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DeviceType[] | ListEnumDeviceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DeviceType[] | ListEnumDeviceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDeviceTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.DeviceType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDeviceTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumDeviceTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumScanResultWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScanResult | EnumScanResultFieldRefInput<$PrismaModel>
    in?: $Enums.ScanResult[] | ListEnumScanResultFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScanResult[] | ListEnumScanResultFieldRefInput<$PrismaModel>
    not?: NestedEnumScanResultWithAggregatesFilter<$PrismaModel> | $Enums.ScanResult
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScanResultFilter<$PrismaModel>
    _max?: NestedEnumScanResultFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusNewFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatusNew | EnumPaymentStatusNewFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatusNew[] | ListEnumPaymentStatusNewFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatusNew[] | ListEnumPaymentStatusNewFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusNewFilter<$PrismaModel> | $Enums.PaymentStatusNew
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedEnumVerificationMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationMethod | EnumVerificationMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerificationMethod[] | ListEnumVerificationMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerificationMethod[] | ListEnumVerificationMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerificationMethodNullableFilter<$PrismaModel> | $Enums.VerificationMethod | null
  }

  export type NestedEnumPaymentStatusNewWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatusNew | EnumPaymentStatusNewFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatusNew[] | ListEnumPaymentStatusNewFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatusNew[] | ListEnumPaymentStatusNewFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusNewWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatusNew
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusNewFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusNewFilter<$PrismaModel>
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumVerificationMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationMethod | EnumVerificationMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerificationMethod[] | ListEnumVerificationMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerificationMethod[] | ListEnumVerificationMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerificationMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.VerificationMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVerificationMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumVerificationMethodNullableFilter<$PrismaModel>
  }

  export type NestedEnumRefundStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundStatusFilter<$PrismaModel> | $Enums.RefundStatus
  }

  export type NestedEnumRefundStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundStatusWithAggregatesFilter<$PrismaModel> | $Enums.RefundStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRefundStatusFilter<$PrismaModel>
    _max?: NestedEnumRefundStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumPaymentPurposeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentPurpose | EnumPaymentPurposeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentPurpose[] | ListEnumPaymentPurposeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentPurpose[] | ListEnumPaymentPurposeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentPurposeFilter<$PrismaModel> | $Enums.PaymentPurpose
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentPurposeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentPurpose | EnumPaymentPurposeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentPurpose[] | ListEnumPaymentPurposeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentPurpose[] | ListEnumPaymentPurposeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentPurposeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentPurpose
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentPurposeFilter<$PrismaModel>
    _max?: NestedEnumPaymentPurposeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumLocationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationType | EnumLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLocationTypeFilter<$PrismaModel> | $Enums.LocationType
  }

  export type NestedEnumLocationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationType | EnumLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLocationTypeWithAggregatesFilter<$PrismaModel> | $Enums.LocationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLocationTypeFilter<$PrismaModel>
    _max?: NestedEnumLocationTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumPlatformFilter<$PrismaModel = never> = {
    equals?: $Enums.Platform | EnumPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.Platform[] | ListEnumPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.Platform[] | ListEnumPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumPlatformFilter<$PrismaModel> | $Enums.Platform
  }

  export type NestedEnumPlatformWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Platform | EnumPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.Platform[] | ListEnumPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.Platform[] | ListEnumPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumPlatformWithAggregatesFilter<$PrismaModel> | $Enums.Platform
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlatformFilter<$PrismaModel>
    _max?: NestedEnumPlatformFilter<$PrismaModel>
  }

  export type NestedEnumTicketCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketCategory | EnumTicketCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TicketCategory[] | ListEnumTicketCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketCategory[] | ListEnumTicketCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketCategoryFilter<$PrismaModel> | $Enums.TicketCategory
  }

  export type NestedEnumTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityFilter<$PrismaModel> | $Enums.TicketPriority
  }

  export type NestedEnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type NestedEnumTicketCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketCategory | EnumTicketCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TicketCategory[] | ListEnumTicketCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketCategory[] | ListEnumTicketCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketCategoryWithAggregatesFilter<$PrismaModel> | $Enums.TicketCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketCategoryFilter<$PrismaModel>
    _max?: NestedEnumTicketCategoryFilter<$PrismaModel>
  }

  export type NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumTicketPriorityFilter<$PrismaModel>
  }

  export type NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type NestedEnumSenderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeFilter<$PrismaModel> | $Enums.SenderType
  }

  export type NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel> | $Enums.SenderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSenderTypeFilter<$PrismaModel>
    _max?: NestedEnumSenderTypeFilter<$PrismaModel>
  }

  export type NestedEnumOperationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OperationType | EnumOperationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OperationType[] | ListEnumOperationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OperationType[] | ListEnumOperationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOperationTypeFilter<$PrismaModel> | $Enums.OperationType
  }

  export type NestedEnumOperationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OperationType | EnumOperationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OperationType[] | ListEnumOperationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OperationType[] | ListEnumOperationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOperationTypeWithAggregatesFilter<$PrismaModel> | $Enums.OperationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOperationTypeFilter<$PrismaModel>
    _max?: NestedEnumOperationTypeFilter<$PrismaModel>
  }

  export type NestedEnumApplicationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationType | EnumApplicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationType[] | ListEnumApplicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationType[] | ListEnumApplicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationTypeFilter<$PrismaModel> | $Enums.ApplicationType
  }

  export type NestedEnumIdentifierTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IdentifierType | EnumIdentifierTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IdentifierType[] | ListEnumIdentifierTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdentifierType[] | ListEnumIdentifierTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIdentifierTypeFilter<$PrismaModel> | $Enums.IdentifierType
  }

  export type NestedEnumApplicantTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicantType | EnumApplicantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicantType[] | ListEnumApplicantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicantType[] | ListEnumApplicantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicantTypeFilter<$PrismaModel> | $Enums.ApplicantType
  }

  export type NestedEnumApplicationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationType | EnumApplicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationType[] | ListEnumApplicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationType[] | ListEnumApplicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationTypeFilter<$PrismaModel>
    _max?: NestedEnumApplicationTypeFilter<$PrismaModel>
  }

  export type NestedEnumIdentifierTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IdentifierType | EnumIdentifierTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IdentifierType[] | ListEnumIdentifierTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdentifierType[] | ListEnumIdentifierTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIdentifierTypeWithAggregatesFilter<$PrismaModel> | $Enums.IdentifierType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIdentifierTypeFilter<$PrismaModel>
    _max?: NestedEnumIdentifierTypeFilter<$PrismaModel>
  }

  export type NestedEnumApplicantTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicantType | EnumApplicantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicantType[] | ListEnumApplicantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicantType[] | ListEnumApplicantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicantTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApplicantType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicantTypeFilter<$PrismaModel>
    _max?: NestedEnumApplicantTypeFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    tableName: string
    recordId: string
    operationType: $Enums.OperationType
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedColumns?: AuditLogCreatechangedColumnsInput | string[]
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    tableName: string
    recordId: string
    operationType: $Enums.OperationType
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedColumns?: AuditLogCreatechangedColumnsInput | string[]
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DeviceTokenCreateWithoutUserInput = {
    id?: string
    deviceToken: string
    platform: $Enums.Platform
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type DeviceTokenUncheckedCreateWithoutUserInput = {
    id?: string
    deviceToken: string
    platform: $Enums.Platform
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type DeviceTokenCreateOrConnectWithoutUserInput = {
    where: DeviceTokenWhereUniqueInput
    create: XOR<DeviceTokenCreateWithoutUserInput, DeviceTokenUncheckedCreateWithoutUserInput>
  }

  export type DeviceTokenCreateManyUserInputEnvelope = {
    data: DeviceTokenCreateManyUserInput | DeviceTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExecutiveCreateWithoutUserInput = {
    id?: string
    employeeId: string
    territory?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ExecutiveUncheckedCreateWithoutUserInput = {
    id?: string
    employeeId: string
    territory?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ExecutiveCreateOrConnectWithoutUserInput = {
    where: ExecutiveWhereUniqueInput
    create: XOR<ExecutiveCreateWithoutUserInput, ExecutiveUncheckedCreateWithoutUserInput>
  }

  export type LocationTrackCreateWithoutUserInput = {
    id?: string
    locationType: $Enums.LocationType
    position?: string | null
    accuracy?: Decimal | DecimalJsLike | number | string | null
    locationName?: string | null
    countryCode?: string | null
    state?: string | null
    city?: string | null
    ipAddress?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type LocationTrackUncheckedCreateWithoutUserInput = {
    id?: string
    locationType: $Enums.LocationType
    position?: string | null
    accuracy?: Decimal | DecimalJsLike | number | string | null
    locationName?: string | null
    countryCode?: string | null
    state?: string | null
    city?: string | null
    ipAddress?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type LocationTrackCreateOrConnectWithoutUserInput = {
    where: LocationTrackWhereUniqueInput
    create: XOR<LocationTrackCreateWithoutUserInput, LocationTrackUncheckedCreateWithoutUserInput>
  }

  export type LocationTrackCreateManyUserInputEnvelope = {
    data: LocationTrackCreateManyUserInput | LocationTrackCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationPreferenceCreateWithoutUserInput = {
    pushEnabled?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    scanNotifications?: boolean
    marketingNotifications?: boolean
    quietHoursStart?: Date | string | null
    quietHoursEnd?: Date | string | null
    timezone?: string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUncheckedCreateWithoutUserInput = {
    pushEnabled?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    scanNotifications?: boolean
    marketingNotifications?: boolean
    quietHoursStart?: Date | string | null
    quietHoursEnd?: Date | string | null
    timezone?: string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceCreateOrConnectWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    qrScanId?: string | null
    notificationType: $Enums.NotificationType
    title: string
    message: string
    channels?: NotificationCreatechannelsInput | string[]
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    sentAt?: Date | string | null
    readAt?: Date | string | null
    pet?: PetCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    petId?: string | null
    qrScanId?: string | null
    notificationType: $Enums.NotificationType
    title: string
    message: string
    channels?: NotificationCreatechannelsInput | string[]
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    sentAt?: Date | string | null
    readAt?: Date | string | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutUserInput = {
    id?: string
    razorpayOrderId?: string | null
    receipt?: string | null
    amountInPaise: bigint | number
    currency?: string
    status?: $Enums.OrderStatus
    notes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    rawOrderPayload?: NullableJsonNullValueInput | InputJsonValue
    payments?: PaymentCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: string
    razorpayOrderId?: string | null
    receipt?: string | null
    amountInPaise: bigint | number
    currency?: string
    status?: $Enums.OrderStatus
    notes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    rawOrderPayload?: NullableJsonNullValueInput | InputJsonValue
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OTPCodeCreateWithoutUserInput = {
    id?: string
    codeHash: string
    purpose: $Enums.OTPPurpose
    deliveryMethod?: string | null
    expiresAt: Date | string
    isUsed?: boolean
    attemptsCount?: number
    maxAttempts?: number
    createdAt?: Date | string
  }

  export type OTPCodeUncheckedCreateWithoutUserInput = {
    id?: string
    codeHash: string
    purpose: $Enums.OTPPurpose
    deliveryMethod?: string | null
    expiresAt: Date | string
    isUsed?: boolean
    attemptsCount?: number
    maxAttempts?: number
    createdAt?: Date | string
  }

  export type OTPCodeCreateOrConnectWithoutUserInput = {
    where: OTPCodeWhereUniqueInput
    create: XOR<OTPCodeCreateWithoutUserInput, OTPCodeUncheckedCreateWithoutUserInput>
  }

  export type OTPCodeCreateManyUserInputEnvelope = {
    data: OTPCodeCreateManyUserInput | OTPCodeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentEventCreateWithoutUserInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentPurpose: $Enums.PaymentPurpose
    status?: $Enums.PaymentStatus
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    razorpaySignature?: string | null
    paymentMethod?: string | null
    failureReason?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    pet?: PetCreateNestedOneWithoutPaymentEventsInput
    qrCode?: QRCodeCreateNestedOneWithoutPaymentEventsInput
    refunds?: RefundCreateNestedManyWithoutPaymentEventInput
  }

  export type PaymentEventUncheckedCreateWithoutUserInput = {
    id?: string
    petId?: string | null
    qrId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentPurpose: $Enums.PaymentPurpose
    status?: $Enums.PaymentStatus
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    razorpaySignature?: string | null
    paymentMethod?: string | null
    failureReason?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    refunds?: RefundUncheckedCreateNestedManyWithoutPaymentEventInput
  }

  export type PaymentEventCreateOrConnectWithoutUserInput = {
    where: PaymentEventWhereUniqueInput
    create: XOR<PaymentEventCreateWithoutUserInput, PaymentEventUncheckedCreateWithoutUserInput>
  }

  export type PaymentEventCreateManyUserInputEnvelope = {
    data: PaymentEventCreateManyUserInput | PaymentEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PetOwnerCreateWithoutUserInput = {
    id?: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    countryCode?: string
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pets?: PetCreateNestedManyWithoutOwnerInput
  }

  export type PetOwnerUncheckedCreateWithoutUserInput = {
    id?: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    countryCode?: string
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pets?: PetUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type PetOwnerCreateOrConnectWithoutUserInput = {
    where: PetOwnerWhereUniqueInput
    create: XOR<PetOwnerCreateWithoutUserInput, PetOwnerUncheckedCreateWithoutUserInput>
  }

  export type PetCreateWithoutRegisteredByUserInput = {
    id?: string
    name: string
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPetInput
    notifications?: NotificationCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventCreateNestedManyWithoutPetInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_breed_idTopet_breedsInput
    owner: PetOwnerCreateNestedOneWithoutPetsInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_secondary_breed_idTopet_breedsInput
    species?: PetSpeciesCreateNestedOneWithoutPetsInput
    qrCodes?: QRCodeCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordCreateNestedManyWithoutPetInput
  }

  export type PetUncheckedCreateWithoutRegisteredByUserInput = {
    id?: string
    ownerId: string
    name: string
    speciesId?: number | null
    breed_id?: number | null
    secondary_breed_id?: number | null
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPetInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventUncheckedCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventUncheckedCreateNestedManyWithoutPetInput
    qrCodes?: QRCodeUncheckedCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetCreateOrConnectWithoutRegisteredByUserInput = {
    where: PetWhereUniqueInput
    create: XOR<PetCreateWithoutRegisteredByUserInput, PetUncheckedCreateWithoutRegisteredByUserInput>
  }

  export type PetCreateManyRegisteredByUserInputEnvelope = {
    data: PetCreateManyRegisteredByUserInput | PetCreateManyRegisteredByUserInput[]
    skipDuplicates?: boolean
  }

  export type SupportMessageCreateWithoutSenderInput = {
    id?: string
    senderType: $Enums.SenderType
    message: string
    attachments?: SupportMessageCreateattachmentsInput | string[]
    isInternal?: boolean
    createdAt?: Date | string
    ticket: SupportTicketCreateNestedOneWithoutMessagesInput
  }

  export type SupportMessageUncheckedCreateWithoutSenderInput = {
    id?: string
    ticketId: string
    senderType: $Enums.SenderType
    message: string
    attachments?: SupportMessageCreateattachmentsInput | string[]
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type SupportMessageCreateOrConnectWithoutSenderInput = {
    where: SupportMessageWhereUniqueInput
    create: XOR<SupportMessageCreateWithoutSenderInput, SupportMessageUncheckedCreateWithoutSenderInput>
  }

  export type SupportMessageCreateManySenderInputEnvelope = {
    data: SupportMessageCreateManySenderInput | SupportMessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutAssignedToUserInput = {
    id?: string
    ticketNumber: string
    subject: string
    description: string
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    messages?: SupportMessageCreateNestedManyWithoutTicketInput
    pet?: PetCreateNestedOneWithoutSupportTicketsInput
    user?: UserCreateNestedOneWithoutSupportTicketsInput
  }

  export type SupportTicketUncheckedCreateWithoutAssignedToUserInput = {
    id?: string
    ticketNumber: string
    userId?: string | null
    petId?: string | null
    subject: string
    description: string
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    messages?: SupportMessageUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketCreateOrConnectWithoutAssignedToUserInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutAssignedToUserInput, SupportTicketUncheckedCreateWithoutAssignedToUserInput>
  }

  export type SupportTicketCreateManyAssignedToUserInputEnvelope = {
    data: SupportTicketCreateManyAssignedToUserInput | SupportTicketCreateManyAssignedToUserInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutUserInput = {
    id?: string
    ticketNumber: string
    subject: string
    description: string
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    messages?: SupportMessageCreateNestedManyWithoutTicketInput
    assignedToUser?: UserCreateNestedOneWithoutAssignedTicketsInput
    pet?: PetCreateNestedOneWithoutSupportTicketsInput
  }

  export type SupportTicketUncheckedCreateWithoutUserInput = {
    id?: string
    ticketNumber: string
    petId?: string | null
    subject: string
    description: string
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    assignedTo?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    messages?: SupportMessageUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketCreateOrConnectWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput>
  }

  export type SupportTicketCreateManyUserInputEnvelope = {
    data: SupportTicketCreateManyUserInput | SupportTicketCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSessionCreateWithoutUserInput = {
    id?: string
    refreshTokenHash: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type UserSessionUncheckedCreateWithoutUserInput = {
    id?: string
    refreshTokenHash: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type UserSessionCreateOrConnectWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateManyUserInputEnvelope = {
    data: UserSessionCreateManyUserInput | UserSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    tableName?: StringFilter<"AuditLog"> | string
    recordId?: UuidFilter<"AuditLog"> | string
    operationType?: EnumOperationTypeFilter<"AuditLog"> | $Enums.OperationType
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    changedColumns?: StringNullableListFilter<"AuditLog">
    userId?: UuidNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type DeviceTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: DeviceTokenWhereUniqueInput
    update: XOR<DeviceTokenUpdateWithoutUserInput, DeviceTokenUncheckedUpdateWithoutUserInput>
    create: XOR<DeviceTokenCreateWithoutUserInput, DeviceTokenUncheckedCreateWithoutUserInput>
  }

  export type DeviceTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: DeviceTokenWhereUniqueInput
    data: XOR<DeviceTokenUpdateWithoutUserInput, DeviceTokenUncheckedUpdateWithoutUserInput>
  }

  export type DeviceTokenUpdateManyWithWhereWithoutUserInput = {
    where: DeviceTokenScalarWhereInput
    data: XOR<DeviceTokenUpdateManyMutationInput, DeviceTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type DeviceTokenScalarWhereInput = {
    AND?: DeviceTokenScalarWhereInput | DeviceTokenScalarWhereInput[]
    OR?: DeviceTokenScalarWhereInput[]
    NOT?: DeviceTokenScalarWhereInput | DeviceTokenScalarWhereInput[]
    id?: UuidFilter<"DeviceToken"> | string
    userId?: UuidFilter<"DeviceToken"> | string
    deviceToken?: StringFilter<"DeviceToken"> | string
    platform?: EnumPlatformFilter<"DeviceToken"> | $Enums.Platform
    deviceInfo?: JsonNullableFilter<"DeviceToken">
    isActive?: BoolFilter<"DeviceToken"> | boolean
    createdAt?: DateTimeFilter<"DeviceToken"> | Date | string
    lastUsedAt?: DateTimeFilter<"DeviceToken"> | Date | string
  }

  export type ExecutiveUpsertWithoutUserInput = {
    update: XOR<ExecutiveUpdateWithoutUserInput, ExecutiveUncheckedUpdateWithoutUserInput>
    create: XOR<ExecutiveCreateWithoutUserInput, ExecutiveUncheckedCreateWithoutUserInput>
    where?: ExecutiveWhereInput
  }

  export type ExecutiveUpdateToOneWithWhereWithoutUserInput = {
    where?: ExecutiveWhereInput
    data: XOR<ExecutiveUpdateWithoutUserInput, ExecutiveUncheckedUpdateWithoutUserInput>
  }

  export type ExecutiveUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    territory?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExecutiveUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    territory?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationTrackUpsertWithWhereUniqueWithoutUserInput = {
    where: LocationTrackWhereUniqueInput
    update: XOR<LocationTrackUpdateWithoutUserInput, LocationTrackUncheckedUpdateWithoutUserInput>
    create: XOR<LocationTrackCreateWithoutUserInput, LocationTrackUncheckedCreateWithoutUserInput>
  }

  export type LocationTrackUpdateWithWhereUniqueWithoutUserInput = {
    where: LocationTrackWhereUniqueInput
    data: XOR<LocationTrackUpdateWithoutUserInput, LocationTrackUncheckedUpdateWithoutUserInput>
  }

  export type LocationTrackUpdateManyWithWhereWithoutUserInput = {
    where: LocationTrackScalarWhereInput
    data: XOR<LocationTrackUpdateManyMutationInput, LocationTrackUncheckedUpdateManyWithoutUserInput>
  }

  export type LocationTrackScalarWhereInput = {
    AND?: LocationTrackScalarWhereInput | LocationTrackScalarWhereInput[]
    OR?: LocationTrackScalarWhereInput[]
    NOT?: LocationTrackScalarWhereInput | LocationTrackScalarWhereInput[]
    id?: UuidFilter<"LocationTrack"> | string
    userId?: UuidNullableFilter<"LocationTrack"> | string | null
    locationType?: EnumLocationTypeFilter<"LocationTrack"> | $Enums.LocationType
    position?: StringNullableFilter<"LocationTrack"> | string | null
    accuracy?: DecimalNullableFilter<"LocationTrack"> | Decimal | DecimalJsLike | number | string | null
    locationName?: StringNullableFilter<"LocationTrack"> | string | null
    countryCode?: StringNullableFilter<"LocationTrack"> | string | null
    state?: StringNullableFilter<"LocationTrack"> | string | null
    city?: StringNullableFilter<"LocationTrack"> | string | null
    ipAddress?: StringNullableFilter<"LocationTrack"> | string | null
    deviceInfo?: JsonNullableFilter<"LocationTrack">
    timestamp?: DateTimeFilter<"LocationTrack"> | Date | string
  }

  export type NotificationPreferenceUpsertWithoutUserInput = {
    update: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    where?: NotificationPreferenceWhereInput
  }

  export type NotificationPreferenceUpdateToOneWithWhereWithoutUserInput = {
    where?: NotificationPreferenceWhereInput
    data: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPreferenceUpdateWithoutUserInput = {
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    scanNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingNotifications?: BoolFieldUpdateOperationsInput | boolean
    quietHoursStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quietHoursEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateWithoutUserInput = {
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    scanNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingNotifications?: BoolFieldUpdateOperationsInput | boolean
    quietHoursStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quietHoursEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: UuidFilter<"Notification"> | string
    userId?: UuidNullableFilter<"Notification"> | string | null
    petId?: UuidNullableFilter<"Notification"> | string | null
    qrScanId?: UuidNullableFilter<"Notification"> | string | null
    notificationType?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    channels?: StringNullableListFilter<"Notification">
    deliveryStatus?: JsonNullableFilter<"Notification">
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: UuidFilter<"Order"> | string
    razorpayOrderId?: StringNullableFilter<"Order"> | string | null
    userId?: UuidFilter<"Order"> | string
    receipt?: StringNullableFilter<"Order"> | string | null
    amountInPaise?: BigIntFilter<"Order"> | bigint | number
    currency?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    notes?: JsonNullableFilter<"Order">
    metadata?: JsonNullableFilter<"Order">
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    rawOrderPayload?: JsonNullableFilter<"Order">
  }

  export type OTPCodeUpsertWithWhereUniqueWithoutUserInput = {
    where: OTPCodeWhereUniqueInput
    update: XOR<OTPCodeUpdateWithoutUserInput, OTPCodeUncheckedUpdateWithoutUserInput>
    create: XOR<OTPCodeCreateWithoutUserInput, OTPCodeUncheckedCreateWithoutUserInput>
  }

  export type OTPCodeUpdateWithWhereUniqueWithoutUserInput = {
    where: OTPCodeWhereUniqueInput
    data: XOR<OTPCodeUpdateWithoutUserInput, OTPCodeUncheckedUpdateWithoutUserInput>
  }

  export type OTPCodeUpdateManyWithWhereWithoutUserInput = {
    where: OTPCodeScalarWhereInput
    data: XOR<OTPCodeUpdateManyMutationInput, OTPCodeUncheckedUpdateManyWithoutUserInput>
  }

  export type OTPCodeScalarWhereInput = {
    AND?: OTPCodeScalarWhereInput | OTPCodeScalarWhereInput[]
    OR?: OTPCodeScalarWhereInput[]
    NOT?: OTPCodeScalarWhereInput | OTPCodeScalarWhereInput[]
    id?: UuidFilter<"OTPCode"> | string
    userId?: UuidFilter<"OTPCode"> | string
    codeHash?: StringFilter<"OTPCode"> | string
    purpose?: EnumOTPPurposeFilter<"OTPCode"> | $Enums.OTPPurpose
    deliveryMethod?: StringNullableFilter<"OTPCode"> | string | null
    expiresAt?: DateTimeFilter<"OTPCode"> | Date | string
    isUsed?: BoolFilter<"OTPCode"> | boolean
    attemptsCount?: IntFilter<"OTPCode"> | number
    maxAttempts?: IntFilter<"OTPCode"> | number
    createdAt?: DateTimeFilter<"OTPCode"> | Date | string
  }

  export type PaymentEventUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentEventWhereUniqueInput
    update: XOR<PaymentEventUpdateWithoutUserInput, PaymentEventUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentEventCreateWithoutUserInput, PaymentEventUncheckedCreateWithoutUserInput>
  }

  export type PaymentEventUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentEventWhereUniqueInput
    data: XOR<PaymentEventUpdateWithoutUserInput, PaymentEventUncheckedUpdateWithoutUserInput>
  }

  export type PaymentEventUpdateManyWithWhereWithoutUserInput = {
    where: PaymentEventScalarWhereInput
    data: XOR<PaymentEventUpdateManyMutationInput, PaymentEventUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentEventScalarWhereInput = {
    AND?: PaymentEventScalarWhereInput | PaymentEventScalarWhereInput[]
    OR?: PaymentEventScalarWhereInput[]
    NOT?: PaymentEventScalarWhereInput | PaymentEventScalarWhereInput[]
    id?: UuidFilter<"PaymentEvent"> | string
    userId?: UuidNullableFilter<"PaymentEvent"> | string | null
    petId?: UuidNullableFilter<"PaymentEvent"> | string | null
    qrId?: UuidNullableFilter<"PaymentEvent"> | string | null
    amount?: DecimalFilter<"PaymentEvent"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"PaymentEvent"> | string
    paymentPurpose?: EnumPaymentPurposeFilter<"PaymentEvent"> | $Enums.PaymentPurpose
    status?: EnumPaymentStatusFilter<"PaymentEvent"> | $Enums.PaymentStatus
    razorpayOrderId?: StringNullableFilter<"PaymentEvent"> | string | null
    razorpayPaymentId?: StringNullableFilter<"PaymentEvent"> | string | null
    razorpaySignature?: StringNullableFilter<"PaymentEvent"> | string | null
    paymentMethod?: StringNullableFilter<"PaymentEvent"> | string | null
    failureReason?: StringNullableFilter<"PaymentEvent"> | string | null
    createdAt?: DateTimeFilter<"PaymentEvent"> | Date | string
    completedAt?: DateTimeNullableFilter<"PaymentEvent"> | Date | string | null
  }

  export type PetOwnerUpsertWithoutUserInput = {
    update: XOR<PetOwnerUpdateWithoutUserInput, PetOwnerUncheckedUpdateWithoutUserInput>
    create: XOR<PetOwnerCreateWithoutUserInput, PetOwnerUncheckedCreateWithoutUserInput>
    where?: PetOwnerWhereInput
  }

  export type PetOwnerUpdateToOneWithWhereWithoutUserInput = {
    where?: PetOwnerWhereInput
    data: XOR<PetOwnerUpdateWithoutUserInput, PetOwnerUncheckedUpdateWithoutUserInput>
  }

  export type PetOwnerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: StringFieldUpdateOperationsInput | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pets?: PetUpdateManyWithoutOwnerNestedInput
  }

  export type PetOwnerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: StringFieldUpdateOperationsInput | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pets?: PetUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type PetUpsertWithWhereUniqueWithoutRegisteredByUserInput = {
    where: PetWhereUniqueInput
    update: XOR<PetUpdateWithoutRegisteredByUserInput, PetUncheckedUpdateWithoutRegisteredByUserInput>
    create: XOR<PetCreateWithoutRegisteredByUserInput, PetUncheckedCreateWithoutRegisteredByUserInput>
  }

  export type PetUpdateWithWhereUniqueWithoutRegisteredByUserInput = {
    where: PetWhereUniqueInput
    data: XOR<PetUpdateWithoutRegisteredByUserInput, PetUncheckedUpdateWithoutRegisteredByUserInput>
  }

  export type PetUpdateManyWithWhereWithoutRegisteredByUserInput = {
    where: PetScalarWhereInput
    data: XOR<PetUpdateManyMutationInput, PetUncheckedUpdateManyWithoutRegisteredByUserInput>
  }

  export type PetScalarWhereInput = {
    AND?: PetScalarWhereInput | PetScalarWhereInput[]
    OR?: PetScalarWhereInput[]
    NOT?: PetScalarWhereInput | PetScalarWhereInput[]
    id?: UuidFilter<"Pet"> | string
    ownerId?: UuidFilter<"Pet"> | string
    registeredBy?: UuidNullableFilter<"Pet"> | string | null
    name?: StringFilter<"Pet"> | string
    speciesId?: IntNullableFilter<"Pet"> | number | null
    breed_id?: IntNullableFilter<"Pet"> | number | null
    secondary_breed_id?: IntNullableFilter<"Pet"> | number | null
    gender?: EnumGenderFilter<"Pet"> | $Enums.Gender
    birthDate?: DateTimeNullableFilter<"Pet"> | Date | string | null
    color?: StringNullableFilter<"Pet"> | string | null
    weightKg?: DecimalNullableFilter<"Pet"> | Decimal | DecimalJsLike | number | string | null
    heightCm?: DecimalNullableFilter<"Pet"> | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: StringNullableFilter<"Pet"> | string | null
    isSpayedNeutered?: BoolNullableFilter<"Pet"> | boolean | null
    microchip_id?: StringNullableFilter<"Pet"> | string | null
    registrationNumber?: StringNullableFilter<"Pet"> | string | null
    status?: EnumPetStatusFilter<"Pet"> | $Enums.PetStatus
    specialNeeds?: StringNullableFilter<"Pet"> | string | null
    behavioralNotes?: StringNullableFilter<"Pet"> | string | null
    profileImageUrl?: StringNullableFilter<"Pet"> | string | null
    createdAt?: DateTimeFilter<"Pet"> | Date | string
    updatedAt?: DateTimeFilter<"Pet"> | Date | string
  }

  export type SupportMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: SupportMessageWhereUniqueInput
    update: XOR<SupportMessageUpdateWithoutSenderInput, SupportMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<SupportMessageCreateWithoutSenderInput, SupportMessageUncheckedCreateWithoutSenderInput>
  }

  export type SupportMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: SupportMessageWhereUniqueInput
    data: XOR<SupportMessageUpdateWithoutSenderInput, SupportMessageUncheckedUpdateWithoutSenderInput>
  }

  export type SupportMessageUpdateManyWithWhereWithoutSenderInput = {
    where: SupportMessageScalarWhereInput
    data: XOR<SupportMessageUpdateManyMutationInput, SupportMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type SupportMessageScalarWhereInput = {
    AND?: SupportMessageScalarWhereInput | SupportMessageScalarWhereInput[]
    OR?: SupportMessageScalarWhereInput[]
    NOT?: SupportMessageScalarWhereInput | SupportMessageScalarWhereInput[]
    id?: UuidFilter<"SupportMessage"> | string
    ticketId?: UuidFilter<"SupportMessage"> | string
    senderId?: UuidNullableFilter<"SupportMessage"> | string | null
    senderType?: EnumSenderTypeFilter<"SupportMessage"> | $Enums.SenderType
    message?: StringFilter<"SupportMessage"> | string
    attachments?: StringNullableListFilter<"SupportMessage">
    isInternal?: BoolFilter<"SupportMessage"> | boolean
    createdAt?: DateTimeFilter<"SupportMessage"> | Date | string
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutAssignedToUserInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutAssignedToUserInput, SupportTicketUncheckedUpdateWithoutAssignedToUserInput>
    create: XOR<SupportTicketCreateWithoutAssignedToUserInput, SupportTicketUncheckedCreateWithoutAssignedToUserInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutAssignedToUserInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutAssignedToUserInput, SupportTicketUncheckedUpdateWithoutAssignedToUserInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutAssignedToUserInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutAssignedToUserInput>
  }

  export type SupportTicketScalarWhereInput = {
    AND?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    OR?: SupportTicketScalarWhereInput[]
    NOT?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    id?: UuidFilter<"SupportTicket"> | string
    ticketNumber?: StringFilter<"SupportTicket"> | string
    userId?: UuidNullableFilter<"SupportTicket"> | string | null
    petId?: UuidNullableFilter<"SupportTicket"> | string | null
    subject?: StringFilter<"SupportTicket"> | string
    description?: StringFilter<"SupportTicket"> | string
    category?: EnumTicketCategoryFilter<"SupportTicket"> | $Enums.TicketCategory
    priority?: EnumTicketPriorityFilter<"SupportTicket"> | $Enums.TicketPriority
    status?: EnumTicketStatusFilter<"SupportTicket"> | $Enums.TicketStatus
    assignedTo?: UuidNullableFilter<"SupportTicket"> | string | null
    resolution?: StringNullableFilter<"SupportTicket"> | string | null
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutUserInput, SupportTicketUncheckedUpdateWithoutUserInput>
    create: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutUserInput, SupportTicketUncheckedUpdateWithoutUserInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutUserInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutUserInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionScalarWhereInput = {
    AND?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    OR?: UserSessionScalarWhereInput[]
    NOT?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    id?: UuidFilter<"UserSession"> | string
    userId?: UuidFilter<"UserSession"> | string
    refreshTokenHash?: StringFilter<"UserSession"> | string
    deviceInfo?: JsonNullableFilter<"UserSession">
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    lastUsedAt?: DateTimeFilter<"UserSession"> | Date | string
  }

  export type UserCreateWithoutOtpCodesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    executive?: ExecutiveCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerCreateNestedOneWithoutUserInput
    registeredPets?: PetCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOtpCodesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    executive?: ExecutiveUncheckedCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerUncheckedCreateNestedOneWithoutUserInput
    registeredPets?: PetUncheckedCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOtpCodesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOtpCodesInput, UserUncheckedCreateWithoutOtpCodesInput>
  }

  export type UserUpsertWithoutOtpCodesInput = {
    update: XOR<UserUpdateWithoutOtpCodesInput, UserUncheckedUpdateWithoutOtpCodesInput>
    create: XOR<UserCreateWithoutOtpCodesInput, UserUncheckedCreateWithoutOtpCodesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOtpCodesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOtpCodesInput, UserUncheckedUpdateWithoutOtpCodesInput>
  }

  export type UserUpdateWithoutOtpCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUpdateOneWithoutUserNestedInput
    registeredPets?: PetUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOtpCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUncheckedUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUncheckedUpdateOneWithoutUserNestedInput
    registeredPets?: PetUncheckedUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    executive?: ExecutiveCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerCreateNestedOneWithoutUserInput
    registeredPets?: PetCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    executive?: ExecutiveUncheckedCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeUncheckedCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerUncheckedCreateNestedOneWithoutUserInput
    registeredPets?: PetUncheckedCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUpdateOneWithoutUserNestedInput
    registeredPets?: PetUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUncheckedUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUncheckedUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUncheckedUpdateOneWithoutUserNestedInput
    registeredPets?: PetUncheckedUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutExecutiveInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    locationTracks?: LocationTrackCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerCreateNestedOneWithoutUserInput
    registeredPets?: PetCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExecutiveInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    locationTracks?: LocationTrackUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeUncheckedCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerUncheckedCreateNestedOneWithoutUserInput
    registeredPets?: PetUncheckedCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExecutiveInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExecutiveInput, UserUncheckedCreateWithoutExecutiveInput>
  }

  export type UserUpsertWithoutExecutiveInput = {
    update: XOR<UserUpdateWithoutExecutiveInput, UserUncheckedUpdateWithoutExecutiveInput>
    create: XOR<UserCreateWithoutExecutiveInput, UserUncheckedCreateWithoutExecutiveInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExecutiveInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExecutiveInput, UserUncheckedUpdateWithoutExecutiveInput>
  }

  export type UserUpdateWithoutExecutiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    locationTracks?: LocationTrackUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUpdateOneWithoutUserNestedInput
    registeredPets?: PetUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExecutiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    locationTracks?: LocationTrackUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUncheckedUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUncheckedUpdateOneWithoutUserNestedInput
    registeredPets?: PetUncheckedUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPetOwnerInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    executive?: ExecutiveCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutUserInput
    registeredPets?: PetCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPetOwnerInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    executive?: ExecutiveUncheckedCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeUncheckedCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutUserInput
    registeredPets?: PetUncheckedCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPetOwnerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPetOwnerInput, UserUncheckedCreateWithoutPetOwnerInput>
  }

  export type PetCreateWithoutOwnerInput = {
    id?: string
    name: string
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPetInput
    notifications?: NotificationCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventCreateNestedManyWithoutPetInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_breed_idTopet_breedsInput
    registeredByUser?: UserCreateNestedOneWithoutRegisteredPetsInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_secondary_breed_idTopet_breedsInput
    species?: PetSpeciesCreateNestedOneWithoutPetsInput
    qrCodes?: QRCodeCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordCreateNestedManyWithoutPetInput
  }

  export type PetUncheckedCreateWithoutOwnerInput = {
    id?: string
    registeredBy?: string | null
    name: string
    speciesId?: number | null
    breed_id?: number | null
    secondary_breed_id?: number | null
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPetInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventUncheckedCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventUncheckedCreateNestedManyWithoutPetInput
    qrCodes?: QRCodeUncheckedCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetCreateOrConnectWithoutOwnerInput = {
    where: PetWhereUniqueInput
    create: XOR<PetCreateWithoutOwnerInput, PetUncheckedCreateWithoutOwnerInput>
  }

  export type PetCreateManyOwnerInputEnvelope = {
    data: PetCreateManyOwnerInput | PetCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPetOwnerInput = {
    update: XOR<UserUpdateWithoutPetOwnerInput, UserUncheckedUpdateWithoutPetOwnerInput>
    create: XOR<UserCreateWithoutPetOwnerInput, UserUncheckedCreateWithoutPetOwnerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPetOwnerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPetOwnerInput, UserUncheckedUpdateWithoutPetOwnerInput>
  }

  export type UserUpdateWithoutPetOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutUserNestedInput
    registeredPets?: PetUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPetOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUncheckedUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUncheckedUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutUserNestedInput
    registeredPets?: PetUncheckedUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PetUpsertWithWhereUniqueWithoutOwnerInput = {
    where: PetWhereUniqueInput
    update: XOR<PetUpdateWithoutOwnerInput, PetUncheckedUpdateWithoutOwnerInput>
    create: XOR<PetCreateWithoutOwnerInput, PetUncheckedCreateWithoutOwnerInput>
  }

  export type PetUpdateWithWhereUniqueWithoutOwnerInput = {
    where: PetWhereUniqueInput
    data: XOR<PetUpdateWithoutOwnerInput, PetUncheckedUpdateWithoutOwnerInput>
  }

  export type PetUpdateManyWithWhereWithoutOwnerInput = {
    where: PetScalarWhereInput
    data: XOR<PetUpdateManyMutationInput, PetUncheckedUpdateManyWithoutOwnerInput>
  }

  export type PetBreedCreateWithoutSpeciesInput = {
    breedName: string
    sizeCategory?: $Enums.SizeCategory | null
    typicalLifespanYears?: number | null
    pets_pets_breed_idTopet_breeds?: PetCreateNestedManyWithoutPet_breeds_pets_breed_idTopet_breedsInput
    pets_pets_secondary_breed_idTopet_breeds?: PetCreateNestedManyWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput
  }

  export type PetBreedUncheckedCreateWithoutSpeciesInput = {
    id?: number
    breedName: string
    sizeCategory?: $Enums.SizeCategory | null
    typicalLifespanYears?: number | null
    pets_pets_breed_idTopet_breeds?: PetUncheckedCreateNestedManyWithoutPet_breeds_pets_breed_idTopet_breedsInput
    pets_pets_secondary_breed_idTopet_breeds?: PetUncheckedCreateNestedManyWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput
  }

  export type PetBreedCreateOrConnectWithoutSpeciesInput = {
    where: PetBreedWhereUniqueInput
    create: XOR<PetBreedCreateWithoutSpeciesInput, PetBreedUncheckedCreateWithoutSpeciesInput>
  }

  export type PetBreedCreateManySpeciesInputEnvelope = {
    data: PetBreedCreateManySpeciesInput | PetBreedCreateManySpeciesInput[]
    skipDuplicates?: boolean
  }

  export type PetCreateWithoutSpeciesInput = {
    id?: string
    name: string
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPetInput
    notifications?: NotificationCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventCreateNestedManyWithoutPetInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_breed_idTopet_breedsInput
    owner: PetOwnerCreateNestedOneWithoutPetsInput
    registeredByUser?: UserCreateNestedOneWithoutRegisteredPetsInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_secondary_breed_idTopet_breedsInput
    qrCodes?: QRCodeCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordCreateNestedManyWithoutPetInput
  }

  export type PetUncheckedCreateWithoutSpeciesInput = {
    id?: string
    ownerId: string
    registeredBy?: string | null
    name: string
    breed_id?: number | null
    secondary_breed_id?: number | null
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPetInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventUncheckedCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventUncheckedCreateNestedManyWithoutPetInput
    qrCodes?: QRCodeUncheckedCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetCreateOrConnectWithoutSpeciesInput = {
    where: PetWhereUniqueInput
    create: XOR<PetCreateWithoutSpeciesInput, PetUncheckedCreateWithoutSpeciesInput>
  }

  export type PetCreateManySpeciesInputEnvelope = {
    data: PetCreateManySpeciesInput | PetCreateManySpeciesInput[]
    skipDuplicates?: boolean
  }

  export type PetBreedUpsertWithWhereUniqueWithoutSpeciesInput = {
    where: PetBreedWhereUniqueInput
    update: XOR<PetBreedUpdateWithoutSpeciesInput, PetBreedUncheckedUpdateWithoutSpeciesInput>
    create: XOR<PetBreedCreateWithoutSpeciesInput, PetBreedUncheckedCreateWithoutSpeciesInput>
  }

  export type PetBreedUpdateWithWhereUniqueWithoutSpeciesInput = {
    where: PetBreedWhereUniqueInput
    data: XOR<PetBreedUpdateWithoutSpeciesInput, PetBreedUncheckedUpdateWithoutSpeciesInput>
  }

  export type PetBreedUpdateManyWithWhereWithoutSpeciesInput = {
    where: PetBreedScalarWhereInput
    data: XOR<PetBreedUpdateManyMutationInput, PetBreedUncheckedUpdateManyWithoutSpeciesInput>
  }

  export type PetBreedScalarWhereInput = {
    AND?: PetBreedScalarWhereInput | PetBreedScalarWhereInput[]
    OR?: PetBreedScalarWhereInput[]
    NOT?: PetBreedScalarWhereInput | PetBreedScalarWhereInput[]
    id?: IntFilter<"PetBreed"> | number
    breedName?: StringFilter<"PetBreed"> | string
    speciesId?: IntFilter<"PetBreed"> | number
    sizeCategory?: EnumSizeCategoryNullableFilter<"PetBreed"> | $Enums.SizeCategory | null
    typicalLifespanYears?: IntNullableFilter<"PetBreed"> | number | null
  }

  export type PetUpsertWithWhereUniqueWithoutSpeciesInput = {
    where: PetWhereUniqueInput
    update: XOR<PetUpdateWithoutSpeciesInput, PetUncheckedUpdateWithoutSpeciesInput>
    create: XOR<PetCreateWithoutSpeciesInput, PetUncheckedCreateWithoutSpeciesInput>
  }

  export type PetUpdateWithWhereUniqueWithoutSpeciesInput = {
    where: PetWhereUniqueInput
    data: XOR<PetUpdateWithoutSpeciesInput, PetUncheckedUpdateWithoutSpeciesInput>
  }

  export type PetUpdateManyWithWhereWithoutSpeciesInput = {
    where: PetScalarWhereInput
    data: XOR<PetUpdateManyMutationInput, PetUncheckedUpdateManyWithoutSpeciesInput>
  }

  export type PetSpeciesCreateWithoutBreedsInput = {
    speciesName: string
    category: string
    pets?: PetCreateNestedManyWithoutSpeciesInput
  }

  export type PetSpeciesUncheckedCreateWithoutBreedsInput = {
    id?: number
    speciesName: string
    category: string
    pets?: PetUncheckedCreateNestedManyWithoutSpeciesInput
  }

  export type PetSpeciesCreateOrConnectWithoutBreedsInput = {
    where: PetSpeciesWhereUniqueInput
    create: XOR<PetSpeciesCreateWithoutBreedsInput, PetSpeciesUncheckedCreateWithoutBreedsInput>
  }

  export type PetCreateWithoutPet_breeds_pets_breed_idTopet_breedsInput = {
    id?: string
    name: string
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPetInput
    notifications?: NotificationCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventCreateNestedManyWithoutPetInput
    owner: PetOwnerCreateNestedOneWithoutPetsInput
    registeredByUser?: UserCreateNestedOneWithoutRegisteredPetsInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_secondary_breed_idTopet_breedsInput
    species?: PetSpeciesCreateNestedOneWithoutPetsInput
    qrCodes?: QRCodeCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordCreateNestedManyWithoutPetInput
  }

  export type PetUncheckedCreateWithoutPet_breeds_pets_breed_idTopet_breedsInput = {
    id?: string
    ownerId: string
    registeredBy?: string | null
    name: string
    speciesId?: number | null
    secondary_breed_id?: number | null
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPetInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventUncheckedCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventUncheckedCreateNestedManyWithoutPetInput
    qrCodes?: QRCodeUncheckedCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetCreateOrConnectWithoutPet_breeds_pets_breed_idTopet_breedsInput = {
    where: PetWhereUniqueInput
    create: XOR<PetCreateWithoutPet_breeds_pets_breed_idTopet_breedsInput, PetUncheckedCreateWithoutPet_breeds_pets_breed_idTopet_breedsInput>
  }

  export type PetCreateManyPet_breeds_pets_breed_idTopet_breedsInputEnvelope = {
    data: PetCreateManyPet_breeds_pets_breed_idTopet_breedsInput | PetCreateManyPet_breeds_pets_breed_idTopet_breedsInput[]
    skipDuplicates?: boolean
  }

  export type PetCreateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput = {
    id?: string
    name: string
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPetInput
    notifications?: NotificationCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventCreateNestedManyWithoutPetInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_breed_idTopet_breedsInput
    owner: PetOwnerCreateNestedOneWithoutPetsInput
    registeredByUser?: UserCreateNestedOneWithoutRegisteredPetsInput
    species?: PetSpeciesCreateNestedOneWithoutPetsInput
    qrCodes?: QRCodeCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordCreateNestedManyWithoutPetInput
  }

  export type PetUncheckedCreateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput = {
    id?: string
    ownerId: string
    registeredBy?: string | null
    name: string
    speciesId?: number | null
    breed_id?: number | null
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPetInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventUncheckedCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventUncheckedCreateNestedManyWithoutPetInput
    qrCodes?: QRCodeUncheckedCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetCreateOrConnectWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput = {
    where: PetWhereUniqueInput
    create: XOR<PetCreateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput, PetUncheckedCreateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput>
  }

  export type PetCreateManyPet_breeds_pets_secondary_breed_idTopet_breedsInputEnvelope = {
    data: PetCreateManyPet_breeds_pets_secondary_breed_idTopet_breedsInput | PetCreateManyPet_breeds_pets_secondary_breed_idTopet_breedsInput[]
    skipDuplicates?: boolean
  }

  export type PetSpeciesUpsertWithoutBreedsInput = {
    update: XOR<PetSpeciesUpdateWithoutBreedsInput, PetSpeciesUncheckedUpdateWithoutBreedsInput>
    create: XOR<PetSpeciesCreateWithoutBreedsInput, PetSpeciesUncheckedCreateWithoutBreedsInput>
    where?: PetSpeciesWhereInput
  }

  export type PetSpeciesUpdateToOneWithWhereWithoutBreedsInput = {
    where?: PetSpeciesWhereInput
    data: XOR<PetSpeciesUpdateWithoutBreedsInput, PetSpeciesUncheckedUpdateWithoutBreedsInput>
  }

  export type PetSpeciesUpdateWithoutBreedsInput = {
    speciesName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pets?: PetUpdateManyWithoutSpeciesNestedInput
  }

  export type PetSpeciesUncheckedUpdateWithoutBreedsInput = {
    id?: IntFieldUpdateOperationsInput | number
    speciesName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pets?: PetUncheckedUpdateManyWithoutSpeciesNestedInput
  }

  export type PetUpsertWithWhereUniqueWithoutPet_breeds_pets_breed_idTopet_breedsInput = {
    where: PetWhereUniqueInput
    update: XOR<PetUpdateWithoutPet_breeds_pets_breed_idTopet_breedsInput, PetUncheckedUpdateWithoutPet_breeds_pets_breed_idTopet_breedsInput>
    create: XOR<PetCreateWithoutPet_breeds_pets_breed_idTopet_breedsInput, PetUncheckedCreateWithoutPet_breeds_pets_breed_idTopet_breedsInput>
  }

  export type PetUpdateWithWhereUniqueWithoutPet_breeds_pets_breed_idTopet_breedsInput = {
    where: PetWhereUniqueInput
    data: XOR<PetUpdateWithoutPet_breeds_pets_breed_idTopet_breedsInput, PetUncheckedUpdateWithoutPet_breeds_pets_breed_idTopet_breedsInput>
  }

  export type PetUpdateManyWithWhereWithoutPet_breeds_pets_breed_idTopet_breedsInput = {
    where: PetScalarWhereInput
    data: XOR<PetUpdateManyMutationInput, PetUncheckedUpdateManyWithoutPet_breeds_pets_breed_idTopet_breedsInput>
  }

  export type PetUpsertWithWhereUniqueWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput = {
    where: PetWhereUniqueInput
    update: XOR<PetUpdateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput, PetUncheckedUpdateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput>
    create: XOR<PetCreateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput, PetUncheckedCreateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput>
  }

  export type PetUpdateWithWhereUniqueWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput = {
    where: PetWhereUniqueInput
    data: XOR<PetUpdateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput, PetUncheckedUpdateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput>
  }

  export type PetUpdateManyWithWhereWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput = {
    where: PetScalarWhereInput
    data: XOR<PetUpdateManyMutationInput, PetUncheckedUpdateManyWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput>
  }

  export type MedicalRecordCreateWithoutPetInput = {
    id?: string
    visitDate: Date | string
    veterinarianName?: string | null
    clinicName?: string | null
    diagnosis?: string | null
    treatment?: string | null
    medications?: NullableJsonNullValueInput | InputJsonValue
    followUpRequired?: boolean
    followUpDate?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    documentUrls?: MedicalRecordCreatedocumentUrlsInput | string[]
    createdAt?: Date | string
  }

  export type MedicalRecordUncheckedCreateWithoutPetInput = {
    id?: string
    visitDate: Date | string
    veterinarianName?: string | null
    clinicName?: string | null
    diagnosis?: string | null
    treatment?: string | null
    medications?: NullableJsonNullValueInput | InputJsonValue
    followUpRequired?: boolean
    followUpDate?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    documentUrls?: MedicalRecordCreatedocumentUrlsInput | string[]
    createdAt?: Date | string
  }

  export type MedicalRecordCreateOrConnectWithoutPetInput = {
    where: MedicalRecordWhereUniqueInput
    create: XOR<MedicalRecordCreateWithoutPetInput, MedicalRecordUncheckedCreateWithoutPetInput>
  }

  export type MedicalRecordCreateManyPetInputEnvelope = {
    data: MedicalRecordCreateManyPetInput | MedicalRecordCreateManyPetInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutPetInput = {
    id?: string
    qrScanId?: string | null
    notificationType: $Enums.NotificationType
    title: string
    message: string
    channels?: NotificationCreatechannelsInput | string[]
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    sentAt?: Date | string | null
    readAt?: Date | string | null
    user?: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutPetInput = {
    id?: string
    userId?: string | null
    qrScanId?: string | null
    notificationType: $Enums.NotificationType
    title: string
    message: string
    channels?: NotificationCreatechannelsInput | string[]
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    sentAt?: Date | string | null
    readAt?: Date | string | null
  }

  export type NotificationCreateOrConnectWithoutPetInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutPetInput, NotificationUncheckedCreateWithoutPetInput>
  }

  export type NotificationCreateManyPetInputEnvelope = {
    data: NotificationCreateManyPetInput | NotificationCreateManyPetInput[]
    skipDuplicates?: boolean
  }

  export type PaymentEventCreateWithoutPetInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentPurpose: $Enums.PaymentPurpose
    status?: $Enums.PaymentStatus
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    razorpaySignature?: string | null
    paymentMethod?: string | null
    failureReason?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    qrCode?: QRCodeCreateNestedOneWithoutPaymentEventsInput
    user?: UserCreateNestedOneWithoutPaymentEventsInput
    refunds?: RefundCreateNestedManyWithoutPaymentEventInput
  }

  export type PaymentEventUncheckedCreateWithoutPetInput = {
    id?: string
    userId?: string | null
    qrId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentPurpose: $Enums.PaymentPurpose
    status?: $Enums.PaymentStatus
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    razorpaySignature?: string | null
    paymentMethod?: string | null
    failureReason?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    refunds?: RefundUncheckedCreateNestedManyWithoutPaymentEventInput
  }

  export type PaymentEventCreateOrConnectWithoutPetInput = {
    where: PaymentEventWhereUniqueInput
    create: XOR<PaymentEventCreateWithoutPetInput, PaymentEventUncheckedCreateWithoutPetInput>
  }

  export type PaymentEventCreateManyPetInputEnvelope = {
    data: PaymentEventCreateManyPetInput | PaymentEventCreateManyPetInput[]
    skipDuplicates?: boolean
  }

  export type PetLocationEventCreateWithoutPetInput = {
    id?: string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    accuracy?: Decimal | DecimalJsLike | number | string | null
    scannerIp?: string | null
    userAgent?: string | null
    deviceType?: $Enums.DeviceType | null
    locationName?: string | null
    countryCode?: string | null
    city?: string | null
    state?: string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    qrScanEvent?: QRScanEventCreateNestedOneWithoutLocationEventsInput
  }

  export type PetLocationEventUncheckedCreateWithoutPetInput = {
    id?: string
    qrScanId?: string | null
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    accuracy?: Decimal | DecimalJsLike | number | string | null
    scannerIp?: string | null
    userAgent?: string | null
    deviceType?: $Enums.DeviceType | null
    locationName?: string | null
    countryCode?: string | null
    city?: string | null
    state?: string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PetLocationEventCreateOrConnectWithoutPetInput = {
    where: PetLocationEventWhereUniqueInput
    create: XOR<PetLocationEventCreateWithoutPetInput, PetLocationEventUncheckedCreateWithoutPetInput>
  }

  export type PetLocationEventCreateManyPetInputEnvelope = {
    data: PetLocationEventCreateManyPetInput | PetLocationEventCreateManyPetInput[]
    skipDuplicates?: boolean
  }

  export type QRScanEventCreateWithoutPetInput = {
    id?: string
    scanTimestamp?: Date | string
    scannerIp?: string | null
    userAgent?: string | null
    deviceType?: $Enums.DeviceType | null
    scanLocation?: string | null
    locationAccuracy?: Decimal | DecimalJsLike | number | string | null
    locationName?: string | null
    countryCode?: string | null
    city?: string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    scanResult: $Enums.ScanResult
    createdAt?: Date | string
    qrCode: QRCodeCreateNestedOneWithoutScanEventsInput
    locationEvents?: PetLocationEventCreateNestedManyWithoutQrScanEventInput
  }

  export type QRScanEventUncheckedCreateWithoutPetInput = {
    id?: string
    qrId: string
    scanTimestamp?: Date | string
    scannerIp?: string | null
    userAgent?: string | null
    deviceType?: $Enums.DeviceType | null
    scanLocation?: string | null
    locationAccuracy?: Decimal | DecimalJsLike | number | string | null
    locationName?: string | null
    countryCode?: string | null
    city?: string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    scanResult: $Enums.ScanResult
    createdAt?: Date | string
    locationEvents?: PetLocationEventUncheckedCreateNestedManyWithoutQrScanEventInput
  }

  export type QRScanEventCreateOrConnectWithoutPetInput = {
    where: QRScanEventWhereUniqueInput
    create: XOR<QRScanEventCreateWithoutPetInput, QRScanEventUncheckedCreateWithoutPetInput>
  }

  export type QRScanEventCreateManyPetInputEnvelope = {
    data: QRScanEventCreateManyPetInput | QRScanEventCreateManyPetInput[]
    skipDuplicates?: boolean
  }

  export type PetBreedCreateWithoutPets_pets_breed_idTopet_breedsInput = {
    breedName: string
    sizeCategory?: $Enums.SizeCategory | null
    typicalLifespanYears?: number | null
    species: PetSpeciesCreateNestedOneWithoutBreedsInput
    pets_pets_secondary_breed_idTopet_breeds?: PetCreateNestedManyWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput
  }

  export type PetBreedUncheckedCreateWithoutPets_pets_breed_idTopet_breedsInput = {
    id?: number
    breedName: string
    speciesId: number
    sizeCategory?: $Enums.SizeCategory | null
    typicalLifespanYears?: number | null
    pets_pets_secondary_breed_idTopet_breeds?: PetUncheckedCreateNestedManyWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput
  }

  export type PetBreedCreateOrConnectWithoutPets_pets_breed_idTopet_breedsInput = {
    where: PetBreedWhereUniqueInput
    create: XOR<PetBreedCreateWithoutPets_pets_breed_idTopet_breedsInput, PetBreedUncheckedCreateWithoutPets_pets_breed_idTopet_breedsInput>
  }

  export type PetOwnerCreateWithoutPetsInput = {
    id?: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    countryCode?: string
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPetOwnerInput
  }

  export type PetOwnerUncheckedCreateWithoutPetsInput = {
    id?: string
    userId: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    countryCode?: string
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PetOwnerCreateOrConnectWithoutPetsInput = {
    where: PetOwnerWhereUniqueInput
    create: XOR<PetOwnerCreateWithoutPetsInput, PetOwnerUncheckedCreateWithoutPetsInput>
  }

  export type UserCreateWithoutRegisteredPetsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    executive?: ExecutiveCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerCreateNestedOneWithoutUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRegisteredPetsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    executive?: ExecutiveUncheckedCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeUncheckedCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerUncheckedCreateNestedOneWithoutUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRegisteredPetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRegisteredPetsInput, UserUncheckedCreateWithoutRegisteredPetsInput>
  }

  export type PetBreedCreateWithoutPets_pets_secondary_breed_idTopet_breedsInput = {
    breedName: string
    sizeCategory?: $Enums.SizeCategory | null
    typicalLifespanYears?: number | null
    species: PetSpeciesCreateNestedOneWithoutBreedsInput
    pets_pets_breed_idTopet_breeds?: PetCreateNestedManyWithoutPet_breeds_pets_breed_idTopet_breedsInput
  }

  export type PetBreedUncheckedCreateWithoutPets_pets_secondary_breed_idTopet_breedsInput = {
    id?: number
    breedName: string
    speciesId: number
    sizeCategory?: $Enums.SizeCategory | null
    typicalLifespanYears?: number | null
    pets_pets_breed_idTopet_breeds?: PetUncheckedCreateNestedManyWithoutPet_breeds_pets_breed_idTopet_breedsInput
  }

  export type PetBreedCreateOrConnectWithoutPets_pets_secondary_breed_idTopet_breedsInput = {
    where: PetBreedWhereUniqueInput
    create: XOR<PetBreedCreateWithoutPets_pets_secondary_breed_idTopet_breedsInput, PetBreedUncheckedCreateWithoutPets_pets_secondary_breed_idTopet_breedsInput>
  }

  export type PetSpeciesCreateWithoutPetsInput = {
    speciesName: string
    category: string
    breeds?: PetBreedCreateNestedManyWithoutSpeciesInput
  }

  export type PetSpeciesUncheckedCreateWithoutPetsInput = {
    id?: number
    speciesName: string
    category: string
    breeds?: PetBreedUncheckedCreateNestedManyWithoutSpeciesInput
  }

  export type PetSpeciesCreateOrConnectWithoutPetsInput = {
    where: PetSpeciesWhereUniqueInput
    create: XOR<PetSpeciesCreateWithoutPetsInput, PetSpeciesUncheckedCreateWithoutPetsInput>
  }

  export type QRCodeCreateWithoutPetInput = {
    id?: string
    qrCodeString: string
    qrCodeHash: string
    qrImageUrl?: string | null
    status?: $Enums.QRStatus
    assignedAt?: Date | string | null
    activatedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    paymentEvents?: PaymentEventCreateNestedManyWithoutQrCodeInput
    pool?: QRCodePoolCreateNestedOneWithoutQrCodesInput
    scanEvents?: QRScanEventCreateNestedManyWithoutQrCodeInput
  }

  export type QRCodeUncheckedCreateWithoutPetInput = {
    id?: string
    poolId?: string | null
    qrCodeString: string
    qrCodeHash: string
    qrImageUrl?: string | null
    status?: $Enums.QRStatus
    assignedAt?: Date | string | null
    activatedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutQrCodeInput
    scanEvents?: QRScanEventUncheckedCreateNestedManyWithoutQrCodeInput
  }

  export type QRCodeCreateOrConnectWithoutPetInput = {
    where: QRCodeWhereUniqueInput
    create: XOR<QRCodeCreateWithoutPetInput, QRCodeUncheckedCreateWithoutPetInput>
  }

  export type QRCodeCreateManyPetInputEnvelope = {
    data: QRCodeCreateManyPetInput | QRCodeCreateManyPetInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutPetInput = {
    id?: string
    ticketNumber: string
    subject: string
    description: string
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    messages?: SupportMessageCreateNestedManyWithoutTicketInput
    assignedToUser?: UserCreateNestedOneWithoutAssignedTicketsInput
    user?: UserCreateNestedOneWithoutSupportTicketsInput
  }

  export type SupportTicketUncheckedCreateWithoutPetInput = {
    id?: string
    ticketNumber: string
    userId?: string | null
    subject: string
    description: string
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    assignedTo?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    messages?: SupportMessageUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketCreateOrConnectWithoutPetInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutPetInput, SupportTicketUncheckedCreateWithoutPetInput>
  }

  export type SupportTicketCreateManyPetInputEnvelope = {
    data: SupportTicketCreateManyPetInput | SupportTicketCreateManyPetInput[]
    skipDuplicates?: boolean
  }

  export type VaccinationRecordCreateWithoutPetInput = {
    id?: string
    administeredDate: Date | string
    expirationDate?: Date | string | null
    batchNumber?: string | null
    veterinarianName?: string | null
    clinicName?: string | null
    notes?: string | null
    certificateUrl?: string | null
    createdAt?: Date | string
    vaccineType: VaccineTypeCreateNestedOneWithoutVaccinationRecordsInput
  }

  export type VaccinationRecordUncheckedCreateWithoutPetInput = {
    id?: string
    vaccineTypeId: number
    administeredDate: Date | string
    expirationDate?: Date | string | null
    batchNumber?: string | null
    veterinarianName?: string | null
    clinicName?: string | null
    notes?: string | null
    certificateUrl?: string | null
    createdAt?: Date | string
  }

  export type VaccinationRecordCreateOrConnectWithoutPetInput = {
    where: VaccinationRecordWhereUniqueInput
    create: XOR<VaccinationRecordCreateWithoutPetInput, VaccinationRecordUncheckedCreateWithoutPetInput>
  }

  export type VaccinationRecordCreateManyPetInputEnvelope = {
    data: VaccinationRecordCreateManyPetInput | VaccinationRecordCreateManyPetInput[]
    skipDuplicates?: boolean
  }

  export type MedicalRecordUpsertWithWhereUniqueWithoutPetInput = {
    where: MedicalRecordWhereUniqueInput
    update: XOR<MedicalRecordUpdateWithoutPetInput, MedicalRecordUncheckedUpdateWithoutPetInput>
    create: XOR<MedicalRecordCreateWithoutPetInput, MedicalRecordUncheckedCreateWithoutPetInput>
  }

  export type MedicalRecordUpdateWithWhereUniqueWithoutPetInput = {
    where: MedicalRecordWhereUniqueInput
    data: XOR<MedicalRecordUpdateWithoutPetInput, MedicalRecordUncheckedUpdateWithoutPetInput>
  }

  export type MedicalRecordUpdateManyWithWhereWithoutPetInput = {
    where: MedicalRecordScalarWhereInput
    data: XOR<MedicalRecordUpdateManyMutationInput, MedicalRecordUncheckedUpdateManyWithoutPetInput>
  }

  export type MedicalRecordScalarWhereInput = {
    AND?: MedicalRecordScalarWhereInput | MedicalRecordScalarWhereInput[]
    OR?: MedicalRecordScalarWhereInput[]
    NOT?: MedicalRecordScalarWhereInput | MedicalRecordScalarWhereInput[]
    id?: UuidFilter<"MedicalRecord"> | string
    petId?: UuidFilter<"MedicalRecord"> | string
    visitDate?: DateTimeFilter<"MedicalRecord"> | Date | string
    veterinarianName?: StringNullableFilter<"MedicalRecord"> | string | null
    clinicName?: StringNullableFilter<"MedicalRecord"> | string | null
    diagnosis?: StringNullableFilter<"MedicalRecord"> | string | null
    treatment?: StringNullableFilter<"MedicalRecord"> | string | null
    medications?: JsonNullableFilter<"MedicalRecord">
    followUpRequired?: BoolFilter<"MedicalRecord"> | boolean
    followUpDate?: DateTimeNullableFilter<"MedicalRecord"> | Date | string | null
    cost?: DecimalNullableFilter<"MedicalRecord"> | Decimal | DecimalJsLike | number | string | null
    documentUrls?: StringNullableListFilter<"MedicalRecord">
    createdAt?: DateTimeFilter<"MedicalRecord"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutPetInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutPetInput, NotificationUncheckedUpdateWithoutPetInput>
    create: XOR<NotificationCreateWithoutPetInput, NotificationUncheckedCreateWithoutPetInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutPetInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutPetInput, NotificationUncheckedUpdateWithoutPetInput>
  }

  export type NotificationUpdateManyWithWhereWithoutPetInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutPetInput>
  }

  export type PaymentEventUpsertWithWhereUniqueWithoutPetInput = {
    where: PaymentEventWhereUniqueInput
    update: XOR<PaymentEventUpdateWithoutPetInput, PaymentEventUncheckedUpdateWithoutPetInput>
    create: XOR<PaymentEventCreateWithoutPetInput, PaymentEventUncheckedCreateWithoutPetInput>
  }

  export type PaymentEventUpdateWithWhereUniqueWithoutPetInput = {
    where: PaymentEventWhereUniqueInput
    data: XOR<PaymentEventUpdateWithoutPetInput, PaymentEventUncheckedUpdateWithoutPetInput>
  }

  export type PaymentEventUpdateManyWithWhereWithoutPetInput = {
    where: PaymentEventScalarWhereInput
    data: XOR<PaymentEventUpdateManyMutationInput, PaymentEventUncheckedUpdateManyWithoutPetInput>
  }

  export type PetLocationEventUpsertWithWhereUniqueWithoutPetInput = {
    where: PetLocationEventWhereUniqueInput
    update: XOR<PetLocationEventUpdateWithoutPetInput, PetLocationEventUncheckedUpdateWithoutPetInput>
    create: XOR<PetLocationEventCreateWithoutPetInput, PetLocationEventUncheckedCreateWithoutPetInput>
  }

  export type PetLocationEventUpdateWithWhereUniqueWithoutPetInput = {
    where: PetLocationEventWhereUniqueInput
    data: XOR<PetLocationEventUpdateWithoutPetInput, PetLocationEventUncheckedUpdateWithoutPetInput>
  }

  export type PetLocationEventUpdateManyWithWhereWithoutPetInput = {
    where: PetLocationEventScalarWhereInput
    data: XOR<PetLocationEventUpdateManyMutationInput, PetLocationEventUncheckedUpdateManyWithoutPetInput>
  }

  export type PetLocationEventScalarWhereInput = {
    AND?: PetLocationEventScalarWhereInput | PetLocationEventScalarWhereInput[]
    OR?: PetLocationEventScalarWhereInput[]
    NOT?: PetLocationEventScalarWhereInput | PetLocationEventScalarWhereInput[]
    id?: UuidFilter<"PetLocationEvent"> | string
    petId?: UuidFilter<"PetLocationEvent"> | string
    qrScanId?: UuidNullableFilter<"PetLocationEvent"> | string | null
    latitude?: DecimalFilter<"PetLocationEvent"> | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFilter<"PetLocationEvent"> | Decimal | DecimalJsLike | number | string
    accuracy?: DecimalNullableFilter<"PetLocationEvent"> | Decimal | DecimalJsLike | number | string | null
    scannerIp?: StringNullableFilter<"PetLocationEvent"> | string | null
    userAgent?: StringNullableFilter<"PetLocationEvent"> | string | null
    deviceType?: EnumDeviceTypeNullableFilter<"PetLocationEvent"> | $Enums.DeviceType | null
    locationName?: StringNullableFilter<"PetLocationEvent"> | string | null
    countryCode?: StringNullableFilter<"PetLocationEvent"> | string | null
    city?: StringNullableFilter<"PetLocationEvent"> | string | null
    state?: StringNullableFilter<"PetLocationEvent"> | string | null
    scannerContactInfo?: JsonNullableFilter<"PetLocationEvent">
    createdAt?: DateTimeFilter<"PetLocationEvent"> | Date | string
  }

  export type QRScanEventUpsertWithWhereUniqueWithoutPetInput = {
    where: QRScanEventWhereUniqueInput
    update: XOR<QRScanEventUpdateWithoutPetInput, QRScanEventUncheckedUpdateWithoutPetInput>
    create: XOR<QRScanEventCreateWithoutPetInput, QRScanEventUncheckedCreateWithoutPetInput>
  }

  export type QRScanEventUpdateWithWhereUniqueWithoutPetInput = {
    where: QRScanEventWhereUniqueInput
    data: XOR<QRScanEventUpdateWithoutPetInput, QRScanEventUncheckedUpdateWithoutPetInput>
  }

  export type QRScanEventUpdateManyWithWhereWithoutPetInput = {
    where: QRScanEventScalarWhereInput
    data: XOR<QRScanEventUpdateManyMutationInput, QRScanEventUncheckedUpdateManyWithoutPetInput>
  }

  export type QRScanEventScalarWhereInput = {
    AND?: QRScanEventScalarWhereInput | QRScanEventScalarWhereInput[]
    OR?: QRScanEventScalarWhereInput[]
    NOT?: QRScanEventScalarWhereInput | QRScanEventScalarWhereInput[]
    id?: UuidFilter<"QRScanEvent"> | string
    qrId?: UuidFilter<"QRScanEvent"> | string
    petId?: UuidNullableFilter<"QRScanEvent"> | string | null
    scanTimestamp?: DateTimeFilter<"QRScanEvent"> | Date | string
    scannerIp?: StringNullableFilter<"QRScanEvent"> | string | null
    userAgent?: StringNullableFilter<"QRScanEvent"> | string | null
    deviceType?: EnumDeviceTypeNullableFilter<"QRScanEvent"> | $Enums.DeviceType | null
    scanLocation?: StringNullableFilter<"QRScanEvent"> | string | null
    locationAccuracy?: DecimalNullableFilter<"QRScanEvent"> | Decimal | DecimalJsLike | number | string | null
    locationName?: StringNullableFilter<"QRScanEvent"> | string | null
    countryCode?: StringNullableFilter<"QRScanEvent"> | string | null
    city?: StringNullableFilter<"QRScanEvent"> | string | null
    scannerContactInfo?: JsonNullableFilter<"QRScanEvent">
    scanResult?: EnumScanResultFilter<"QRScanEvent"> | $Enums.ScanResult
    createdAt?: DateTimeFilter<"QRScanEvent"> | Date | string
  }

  export type PetBreedUpsertWithoutPets_pets_breed_idTopet_breedsInput = {
    update: XOR<PetBreedUpdateWithoutPets_pets_breed_idTopet_breedsInput, PetBreedUncheckedUpdateWithoutPets_pets_breed_idTopet_breedsInput>
    create: XOR<PetBreedCreateWithoutPets_pets_breed_idTopet_breedsInput, PetBreedUncheckedCreateWithoutPets_pets_breed_idTopet_breedsInput>
    where?: PetBreedWhereInput
  }

  export type PetBreedUpdateToOneWithWhereWithoutPets_pets_breed_idTopet_breedsInput = {
    where?: PetBreedWhereInput
    data: XOR<PetBreedUpdateWithoutPets_pets_breed_idTopet_breedsInput, PetBreedUncheckedUpdateWithoutPets_pets_breed_idTopet_breedsInput>
  }

  export type PetBreedUpdateWithoutPets_pets_breed_idTopet_breedsInput = {
    breedName?: StringFieldUpdateOperationsInput | string
    sizeCategory?: NullableEnumSizeCategoryFieldUpdateOperationsInput | $Enums.SizeCategory | null
    typicalLifespanYears?: NullableIntFieldUpdateOperationsInput | number | null
    species?: PetSpeciesUpdateOneRequiredWithoutBreedsNestedInput
    pets_pets_secondary_breed_idTopet_breeds?: PetUpdateManyWithoutPet_breeds_pets_secondary_breed_idTopet_breedsNestedInput
  }

  export type PetBreedUncheckedUpdateWithoutPets_pets_breed_idTopet_breedsInput = {
    id?: IntFieldUpdateOperationsInput | number
    breedName?: StringFieldUpdateOperationsInput | string
    speciesId?: IntFieldUpdateOperationsInput | number
    sizeCategory?: NullableEnumSizeCategoryFieldUpdateOperationsInput | $Enums.SizeCategory | null
    typicalLifespanYears?: NullableIntFieldUpdateOperationsInput | number | null
    pets_pets_secondary_breed_idTopet_breeds?: PetUncheckedUpdateManyWithoutPet_breeds_pets_secondary_breed_idTopet_breedsNestedInput
  }

  export type PetOwnerUpsertWithoutPetsInput = {
    update: XOR<PetOwnerUpdateWithoutPetsInput, PetOwnerUncheckedUpdateWithoutPetsInput>
    create: XOR<PetOwnerCreateWithoutPetsInput, PetOwnerUncheckedCreateWithoutPetsInput>
    where?: PetOwnerWhereInput
  }

  export type PetOwnerUpdateToOneWithWhereWithoutPetsInput = {
    where?: PetOwnerWhereInput
    data: XOR<PetOwnerUpdateWithoutPetsInput, PetOwnerUncheckedUpdateWithoutPetsInput>
  }

  export type PetOwnerUpdateWithoutPetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: StringFieldUpdateOperationsInput | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPetOwnerNestedInput
  }

  export type PetOwnerUncheckedUpdateWithoutPetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: StringFieldUpdateOperationsInput | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutRegisteredPetsInput = {
    update: XOR<UserUpdateWithoutRegisteredPetsInput, UserUncheckedUpdateWithoutRegisteredPetsInput>
    create: XOR<UserCreateWithoutRegisteredPetsInput, UserUncheckedCreateWithoutRegisteredPetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRegisteredPetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRegisteredPetsInput, UserUncheckedUpdateWithoutRegisteredPetsInput>
  }

  export type UserUpdateWithoutRegisteredPetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUpdateOneWithoutUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRegisteredPetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUncheckedUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUncheckedUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUncheckedUpdateOneWithoutUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PetBreedUpsertWithoutPets_pets_secondary_breed_idTopet_breedsInput = {
    update: XOR<PetBreedUpdateWithoutPets_pets_secondary_breed_idTopet_breedsInput, PetBreedUncheckedUpdateWithoutPets_pets_secondary_breed_idTopet_breedsInput>
    create: XOR<PetBreedCreateWithoutPets_pets_secondary_breed_idTopet_breedsInput, PetBreedUncheckedCreateWithoutPets_pets_secondary_breed_idTopet_breedsInput>
    where?: PetBreedWhereInput
  }

  export type PetBreedUpdateToOneWithWhereWithoutPets_pets_secondary_breed_idTopet_breedsInput = {
    where?: PetBreedWhereInput
    data: XOR<PetBreedUpdateWithoutPets_pets_secondary_breed_idTopet_breedsInput, PetBreedUncheckedUpdateWithoutPets_pets_secondary_breed_idTopet_breedsInput>
  }

  export type PetBreedUpdateWithoutPets_pets_secondary_breed_idTopet_breedsInput = {
    breedName?: StringFieldUpdateOperationsInput | string
    sizeCategory?: NullableEnumSizeCategoryFieldUpdateOperationsInput | $Enums.SizeCategory | null
    typicalLifespanYears?: NullableIntFieldUpdateOperationsInput | number | null
    species?: PetSpeciesUpdateOneRequiredWithoutBreedsNestedInput
    pets_pets_breed_idTopet_breeds?: PetUpdateManyWithoutPet_breeds_pets_breed_idTopet_breedsNestedInput
  }

  export type PetBreedUncheckedUpdateWithoutPets_pets_secondary_breed_idTopet_breedsInput = {
    id?: IntFieldUpdateOperationsInput | number
    breedName?: StringFieldUpdateOperationsInput | string
    speciesId?: IntFieldUpdateOperationsInput | number
    sizeCategory?: NullableEnumSizeCategoryFieldUpdateOperationsInput | $Enums.SizeCategory | null
    typicalLifespanYears?: NullableIntFieldUpdateOperationsInput | number | null
    pets_pets_breed_idTopet_breeds?: PetUncheckedUpdateManyWithoutPet_breeds_pets_breed_idTopet_breedsNestedInput
  }

  export type PetSpeciesUpsertWithoutPetsInput = {
    update: XOR<PetSpeciesUpdateWithoutPetsInput, PetSpeciesUncheckedUpdateWithoutPetsInput>
    create: XOR<PetSpeciesCreateWithoutPetsInput, PetSpeciesUncheckedCreateWithoutPetsInput>
    where?: PetSpeciesWhereInput
  }

  export type PetSpeciesUpdateToOneWithWhereWithoutPetsInput = {
    where?: PetSpeciesWhereInput
    data: XOR<PetSpeciesUpdateWithoutPetsInput, PetSpeciesUncheckedUpdateWithoutPetsInput>
  }

  export type PetSpeciesUpdateWithoutPetsInput = {
    speciesName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    breeds?: PetBreedUpdateManyWithoutSpeciesNestedInput
  }

  export type PetSpeciesUncheckedUpdateWithoutPetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    speciesName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    breeds?: PetBreedUncheckedUpdateManyWithoutSpeciesNestedInput
  }

  export type QRCodeUpsertWithWhereUniqueWithoutPetInput = {
    where: QRCodeWhereUniqueInput
    update: XOR<QRCodeUpdateWithoutPetInput, QRCodeUncheckedUpdateWithoutPetInput>
    create: XOR<QRCodeCreateWithoutPetInput, QRCodeUncheckedCreateWithoutPetInput>
  }

  export type QRCodeUpdateWithWhereUniqueWithoutPetInput = {
    where: QRCodeWhereUniqueInput
    data: XOR<QRCodeUpdateWithoutPetInput, QRCodeUncheckedUpdateWithoutPetInput>
  }

  export type QRCodeUpdateManyWithWhereWithoutPetInput = {
    where: QRCodeScalarWhereInput
    data: XOR<QRCodeUpdateManyMutationInput, QRCodeUncheckedUpdateManyWithoutPetInput>
  }

  export type QRCodeScalarWhereInput = {
    AND?: QRCodeScalarWhereInput | QRCodeScalarWhereInput[]
    OR?: QRCodeScalarWhereInput[]
    NOT?: QRCodeScalarWhereInput | QRCodeScalarWhereInput[]
    id?: UuidFilter<"QRCode"> | string
    poolId?: UuidNullableFilter<"QRCode"> | string | null
    qrCodeString?: StringFilter<"QRCode"> | string
    qrCodeHash?: StringFilter<"QRCode"> | string
    qrImageUrl?: StringNullableFilter<"QRCode"> | string | null
    status?: EnumQRStatusFilter<"QRCode"> | $Enums.QRStatus
    assignedToPet?: UuidNullableFilter<"QRCode"> | string | null
    assignedAt?: DateTimeNullableFilter<"QRCode"> | Date | string | null
    activatedAt?: DateTimeNullableFilter<"QRCode"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"QRCode"> | Date | string | null
    createdAt?: DateTimeFilter<"QRCode"> | Date | string
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutPetInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutPetInput, SupportTicketUncheckedUpdateWithoutPetInput>
    create: XOR<SupportTicketCreateWithoutPetInput, SupportTicketUncheckedCreateWithoutPetInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutPetInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutPetInput, SupportTicketUncheckedUpdateWithoutPetInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutPetInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutPetInput>
  }

  export type VaccinationRecordUpsertWithWhereUniqueWithoutPetInput = {
    where: VaccinationRecordWhereUniqueInput
    update: XOR<VaccinationRecordUpdateWithoutPetInput, VaccinationRecordUncheckedUpdateWithoutPetInput>
    create: XOR<VaccinationRecordCreateWithoutPetInput, VaccinationRecordUncheckedCreateWithoutPetInput>
  }

  export type VaccinationRecordUpdateWithWhereUniqueWithoutPetInput = {
    where: VaccinationRecordWhereUniqueInput
    data: XOR<VaccinationRecordUpdateWithoutPetInput, VaccinationRecordUncheckedUpdateWithoutPetInput>
  }

  export type VaccinationRecordUpdateManyWithWhereWithoutPetInput = {
    where: VaccinationRecordScalarWhereInput
    data: XOR<VaccinationRecordUpdateManyMutationInput, VaccinationRecordUncheckedUpdateManyWithoutPetInput>
  }

  export type VaccinationRecordScalarWhereInput = {
    AND?: VaccinationRecordScalarWhereInput | VaccinationRecordScalarWhereInput[]
    OR?: VaccinationRecordScalarWhereInput[]
    NOT?: VaccinationRecordScalarWhereInput | VaccinationRecordScalarWhereInput[]
    id?: UuidFilter<"VaccinationRecord"> | string
    petId?: UuidFilter<"VaccinationRecord"> | string
    vaccineTypeId?: IntFilter<"VaccinationRecord"> | number
    administeredDate?: DateTimeFilter<"VaccinationRecord"> | Date | string
    expirationDate?: DateTimeNullableFilter<"VaccinationRecord"> | Date | string | null
    batchNumber?: StringNullableFilter<"VaccinationRecord"> | string | null
    veterinarianName?: StringNullableFilter<"VaccinationRecord"> | string | null
    clinicName?: StringNullableFilter<"VaccinationRecord"> | string | null
    notes?: StringNullableFilter<"VaccinationRecord"> | string | null
    certificateUrl?: StringNullableFilter<"VaccinationRecord"> | string | null
    createdAt?: DateTimeFilter<"VaccinationRecord"> | Date | string
  }

  export type VaccinationRecordCreateWithoutVaccineTypeInput = {
    id?: string
    administeredDate: Date | string
    expirationDate?: Date | string | null
    batchNumber?: string | null
    veterinarianName?: string | null
    clinicName?: string | null
    notes?: string | null
    certificateUrl?: string | null
    createdAt?: Date | string
    pet: PetCreateNestedOneWithoutVaccinationRecordsInput
  }

  export type VaccinationRecordUncheckedCreateWithoutVaccineTypeInput = {
    id?: string
    petId: string
    administeredDate: Date | string
    expirationDate?: Date | string | null
    batchNumber?: string | null
    veterinarianName?: string | null
    clinicName?: string | null
    notes?: string | null
    certificateUrl?: string | null
    createdAt?: Date | string
  }

  export type VaccinationRecordCreateOrConnectWithoutVaccineTypeInput = {
    where: VaccinationRecordWhereUniqueInput
    create: XOR<VaccinationRecordCreateWithoutVaccineTypeInput, VaccinationRecordUncheckedCreateWithoutVaccineTypeInput>
  }

  export type VaccinationRecordCreateManyVaccineTypeInputEnvelope = {
    data: VaccinationRecordCreateManyVaccineTypeInput | VaccinationRecordCreateManyVaccineTypeInput[]
    skipDuplicates?: boolean
  }

  export type VaccinationRecordUpsertWithWhereUniqueWithoutVaccineTypeInput = {
    where: VaccinationRecordWhereUniqueInput
    update: XOR<VaccinationRecordUpdateWithoutVaccineTypeInput, VaccinationRecordUncheckedUpdateWithoutVaccineTypeInput>
    create: XOR<VaccinationRecordCreateWithoutVaccineTypeInput, VaccinationRecordUncheckedCreateWithoutVaccineTypeInput>
  }

  export type VaccinationRecordUpdateWithWhereUniqueWithoutVaccineTypeInput = {
    where: VaccinationRecordWhereUniqueInput
    data: XOR<VaccinationRecordUpdateWithoutVaccineTypeInput, VaccinationRecordUncheckedUpdateWithoutVaccineTypeInput>
  }

  export type VaccinationRecordUpdateManyWithWhereWithoutVaccineTypeInput = {
    where: VaccinationRecordScalarWhereInput
    data: XOR<VaccinationRecordUpdateManyMutationInput, VaccinationRecordUncheckedUpdateManyWithoutVaccineTypeInput>
  }

  export type PetCreateWithoutVaccinationRecordsInput = {
    id?: string
    name: string
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPetInput
    notifications?: NotificationCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventCreateNestedManyWithoutPetInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_breed_idTopet_breedsInput
    owner: PetOwnerCreateNestedOneWithoutPetsInput
    registeredByUser?: UserCreateNestedOneWithoutRegisteredPetsInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_secondary_breed_idTopet_breedsInput
    species?: PetSpeciesCreateNestedOneWithoutPetsInput
    qrCodes?: QRCodeCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketCreateNestedManyWithoutPetInput
  }

  export type PetUncheckedCreateWithoutVaccinationRecordsInput = {
    id?: string
    ownerId: string
    registeredBy?: string | null
    name: string
    speciesId?: number | null
    breed_id?: number | null
    secondary_breed_id?: number | null
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPetInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventUncheckedCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventUncheckedCreateNestedManyWithoutPetInput
    qrCodes?: QRCodeUncheckedCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetCreateOrConnectWithoutVaccinationRecordsInput = {
    where: PetWhereUniqueInput
    create: XOR<PetCreateWithoutVaccinationRecordsInput, PetUncheckedCreateWithoutVaccinationRecordsInput>
  }

  export type VaccineTypeCreateWithoutVaccinationRecordsInput = {
    vaccineName: string
    speciesApplicability?: VaccineTypeCreatespeciesApplicabilityInput | number[]
    durationMonths?: number | null
    isRequiredByLaw?: boolean
  }

  export type VaccineTypeUncheckedCreateWithoutVaccinationRecordsInput = {
    id?: number
    vaccineName: string
    speciesApplicability?: VaccineTypeCreatespeciesApplicabilityInput | number[]
    durationMonths?: number | null
    isRequiredByLaw?: boolean
  }

  export type VaccineTypeCreateOrConnectWithoutVaccinationRecordsInput = {
    where: VaccineTypeWhereUniqueInput
    create: XOR<VaccineTypeCreateWithoutVaccinationRecordsInput, VaccineTypeUncheckedCreateWithoutVaccinationRecordsInput>
  }

  export type PetUpsertWithoutVaccinationRecordsInput = {
    update: XOR<PetUpdateWithoutVaccinationRecordsInput, PetUncheckedUpdateWithoutVaccinationRecordsInput>
    create: XOR<PetCreateWithoutVaccinationRecordsInput, PetUncheckedCreateWithoutVaccinationRecordsInput>
    where?: PetWhereInput
  }

  export type PetUpdateToOneWithWhereWithoutVaccinationRecordsInput = {
    where?: PetWhereInput
    data: XOR<PetUpdateWithoutVaccinationRecordsInput, PetUncheckedUpdateWithoutVaccinationRecordsInput>
  }

  export type PetUpdateWithoutVaccinationRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUpdateManyWithoutPetNestedInput
    notifications?: NotificationUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUpdateManyWithoutPetNestedInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_breed_idTopet_breedsNestedInput
    owner?: PetOwnerUpdateOneRequiredWithoutPetsNestedInput
    registeredByUser?: UserUpdateOneWithoutRegisteredPetsNestedInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_secondary_breed_idTopet_breedsNestedInput
    species?: PetSpeciesUpdateOneWithoutPetsNestedInput
    qrCodes?: QRCodeUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateWithoutVaccinationRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    registeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableIntFieldUpdateOperationsInput | number | null
    breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPetNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUncheckedUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUncheckedUpdateManyWithoutPetNestedInput
    qrCodes?: QRCodeUncheckedUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutPetNestedInput
  }

  export type VaccineTypeUpsertWithoutVaccinationRecordsInput = {
    update: XOR<VaccineTypeUpdateWithoutVaccinationRecordsInput, VaccineTypeUncheckedUpdateWithoutVaccinationRecordsInput>
    create: XOR<VaccineTypeCreateWithoutVaccinationRecordsInput, VaccineTypeUncheckedCreateWithoutVaccinationRecordsInput>
    where?: VaccineTypeWhereInput
  }

  export type VaccineTypeUpdateToOneWithWhereWithoutVaccinationRecordsInput = {
    where?: VaccineTypeWhereInput
    data: XOR<VaccineTypeUpdateWithoutVaccinationRecordsInput, VaccineTypeUncheckedUpdateWithoutVaccinationRecordsInput>
  }

  export type VaccineTypeUpdateWithoutVaccinationRecordsInput = {
    vaccineName?: StringFieldUpdateOperationsInput | string
    speciesApplicability?: VaccineTypeUpdatespeciesApplicabilityInput | number[]
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    isRequiredByLaw?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VaccineTypeUncheckedUpdateWithoutVaccinationRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    vaccineName?: StringFieldUpdateOperationsInput | string
    speciesApplicability?: VaccineTypeUpdatespeciesApplicabilityInput | number[]
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    isRequiredByLaw?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PetCreateWithoutMedicalRecordsInput = {
    id?: string
    name: string
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventCreateNestedManyWithoutPetInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_breed_idTopet_breedsInput
    owner: PetOwnerCreateNestedOneWithoutPetsInput
    registeredByUser?: UserCreateNestedOneWithoutRegisteredPetsInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_secondary_breed_idTopet_breedsInput
    species?: PetSpeciesCreateNestedOneWithoutPetsInput
    qrCodes?: QRCodeCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordCreateNestedManyWithoutPetInput
  }

  export type PetUncheckedCreateWithoutMedicalRecordsInput = {
    id?: string
    ownerId: string
    registeredBy?: string | null
    name: string
    speciesId?: number | null
    breed_id?: number | null
    secondary_breed_id?: number | null
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventUncheckedCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventUncheckedCreateNestedManyWithoutPetInput
    qrCodes?: QRCodeUncheckedCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetCreateOrConnectWithoutMedicalRecordsInput = {
    where: PetWhereUniqueInput
    create: XOR<PetCreateWithoutMedicalRecordsInput, PetUncheckedCreateWithoutMedicalRecordsInput>
  }

  export type PetUpsertWithoutMedicalRecordsInput = {
    update: XOR<PetUpdateWithoutMedicalRecordsInput, PetUncheckedUpdateWithoutMedicalRecordsInput>
    create: XOR<PetCreateWithoutMedicalRecordsInput, PetUncheckedCreateWithoutMedicalRecordsInput>
    where?: PetWhereInput
  }

  export type PetUpdateToOneWithWhereWithoutMedicalRecordsInput = {
    where?: PetWhereInput
    data: XOR<PetUpdateWithoutMedicalRecordsInput, PetUncheckedUpdateWithoutMedicalRecordsInput>
  }

  export type PetUpdateWithoutMedicalRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUpdateManyWithoutPetNestedInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_breed_idTopet_breedsNestedInput
    owner?: PetOwnerUpdateOneRequiredWithoutPetsNestedInput
    registeredByUser?: UserUpdateOneWithoutRegisteredPetsNestedInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_secondary_breed_idTopet_breedsNestedInput
    species?: PetSpeciesUpdateOneWithoutPetsNestedInput
    qrCodes?: QRCodeUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateWithoutMedicalRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    registeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableIntFieldUpdateOperationsInput | number | null
    breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUncheckedUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUncheckedUpdateManyWithoutPetNestedInput
    qrCodes?: QRCodeUncheckedUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUncheckedUpdateManyWithoutPetNestedInput
  }

  export type QRCodeCreateWithoutPoolInput = {
    id?: string
    qrCodeString: string
    qrCodeHash: string
    qrImageUrl?: string | null
    status?: $Enums.QRStatus
    assignedAt?: Date | string | null
    activatedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    paymentEvents?: PaymentEventCreateNestedManyWithoutQrCodeInput
    pet?: PetCreateNestedOneWithoutQrCodesInput
    scanEvents?: QRScanEventCreateNestedManyWithoutQrCodeInput
  }

  export type QRCodeUncheckedCreateWithoutPoolInput = {
    id?: string
    qrCodeString: string
    qrCodeHash: string
    qrImageUrl?: string | null
    status?: $Enums.QRStatus
    assignedToPet?: string | null
    assignedAt?: Date | string | null
    activatedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutQrCodeInput
    scanEvents?: QRScanEventUncheckedCreateNestedManyWithoutQrCodeInput
  }

  export type QRCodeCreateOrConnectWithoutPoolInput = {
    where: QRCodeWhereUniqueInput
    create: XOR<QRCodeCreateWithoutPoolInput, QRCodeUncheckedCreateWithoutPoolInput>
  }

  export type QRCodeCreateManyPoolInputEnvelope = {
    data: QRCodeCreateManyPoolInput | QRCodeCreateManyPoolInput[]
    skipDuplicates?: boolean
  }

  export type QRCodeUpsertWithWhereUniqueWithoutPoolInput = {
    where: QRCodeWhereUniqueInput
    update: XOR<QRCodeUpdateWithoutPoolInput, QRCodeUncheckedUpdateWithoutPoolInput>
    create: XOR<QRCodeCreateWithoutPoolInput, QRCodeUncheckedCreateWithoutPoolInput>
  }

  export type QRCodeUpdateWithWhereUniqueWithoutPoolInput = {
    where: QRCodeWhereUniqueInput
    data: XOR<QRCodeUpdateWithoutPoolInput, QRCodeUncheckedUpdateWithoutPoolInput>
  }

  export type QRCodeUpdateManyWithWhereWithoutPoolInput = {
    where: QRCodeScalarWhereInput
    data: XOR<QRCodeUpdateManyMutationInput, QRCodeUncheckedUpdateManyWithoutPoolInput>
  }

  export type PaymentEventCreateWithoutQrCodeInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentPurpose: $Enums.PaymentPurpose
    status?: $Enums.PaymentStatus
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    razorpaySignature?: string | null
    paymentMethod?: string | null
    failureReason?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    pet?: PetCreateNestedOneWithoutPaymentEventsInput
    user?: UserCreateNestedOneWithoutPaymentEventsInput
    refunds?: RefundCreateNestedManyWithoutPaymentEventInput
  }

  export type PaymentEventUncheckedCreateWithoutQrCodeInput = {
    id?: string
    userId?: string | null
    petId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentPurpose: $Enums.PaymentPurpose
    status?: $Enums.PaymentStatus
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    razorpaySignature?: string | null
    paymentMethod?: string | null
    failureReason?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    refunds?: RefundUncheckedCreateNestedManyWithoutPaymentEventInput
  }

  export type PaymentEventCreateOrConnectWithoutQrCodeInput = {
    where: PaymentEventWhereUniqueInput
    create: XOR<PaymentEventCreateWithoutQrCodeInput, PaymentEventUncheckedCreateWithoutQrCodeInput>
  }

  export type PaymentEventCreateManyQrCodeInputEnvelope = {
    data: PaymentEventCreateManyQrCodeInput | PaymentEventCreateManyQrCodeInput[]
    skipDuplicates?: boolean
  }

  export type PetCreateWithoutQrCodesInput = {
    id?: string
    name: string
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPetInput
    notifications?: NotificationCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventCreateNestedManyWithoutPetInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_breed_idTopet_breedsInput
    owner: PetOwnerCreateNestedOneWithoutPetsInput
    registeredByUser?: UserCreateNestedOneWithoutRegisteredPetsInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_secondary_breed_idTopet_breedsInput
    species?: PetSpeciesCreateNestedOneWithoutPetsInput
    supportTickets?: SupportTicketCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordCreateNestedManyWithoutPetInput
  }

  export type PetUncheckedCreateWithoutQrCodesInput = {
    id?: string
    ownerId: string
    registeredBy?: string | null
    name: string
    speciesId?: number | null
    breed_id?: number | null
    secondary_breed_id?: number | null
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPetInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventUncheckedCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventUncheckedCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetCreateOrConnectWithoutQrCodesInput = {
    where: PetWhereUniqueInput
    create: XOR<PetCreateWithoutQrCodesInput, PetUncheckedCreateWithoutQrCodesInput>
  }

  export type QRCodePoolCreateWithoutQrCodesInput = {
    id?: string
    poolName: string
    totalCapacity: number
    usedCount?: number
    createdAt?: Date | string
    status?: $Enums.PoolStatus
  }

  export type QRCodePoolUncheckedCreateWithoutQrCodesInput = {
    id?: string
    poolName: string
    totalCapacity: number
    usedCount?: number
    createdAt?: Date | string
    status?: $Enums.PoolStatus
  }

  export type QRCodePoolCreateOrConnectWithoutQrCodesInput = {
    where: QRCodePoolWhereUniqueInput
    create: XOR<QRCodePoolCreateWithoutQrCodesInput, QRCodePoolUncheckedCreateWithoutQrCodesInput>
  }

  export type QRScanEventCreateWithoutQrCodeInput = {
    id?: string
    scanTimestamp?: Date | string
    scannerIp?: string | null
    userAgent?: string | null
    deviceType?: $Enums.DeviceType | null
    scanLocation?: string | null
    locationAccuracy?: Decimal | DecimalJsLike | number | string | null
    locationName?: string | null
    countryCode?: string | null
    city?: string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    scanResult: $Enums.ScanResult
    createdAt?: Date | string
    pet?: PetCreateNestedOneWithoutQrScanEventsInput
    locationEvents?: PetLocationEventCreateNestedManyWithoutQrScanEventInput
  }

  export type QRScanEventUncheckedCreateWithoutQrCodeInput = {
    id?: string
    petId?: string | null
    scanTimestamp?: Date | string
    scannerIp?: string | null
    userAgent?: string | null
    deviceType?: $Enums.DeviceType | null
    scanLocation?: string | null
    locationAccuracy?: Decimal | DecimalJsLike | number | string | null
    locationName?: string | null
    countryCode?: string | null
    city?: string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    scanResult: $Enums.ScanResult
    createdAt?: Date | string
    locationEvents?: PetLocationEventUncheckedCreateNestedManyWithoutQrScanEventInput
  }

  export type QRScanEventCreateOrConnectWithoutQrCodeInput = {
    where: QRScanEventWhereUniqueInput
    create: XOR<QRScanEventCreateWithoutQrCodeInput, QRScanEventUncheckedCreateWithoutQrCodeInput>
  }

  export type QRScanEventCreateManyQrCodeInputEnvelope = {
    data: QRScanEventCreateManyQrCodeInput | QRScanEventCreateManyQrCodeInput[]
    skipDuplicates?: boolean
  }

  export type PaymentEventUpsertWithWhereUniqueWithoutQrCodeInput = {
    where: PaymentEventWhereUniqueInput
    update: XOR<PaymentEventUpdateWithoutQrCodeInput, PaymentEventUncheckedUpdateWithoutQrCodeInput>
    create: XOR<PaymentEventCreateWithoutQrCodeInput, PaymentEventUncheckedCreateWithoutQrCodeInput>
  }

  export type PaymentEventUpdateWithWhereUniqueWithoutQrCodeInput = {
    where: PaymentEventWhereUniqueInput
    data: XOR<PaymentEventUpdateWithoutQrCodeInput, PaymentEventUncheckedUpdateWithoutQrCodeInput>
  }

  export type PaymentEventUpdateManyWithWhereWithoutQrCodeInput = {
    where: PaymentEventScalarWhereInput
    data: XOR<PaymentEventUpdateManyMutationInput, PaymentEventUncheckedUpdateManyWithoutQrCodeInput>
  }

  export type PetUpsertWithoutQrCodesInput = {
    update: XOR<PetUpdateWithoutQrCodesInput, PetUncheckedUpdateWithoutQrCodesInput>
    create: XOR<PetCreateWithoutQrCodesInput, PetUncheckedCreateWithoutQrCodesInput>
    where?: PetWhereInput
  }

  export type PetUpdateToOneWithWhereWithoutQrCodesInput = {
    where?: PetWhereInput
    data: XOR<PetUpdateWithoutQrCodesInput, PetUncheckedUpdateWithoutQrCodesInput>
  }

  export type PetUpdateWithoutQrCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUpdateManyWithoutPetNestedInput
    notifications?: NotificationUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUpdateManyWithoutPetNestedInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_breed_idTopet_breedsNestedInput
    owner?: PetOwnerUpdateOneRequiredWithoutPetsNestedInput
    registeredByUser?: UserUpdateOneWithoutRegisteredPetsNestedInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_secondary_breed_idTopet_breedsNestedInput
    species?: PetSpeciesUpdateOneWithoutPetsNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateWithoutQrCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    registeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableIntFieldUpdateOperationsInput | number | null
    breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPetNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUncheckedUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUncheckedUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUncheckedUpdateManyWithoutPetNestedInput
  }

  export type QRCodePoolUpsertWithoutQrCodesInput = {
    update: XOR<QRCodePoolUpdateWithoutQrCodesInput, QRCodePoolUncheckedUpdateWithoutQrCodesInput>
    create: XOR<QRCodePoolCreateWithoutQrCodesInput, QRCodePoolUncheckedCreateWithoutQrCodesInput>
    where?: QRCodePoolWhereInput
  }

  export type QRCodePoolUpdateToOneWithWhereWithoutQrCodesInput = {
    where?: QRCodePoolWhereInput
    data: XOR<QRCodePoolUpdateWithoutQrCodesInput, QRCodePoolUncheckedUpdateWithoutQrCodesInput>
  }

  export type QRCodePoolUpdateWithoutQrCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    poolName?: StringFieldUpdateOperationsInput | string
    totalCapacity?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPoolStatusFieldUpdateOperationsInput | $Enums.PoolStatus
  }

  export type QRCodePoolUncheckedUpdateWithoutQrCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    poolName?: StringFieldUpdateOperationsInput | string
    totalCapacity?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPoolStatusFieldUpdateOperationsInput | $Enums.PoolStatus
  }

  export type QRScanEventUpsertWithWhereUniqueWithoutQrCodeInput = {
    where: QRScanEventWhereUniqueInput
    update: XOR<QRScanEventUpdateWithoutQrCodeInput, QRScanEventUncheckedUpdateWithoutQrCodeInput>
    create: XOR<QRScanEventCreateWithoutQrCodeInput, QRScanEventUncheckedCreateWithoutQrCodeInput>
  }

  export type QRScanEventUpdateWithWhereUniqueWithoutQrCodeInput = {
    where: QRScanEventWhereUniqueInput
    data: XOR<QRScanEventUpdateWithoutQrCodeInput, QRScanEventUncheckedUpdateWithoutQrCodeInput>
  }

  export type QRScanEventUpdateManyWithWhereWithoutQrCodeInput = {
    where: QRScanEventScalarWhereInput
    data: XOR<QRScanEventUpdateManyMutationInput, QRScanEventUncheckedUpdateManyWithoutQrCodeInput>
  }

  export type QRCodeCreateWithoutScanEventsInput = {
    id?: string
    qrCodeString: string
    qrCodeHash: string
    qrImageUrl?: string | null
    status?: $Enums.QRStatus
    assignedAt?: Date | string | null
    activatedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    paymentEvents?: PaymentEventCreateNestedManyWithoutQrCodeInput
    pet?: PetCreateNestedOneWithoutQrCodesInput
    pool?: QRCodePoolCreateNestedOneWithoutQrCodesInput
  }

  export type QRCodeUncheckedCreateWithoutScanEventsInput = {
    id?: string
    poolId?: string | null
    qrCodeString: string
    qrCodeHash: string
    qrImageUrl?: string | null
    status?: $Enums.QRStatus
    assignedToPet?: string | null
    assignedAt?: Date | string | null
    activatedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutQrCodeInput
  }

  export type QRCodeCreateOrConnectWithoutScanEventsInput = {
    where: QRCodeWhereUniqueInput
    create: XOR<QRCodeCreateWithoutScanEventsInput, QRCodeUncheckedCreateWithoutScanEventsInput>
  }

  export type PetCreateWithoutQrScanEventsInput = {
    id?: string
    name: string
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPetInput
    notifications?: NotificationCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventCreateNestedManyWithoutPetInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_breed_idTopet_breedsInput
    owner: PetOwnerCreateNestedOneWithoutPetsInput
    registeredByUser?: UserCreateNestedOneWithoutRegisteredPetsInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_secondary_breed_idTopet_breedsInput
    species?: PetSpeciesCreateNestedOneWithoutPetsInput
    qrCodes?: QRCodeCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordCreateNestedManyWithoutPetInput
  }

  export type PetUncheckedCreateWithoutQrScanEventsInput = {
    id?: string
    ownerId: string
    registeredBy?: string | null
    name: string
    speciesId?: number | null
    breed_id?: number | null
    secondary_breed_id?: number | null
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPetInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventUncheckedCreateNestedManyWithoutPetInput
    qrCodes?: QRCodeUncheckedCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetCreateOrConnectWithoutQrScanEventsInput = {
    where: PetWhereUniqueInput
    create: XOR<PetCreateWithoutQrScanEventsInput, PetUncheckedCreateWithoutQrScanEventsInput>
  }

  export type PetLocationEventCreateWithoutQrScanEventInput = {
    id?: string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    accuracy?: Decimal | DecimalJsLike | number | string | null
    scannerIp?: string | null
    userAgent?: string | null
    deviceType?: $Enums.DeviceType | null
    locationName?: string | null
    countryCode?: string | null
    city?: string | null
    state?: string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    pet: PetCreateNestedOneWithoutLocationEventsInput
  }

  export type PetLocationEventUncheckedCreateWithoutQrScanEventInput = {
    id?: string
    petId: string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    accuracy?: Decimal | DecimalJsLike | number | string | null
    scannerIp?: string | null
    userAgent?: string | null
    deviceType?: $Enums.DeviceType | null
    locationName?: string | null
    countryCode?: string | null
    city?: string | null
    state?: string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PetLocationEventCreateOrConnectWithoutQrScanEventInput = {
    where: PetLocationEventWhereUniqueInput
    create: XOR<PetLocationEventCreateWithoutQrScanEventInput, PetLocationEventUncheckedCreateWithoutQrScanEventInput>
  }

  export type PetLocationEventCreateManyQrScanEventInputEnvelope = {
    data: PetLocationEventCreateManyQrScanEventInput | PetLocationEventCreateManyQrScanEventInput[]
    skipDuplicates?: boolean
  }

  export type QRCodeUpsertWithoutScanEventsInput = {
    update: XOR<QRCodeUpdateWithoutScanEventsInput, QRCodeUncheckedUpdateWithoutScanEventsInput>
    create: XOR<QRCodeCreateWithoutScanEventsInput, QRCodeUncheckedCreateWithoutScanEventsInput>
    where?: QRCodeWhereInput
  }

  export type QRCodeUpdateToOneWithWhereWithoutScanEventsInput = {
    where?: QRCodeWhereInput
    data: XOR<QRCodeUpdateWithoutScanEventsInput, QRCodeUncheckedUpdateWithoutScanEventsInput>
  }

  export type QRCodeUpdateWithoutScanEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrCodeString?: StringFieldUpdateOperationsInput | string
    qrCodeHash?: StringFieldUpdateOperationsInput | string
    qrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQRStatusFieldUpdateOperationsInput | $Enums.QRStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentEvents?: PaymentEventUpdateManyWithoutQrCodeNestedInput
    pet?: PetUpdateOneWithoutQrCodesNestedInput
    pool?: QRCodePoolUpdateOneWithoutQrCodesNestedInput
  }

  export type QRCodeUncheckedUpdateWithoutScanEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    poolId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeString?: StringFieldUpdateOperationsInput | string
    qrCodeHash?: StringFieldUpdateOperationsInput | string
    qrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQRStatusFieldUpdateOperationsInput | $Enums.QRStatus
    assignedToPet?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutQrCodeNestedInput
  }

  export type PetUpsertWithoutQrScanEventsInput = {
    update: XOR<PetUpdateWithoutQrScanEventsInput, PetUncheckedUpdateWithoutQrScanEventsInput>
    create: XOR<PetCreateWithoutQrScanEventsInput, PetUncheckedCreateWithoutQrScanEventsInput>
    where?: PetWhereInput
  }

  export type PetUpdateToOneWithWhereWithoutQrScanEventsInput = {
    where?: PetWhereInput
    data: XOR<PetUpdateWithoutQrScanEventsInput, PetUncheckedUpdateWithoutQrScanEventsInput>
  }

  export type PetUpdateWithoutQrScanEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUpdateManyWithoutPetNestedInput
    notifications?: NotificationUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUpdateManyWithoutPetNestedInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_breed_idTopet_breedsNestedInput
    owner?: PetOwnerUpdateOneRequiredWithoutPetsNestedInput
    registeredByUser?: UserUpdateOneWithoutRegisteredPetsNestedInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_secondary_breed_idTopet_breedsNestedInput
    species?: PetSpeciesUpdateOneWithoutPetsNestedInput
    qrCodes?: QRCodeUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateWithoutQrScanEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    registeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableIntFieldUpdateOperationsInput | number | null
    breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPetNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUncheckedUpdateManyWithoutPetNestedInput
    qrCodes?: QRCodeUncheckedUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUncheckedUpdateManyWithoutPetNestedInput
  }

  export type PetLocationEventUpsertWithWhereUniqueWithoutQrScanEventInput = {
    where: PetLocationEventWhereUniqueInput
    update: XOR<PetLocationEventUpdateWithoutQrScanEventInput, PetLocationEventUncheckedUpdateWithoutQrScanEventInput>
    create: XOR<PetLocationEventCreateWithoutQrScanEventInput, PetLocationEventUncheckedCreateWithoutQrScanEventInput>
  }

  export type PetLocationEventUpdateWithWhereUniqueWithoutQrScanEventInput = {
    where: PetLocationEventWhereUniqueInput
    data: XOR<PetLocationEventUpdateWithoutQrScanEventInput, PetLocationEventUncheckedUpdateWithoutQrScanEventInput>
  }

  export type PetLocationEventUpdateManyWithWhereWithoutQrScanEventInput = {
    where: PetLocationEventScalarWhereInput
    data: XOR<PetLocationEventUpdateManyMutationInput, PetLocationEventUncheckedUpdateManyWithoutQrScanEventInput>
  }

  export type PetCreateWithoutLocationEventsInput = {
    id?: string
    name: string
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPetInput
    notifications?: NotificationCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventCreateNestedManyWithoutPetInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_breed_idTopet_breedsInput
    owner: PetOwnerCreateNestedOneWithoutPetsInput
    registeredByUser?: UserCreateNestedOneWithoutRegisteredPetsInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_secondary_breed_idTopet_breedsInput
    species?: PetSpeciesCreateNestedOneWithoutPetsInput
    qrCodes?: QRCodeCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordCreateNestedManyWithoutPetInput
  }

  export type PetUncheckedCreateWithoutLocationEventsInput = {
    id?: string
    ownerId: string
    registeredBy?: string | null
    name: string
    speciesId?: number | null
    breed_id?: number | null
    secondary_breed_id?: number | null
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPetInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventUncheckedCreateNestedManyWithoutPetInput
    qrCodes?: QRCodeUncheckedCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetCreateOrConnectWithoutLocationEventsInput = {
    where: PetWhereUniqueInput
    create: XOR<PetCreateWithoutLocationEventsInput, PetUncheckedCreateWithoutLocationEventsInput>
  }

  export type QRScanEventCreateWithoutLocationEventsInput = {
    id?: string
    scanTimestamp?: Date | string
    scannerIp?: string | null
    userAgent?: string | null
    deviceType?: $Enums.DeviceType | null
    scanLocation?: string | null
    locationAccuracy?: Decimal | DecimalJsLike | number | string | null
    locationName?: string | null
    countryCode?: string | null
    city?: string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    scanResult: $Enums.ScanResult
    createdAt?: Date | string
    qrCode: QRCodeCreateNestedOneWithoutScanEventsInput
    pet?: PetCreateNestedOneWithoutQrScanEventsInput
  }

  export type QRScanEventUncheckedCreateWithoutLocationEventsInput = {
    id?: string
    qrId: string
    petId?: string | null
    scanTimestamp?: Date | string
    scannerIp?: string | null
    userAgent?: string | null
    deviceType?: $Enums.DeviceType | null
    scanLocation?: string | null
    locationAccuracy?: Decimal | DecimalJsLike | number | string | null
    locationName?: string | null
    countryCode?: string | null
    city?: string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    scanResult: $Enums.ScanResult
    createdAt?: Date | string
  }

  export type QRScanEventCreateOrConnectWithoutLocationEventsInput = {
    where: QRScanEventWhereUniqueInput
    create: XOR<QRScanEventCreateWithoutLocationEventsInput, QRScanEventUncheckedCreateWithoutLocationEventsInput>
  }

  export type PetUpsertWithoutLocationEventsInput = {
    update: XOR<PetUpdateWithoutLocationEventsInput, PetUncheckedUpdateWithoutLocationEventsInput>
    create: XOR<PetCreateWithoutLocationEventsInput, PetUncheckedCreateWithoutLocationEventsInput>
    where?: PetWhereInput
  }

  export type PetUpdateToOneWithWhereWithoutLocationEventsInput = {
    where?: PetWhereInput
    data: XOR<PetUpdateWithoutLocationEventsInput, PetUncheckedUpdateWithoutLocationEventsInput>
  }

  export type PetUpdateWithoutLocationEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUpdateManyWithoutPetNestedInput
    notifications?: NotificationUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUpdateManyWithoutPetNestedInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_breed_idTopet_breedsNestedInput
    owner?: PetOwnerUpdateOneRequiredWithoutPetsNestedInput
    registeredByUser?: UserUpdateOneWithoutRegisteredPetsNestedInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_secondary_breed_idTopet_breedsNestedInput
    species?: PetSpeciesUpdateOneWithoutPetsNestedInput
    qrCodes?: QRCodeUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateWithoutLocationEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    registeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableIntFieldUpdateOperationsInput | number | null
    breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPetNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUncheckedUpdateManyWithoutPetNestedInput
    qrCodes?: QRCodeUncheckedUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUncheckedUpdateManyWithoutPetNestedInput
  }

  export type QRScanEventUpsertWithoutLocationEventsInput = {
    update: XOR<QRScanEventUpdateWithoutLocationEventsInput, QRScanEventUncheckedUpdateWithoutLocationEventsInput>
    create: XOR<QRScanEventCreateWithoutLocationEventsInput, QRScanEventUncheckedCreateWithoutLocationEventsInput>
    where?: QRScanEventWhereInput
  }

  export type QRScanEventUpdateToOneWithWhereWithoutLocationEventsInput = {
    where?: QRScanEventWhereInput
    data: XOR<QRScanEventUpdateWithoutLocationEventsInput, QRScanEventUncheckedUpdateWithoutLocationEventsInput>
  }

  export type QRScanEventUpdateWithoutLocationEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    scanTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    scannerIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableEnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType | null
    scanLocation?: NullableStringFieldUpdateOperationsInput | string | null
    locationAccuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    scanResult?: EnumScanResultFieldUpdateOperationsInput | $Enums.ScanResult
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: QRCodeUpdateOneRequiredWithoutScanEventsNestedInput
    pet?: PetUpdateOneWithoutQrScanEventsNestedInput
  }

  export type QRScanEventUncheckedUpdateWithoutLocationEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    petId?: NullableStringFieldUpdateOperationsInput | string | null
    scanTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    scannerIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableEnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType | null
    scanLocation?: NullableStringFieldUpdateOperationsInput | string | null
    locationAccuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    scanResult?: EnumScanResultFieldUpdateOperationsInput | $Enums.ScanResult
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    executive?: ExecutiveCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerCreateNestedOneWithoutUserInput
    registeredPets?: PetCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    executive?: ExecutiveUncheckedCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeUncheckedCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerUncheckedCreateNestedOneWithoutUserInput
    registeredPets?: PetUncheckedCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type PaymentCreateWithoutOrderInput = {
    id?: string
    razorpayPaymentId: string
    razorpayOrderId: string
    amountInPaise: bigint | number
    currency?: string
    method?: string | null
    status?: $Enums.PaymentStatusNew
    captured?: boolean
    capturedAt?: Date | string | null
    bank?: string | null
    vpa?: string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    fee?: bigint | number | null
    tax?: bigint | number | null
    currencyConversion?: NullableJsonNullValueInput | InputJsonValue
    signatureValid?: boolean | null
    signatureVerifiedAt?: Date | string | null
    verificationMethod?: $Enums.VerificationMethod | null
    rawPaymentPayload?: NullableJsonNullValueInput | InputJsonValue
    clientMeta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    refunds?: RefundCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutOrderInput = {
    id?: string
    razorpayPaymentId: string
    razorpayOrderId: string
    amountInPaise: bigint | number
    currency?: string
    method?: string | null
    status?: $Enums.PaymentStatusNew
    captured?: boolean
    capturedAt?: Date | string | null
    bank?: string | null
    vpa?: string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    fee?: bigint | number | null
    tax?: bigint | number | null
    currencyConversion?: NullableJsonNullValueInput | InputJsonValue
    signatureValid?: boolean | null
    signatureVerifiedAt?: Date | string | null
    verificationMethod?: $Enums.VerificationMethod | null
    rawPaymentPayload?: NullableJsonNullValueInput | InputJsonValue
    clientMeta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    refunds?: RefundUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentCreateManyOrderInputEnvelope = {
    data: PaymentCreateManyOrderInput | PaymentCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUpdateOneWithoutUserNestedInput
    registeredPets?: PetUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUncheckedUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUncheckedUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUncheckedUpdateOneWithoutUserNestedInput
    registeredPets?: PetUncheckedUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type PaymentUpdateManyWithWhereWithoutOrderInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutOrderInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: UuidFilter<"Payment"> | string
    localOrderId?: UuidFilter<"Payment"> | string
    razorpayPaymentId?: StringFilter<"Payment"> | string
    razorpayOrderId?: StringFilter<"Payment"> | string
    amountInPaise?: BigIntFilter<"Payment"> | bigint | number
    currency?: StringFilter<"Payment"> | string
    method?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusNewFilter<"Payment"> | $Enums.PaymentStatusNew
    captured?: BoolFilter<"Payment"> | boolean
    capturedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    bank?: StringNullableFilter<"Payment"> | string | null
    vpa?: StringNullableFilter<"Payment"> | string | null
    card?: JsonNullableFilter<"Payment">
    fee?: BigIntNullableFilter<"Payment"> | bigint | number | null
    tax?: BigIntNullableFilter<"Payment"> | bigint | number | null
    currencyConversion?: JsonNullableFilter<"Payment">
    signatureValid?: BoolNullableFilter<"Payment"> | boolean | null
    signatureVerifiedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    verificationMethod?: EnumVerificationMethodNullableFilter<"Payment"> | $Enums.VerificationMethod | null
    rawPaymentPayload?: JsonNullableFilter<"Payment">
    clientMeta?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type OrderCreateWithoutPaymentsInput = {
    id?: string
    razorpayOrderId?: string | null
    receipt?: string | null
    amountInPaise: bigint | number
    currency?: string
    status?: $Enums.OrderStatus
    notes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    rawOrderPayload?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutPaymentsInput = {
    id?: string
    razorpayOrderId?: string | null
    userId: string
    receipt?: string | null
    amountInPaise: bigint | number
    currency?: string
    status?: $Enums.OrderStatus
    notes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    rawOrderPayload?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OrderCreateOrConnectWithoutPaymentsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
  }

  export type RefundCreateWithoutPaymentInput = {
    id?: string
    razorpayRefundId?: string | null
    amountInPaise: bigint | number
    refundAmount?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    initiatedBy?: string | null
    status?: $Enums.RefundStatus
    processedAt?: Date | string | null
    rawRefundPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    paymentEvent?: PaymentEventCreateNestedOneWithoutRefundsInput
  }

  export type RefundUncheckedCreateWithoutPaymentInput = {
    id?: string
    razorpayRefundId?: string | null
    paymentEventId?: string | null
    amountInPaise: bigint | number
    refundAmount?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    initiatedBy?: string | null
    status?: $Enums.RefundStatus
    processedAt?: Date | string | null
    rawRefundPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type RefundCreateOrConnectWithoutPaymentInput = {
    where: RefundWhereUniqueInput
    create: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput>
  }

  export type RefundCreateManyPaymentInputEnvelope = {
    data: RefundCreateManyPaymentInput | RefundCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithoutPaymentsInput = {
    update: XOR<OrderUpdateWithoutPaymentsInput, OrderUncheckedUpdateWithoutPaymentsInput>
    create: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPaymentsInput, OrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type OrderUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    receipt?: NullableStringFieldUpdateOperationsInput | string | null
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawOrderPayload?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    receipt?: NullableStringFieldUpdateOperationsInput | string | null
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawOrderPayload?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RefundUpsertWithWhereUniqueWithoutPaymentInput = {
    where: RefundWhereUniqueInput
    update: XOR<RefundUpdateWithoutPaymentInput, RefundUncheckedUpdateWithoutPaymentInput>
    create: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput>
  }

  export type RefundUpdateWithWhereUniqueWithoutPaymentInput = {
    where: RefundWhereUniqueInput
    data: XOR<RefundUpdateWithoutPaymentInput, RefundUncheckedUpdateWithoutPaymentInput>
  }

  export type RefundUpdateManyWithWhereWithoutPaymentInput = {
    where: RefundScalarWhereInput
    data: XOR<RefundUpdateManyMutationInput, RefundUncheckedUpdateManyWithoutPaymentInput>
  }

  export type RefundScalarWhereInput = {
    AND?: RefundScalarWhereInput | RefundScalarWhereInput[]
    OR?: RefundScalarWhereInput[]
    NOT?: RefundScalarWhereInput | RefundScalarWhereInput[]
    id?: UuidFilter<"Refund"> | string
    razorpayRefundId?: StringNullableFilter<"Refund"> | string | null
    razorpayPaymentId?: StringFilter<"Refund"> | string
    paymentEventId?: UuidNullableFilter<"Refund"> | string | null
    amountInPaise?: BigIntFilter<"Refund"> | bigint | number
    refundAmount?: DecimalNullableFilter<"Refund"> | Decimal | DecimalJsLike | number | string | null
    reason?: StringNullableFilter<"Refund"> | string | null
    initiatedBy?: UuidNullableFilter<"Refund"> | string | null
    status?: EnumRefundStatusFilter<"Refund"> | $Enums.RefundStatus
    processedAt?: DateTimeNullableFilter<"Refund"> | Date | string | null
    rawRefundPayload?: JsonNullableFilter<"Refund">
    createdAt?: DateTimeFilter<"Refund"> | Date | string
  }

  export type PaymentCreateWithoutRefundsInput = {
    id?: string
    razorpayPaymentId: string
    razorpayOrderId: string
    amountInPaise: bigint | number
    currency?: string
    method?: string | null
    status?: $Enums.PaymentStatusNew
    captured?: boolean
    capturedAt?: Date | string | null
    bank?: string | null
    vpa?: string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    fee?: bigint | number | null
    tax?: bigint | number | null
    currencyConversion?: NullableJsonNullValueInput | InputJsonValue
    signatureValid?: boolean | null
    signatureVerifiedAt?: Date | string | null
    verificationMethod?: $Enums.VerificationMethod | null
    rawPaymentPayload?: NullableJsonNullValueInput | InputJsonValue
    clientMeta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutRefundsInput = {
    id?: string
    localOrderId: string
    razorpayPaymentId: string
    razorpayOrderId: string
    amountInPaise: bigint | number
    currency?: string
    method?: string | null
    status?: $Enums.PaymentStatusNew
    captured?: boolean
    capturedAt?: Date | string | null
    bank?: string | null
    vpa?: string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    fee?: bigint | number | null
    tax?: bigint | number | null
    currencyConversion?: NullableJsonNullValueInput | InputJsonValue
    signatureValid?: boolean | null
    signatureVerifiedAt?: Date | string | null
    verificationMethod?: $Enums.VerificationMethod | null
    rawPaymentPayload?: NullableJsonNullValueInput | InputJsonValue
    clientMeta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutRefundsInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutRefundsInput, PaymentUncheckedCreateWithoutRefundsInput>
  }

  export type PaymentEventCreateWithoutRefundsInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentPurpose: $Enums.PaymentPurpose
    status?: $Enums.PaymentStatus
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    razorpaySignature?: string | null
    paymentMethod?: string | null
    failureReason?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    pet?: PetCreateNestedOneWithoutPaymentEventsInput
    qrCode?: QRCodeCreateNestedOneWithoutPaymentEventsInput
    user?: UserCreateNestedOneWithoutPaymentEventsInput
  }

  export type PaymentEventUncheckedCreateWithoutRefundsInput = {
    id?: string
    userId?: string | null
    petId?: string | null
    qrId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentPurpose: $Enums.PaymentPurpose
    status?: $Enums.PaymentStatus
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    razorpaySignature?: string | null
    paymentMethod?: string | null
    failureReason?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type PaymentEventCreateOrConnectWithoutRefundsInput = {
    where: PaymentEventWhereUniqueInput
    create: XOR<PaymentEventCreateWithoutRefundsInput, PaymentEventUncheckedCreateWithoutRefundsInput>
  }

  export type PaymentUpsertWithoutRefundsInput = {
    update: XOR<PaymentUpdateWithoutRefundsInput, PaymentUncheckedUpdateWithoutRefundsInput>
    create: XOR<PaymentCreateWithoutRefundsInput, PaymentUncheckedCreateWithoutRefundsInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutRefundsInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutRefundsInput, PaymentUncheckedUpdateWithoutRefundsInput>
  }

  export type PaymentUpdateWithoutRefundsInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayPaymentId?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: StringFieldUpdateOperationsInput | string
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusNewFieldUpdateOperationsInput | $Enums.PaymentStatusNew
    captured?: BoolFieldUpdateOperationsInput | boolean
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bank?: NullableStringFieldUpdateOperationsInput | string | null
    vpa?: NullableStringFieldUpdateOperationsInput | string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    fee?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currencyConversion?: NullableJsonNullValueInput | InputJsonValue
    signatureValid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    signatureVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableEnumVerificationMethodFieldUpdateOperationsInput | $Enums.VerificationMethod | null
    rawPaymentPayload?: NullableJsonNullValueInput | InputJsonValue
    clientMeta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutRefundsInput = {
    id?: StringFieldUpdateOperationsInput | string
    localOrderId?: StringFieldUpdateOperationsInput | string
    razorpayPaymentId?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: StringFieldUpdateOperationsInput | string
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusNewFieldUpdateOperationsInput | $Enums.PaymentStatusNew
    captured?: BoolFieldUpdateOperationsInput | boolean
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bank?: NullableStringFieldUpdateOperationsInput | string | null
    vpa?: NullableStringFieldUpdateOperationsInput | string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    fee?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currencyConversion?: NullableJsonNullValueInput | InputJsonValue
    signatureValid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    signatureVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableEnumVerificationMethodFieldUpdateOperationsInput | $Enums.VerificationMethod | null
    rawPaymentPayload?: NullableJsonNullValueInput | InputJsonValue
    clientMeta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentEventUpsertWithoutRefundsInput = {
    update: XOR<PaymentEventUpdateWithoutRefundsInput, PaymentEventUncheckedUpdateWithoutRefundsInput>
    create: XOR<PaymentEventCreateWithoutRefundsInput, PaymentEventUncheckedCreateWithoutRefundsInput>
    where?: PaymentEventWhereInput
  }

  export type PaymentEventUpdateToOneWithWhereWithoutRefundsInput = {
    where?: PaymentEventWhereInput
    data: XOR<PaymentEventUpdateWithoutRefundsInput, PaymentEventUncheckedUpdateWithoutRefundsInput>
  }

  export type PaymentEventUpdateWithoutRefundsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentPurpose?: EnumPaymentPurposeFieldUpdateOperationsInput | $Enums.PaymentPurpose
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pet?: PetUpdateOneWithoutPaymentEventsNestedInput
    qrCode?: QRCodeUpdateOneWithoutPaymentEventsNestedInput
    user?: UserUpdateOneWithoutPaymentEventsNestedInput
  }

  export type PaymentEventUncheckedUpdateWithoutRefundsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    petId?: NullableStringFieldUpdateOperationsInput | string | null
    qrId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentPurpose?: EnumPaymentPurposeFieldUpdateOperationsInput | $Enums.PaymentPurpose
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PetCreateWithoutPaymentEventsInput = {
    id?: string
    name: string
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPetInput
    notifications?: NotificationCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventCreateNestedManyWithoutPetInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_breed_idTopet_breedsInput
    owner: PetOwnerCreateNestedOneWithoutPetsInput
    registeredByUser?: UserCreateNestedOneWithoutRegisteredPetsInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_secondary_breed_idTopet_breedsInput
    species?: PetSpeciesCreateNestedOneWithoutPetsInput
    qrCodes?: QRCodeCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordCreateNestedManyWithoutPetInput
  }

  export type PetUncheckedCreateWithoutPaymentEventsInput = {
    id?: string
    ownerId: string
    registeredBy?: string | null
    name: string
    speciesId?: number | null
    breed_id?: number | null
    secondary_breed_id?: number | null
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPetInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventUncheckedCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventUncheckedCreateNestedManyWithoutPetInput
    qrCodes?: QRCodeUncheckedCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetCreateOrConnectWithoutPaymentEventsInput = {
    where: PetWhereUniqueInput
    create: XOR<PetCreateWithoutPaymentEventsInput, PetUncheckedCreateWithoutPaymentEventsInput>
  }

  export type QRCodeCreateWithoutPaymentEventsInput = {
    id?: string
    qrCodeString: string
    qrCodeHash: string
    qrImageUrl?: string | null
    status?: $Enums.QRStatus
    assignedAt?: Date | string | null
    activatedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    pet?: PetCreateNestedOneWithoutQrCodesInput
    pool?: QRCodePoolCreateNestedOneWithoutQrCodesInput
    scanEvents?: QRScanEventCreateNestedManyWithoutQrCodeInput
  }

  export type QRCodeUncheckedCreateWithoutPaymentEventsInput = {
    id?: string
    poolId?: string | null
    qrCodeString: string
    qrCodeHash: string
    qrImageUrl?: string | null
    status?: $Enums.QRStatus
    assignedToPet?: string | null
    assignedAt?: Date | string | null
    activatedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    scanEvents?: QRScanEventUncheckedCreateNestedManyWithoutQrCodeInput
  }

  export type QRCodeCreateOrConnectWithoutPaymentEventsInput = {
    where: QRCodeWhereUniqueInput
    create: XOR<QRCodeCreateWithoutPaymentEventsInput, QRCodeUncheckedCreateWithoutPaymentEventsInput>
  }

  export type UserCreateWithoutPaymentEventsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    executive?: ExecutiveCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerCreateNestedOneWithoutUserInput
    registeredPets?: PetCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentEventsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    executive?: ExecutiveUncheckedCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeUncheckedCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerUncheckedCreateNestedOneWithoutUserInput
    registeredPets?: PetUncheckedCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentEventsInput, UserUncheckedCreateWithoutPaymentEventsInput>
  }

  export type RefundCreateWithoutPaymentEventInput = {
    id?: string
    razorpayRefundId?: string | null
    amountInPaise: bigint | number
    refundAmount?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    initiatedBy?: string | null
    status?: $Enums.RefundStatus
    processedAt?: Date | string | null
    rawRefundPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    payment: PaymentCreateNestedOneWithoutRefundsInput
  }

  export type RefundUncheckedCreateWithoutPaymentEventInput = {
    id?: string
    razorpayRefundId?: string | null
    razorpayPaymentId: string
    amountInPaise: bigint | number
    refundAmount?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    initiatedBy?: string | null
    status?: $Enums.RefundStatus
    processedAt?: Date | string | null
    rawRefundPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type RefundCreateOrConnectWithoutPaymentEventInput = {
    where: RefundWhereUniqueInput
    create: XOR<RefundCreateWithoutPaymentEventInput, RefundUncheckedCreateWithoutPaymentEventInput>
  }

  export type RefundCreateManyPaymentEventInputEnvelope = {
    data: RefundCreateManyPaymentEventInput | RefundCreateManyPaymentEventInput[]
    skipDuplicates?: boolean
  }

  export type PetUpsertWithoutPaymentEventsInput = {
    update: XOR<PetUpdateWithoutPaymentEventsInput, PetUncheckedUpdateWithoutPaymentEventsInput>
    create: XOR<PetCreateWithoutPaymentEventsInput, PetUncheckedCreateWithoutPaymentEventsInput>
    where?: PetWhereInput
  }

  export type PetUpdateToOneWithWhereWithoutPaymentEventsInput = {
    where?: PetWhereInput
    data: XOR<PetUpdateWithoutPaymentEventsInput, PetUncheckedUpdateWithoutPaymentEventsInput>
  }

  export type PetUpdateWithoutPaymentEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUpdateManyWithoutPetNestedInput
    notifications?: NotificationUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUpdateManyWithoutPetNestedInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_breed_idTopet_breedsNestedInput
    owner?: PetOwnerUpdateOneRequiredWithoutPetsNestedInput
    registeredByUser?: UserUpdateOneWithoutRegisteredPetsNestedInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_secondary_breed_idTopet_breedsNestedInput
    species?: PetSpeciesUpdateOneWithoutPetsNestedInput
    qrCodes?: QRCodeUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateWithoutPaymentEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    registeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableIntFieldUpdateOperationsInput | number | null
    breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPetNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUncheckedUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUncheckedUpdateManyWithoutPetNestedInput
    qrCodes?: QRCodeUncheckedUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUncheckedUpdateManyWithoutPetNestedInput
  }

  export type QRCodeUpsertWithoutPaymentEventsInput = {
    update: XOR<QRCodeUpdateWithoutPaymentEventsInput, QRCodeUncheckedUpdateWithoutPaymentEventsInput>
    create: XOR<QRCodeCreateWithoutPaymentEventsInput, QRCodeUncheckedCreateWithoutPaymentEventsInput>
    where?: QRCodeWhereInput
  }

  export type QRCodeUpdateToOneWithWhereWithoutPaymentEventsInput = {
    where?: QRCodeWhereInput
    data: XOR<QRCodeUpdateWithoutPaymentEventsInput, QRCodeUncheckedUpdateWithoutPaymentEventsInput>
  }

  export type QRCodeUpdateWithoutPaymentEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrCodeString?: StringFieldUpdateOperationsInput | string
    qrCodeHash?: StringFieldUpdateOperationsInput | string
    qrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQRStatusFieldUpdateOperationsInput | $Enums.QRStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pet?: PetUpdateOneWithoutQrCodesNestedInput
    pool?: QRCodePoolUpdateOneWithoutQrCodesNestedInput
    scanEvents?: QRScanEventUpdateManyWithoutQrCodeNestedInput
  }

  export type QRCodeUncheckedUpdateWithoutPaymentEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    poolId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeString?: StringFieldUpdateOperationsInput | string
    qrCodeHash?: StringFieldUpdateOperationsInput | string
    qrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQRStatusFieldUpdateOperationsInput | $Enums.QRStatus
    assignedToPet?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scanEvents?: QRScanEventUncheckedUpdateManyWithoutQrCodeNestedInput
  }

  export type UserUpsertWithoutPaymentEventsInput = {
    update: XOR<UserUpdateWithoutPaymentEventsInput, UserUncheckedUpdateWithoutPaymentEventsInput>
    create: XOR<UserCreateWithoutPaymentEventsInput, UserUncheckedCreateWithoutPaymentEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentEventsInput, UserUncheckedUpdateWithoutPaymentEventsInput>
  }

  export type UserUpdateWithoutPaymentEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUpdateOneWithoutUserNestedInput
    registeredPets?: PetUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUncheckedUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUncheckedUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUncheckedUpdateOneWithoutUserNestedInput
    registeredPets?: PetUncheckedUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RefundUpsertWithWhereUniqueWithoutPaymentEventInput = {
    where: RefundWhereUniqueInput
    update: XOR<RefundUpdateWithoutPaymentEventInput, RefundUncheckedUpdateWithoutPaymentEventInput>
    create: XOR<RefundCreateWithoutPaymentEventInput, RefundUncheckedCreateWithoutPaymentEventInput>
  }

  export type RefundUpdateWithWhereUniqueWithoutPaymentEventInput = {
    where: RefundWhereUniqueInput
    data: XOR<RefundUpdateWithoutPaymentEventInput, RefundUncheckedUpdateWithoutPaymentEventInput>
  }

  export type RefundUpdateManyWithWhereWithoutPaymentEventInput = {
    where: RefundScalarWhereInput
    data: XOR<RefundUpdateManyMutationInput, RefundUncheckedUpdateManyWithoutPaymentEventInput>
  }

  export type UserCreateWithoutLocationTracksInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    executive?: ExecutiveCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerCreateNestedOneWithoutUserInput
    registeredPets?: PetCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLocationTracksInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    executive?: ExecutiveUncheckedCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeUncheckedCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerUncheckedCreateNestedOneWithoutUserInput
    registeredPets?: PetUncheckedCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLocationTracksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLocationTracksInput, UserUncheckedCreateWithoutLocationTracksInput>
  }

  export type UserUpsertWithoutLocationTracksInput = {
    update: XOR<UserUpdateWithoutLocationTracksInput, UserUncheckedUpdateWithoutLocationTracksInput>
    create: XOR<UserCreateWithoutLocationTracksInput, UserUncheckedCreateWithoutLocationTracksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLocationTracksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLocationTracksInput, UserUncheckedUpdateWithoutLocationTracksInput>
  }

  export type UserUpdateWithoutLocationTracksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUpdateOneWithoutUserNestedInput
    registeredPets?: PetUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLocationTracksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUncheckedUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUncheckedUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUncheckedUpdateOneWithoutUserNestedInput
    registeredPets?: PetUncheckedUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationPrefsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    executive?: ExecutiveCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerCreateNestedOneWithoutUserInput
    registeredPets?: PetCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationPrefsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    executive?: ExecutiveUncheckedCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeUncheckedCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerUncheckedCreateNestedOneWithoutUserInput
    registeredPets?: PetUncheckedCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationPrefsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationPrefsInput, UserUncheckedCreateWithoutNotificationPrefsInput>
  }

  export type UserUpsertWithoutNotificationPrefsInput = {
    update: XOR<UserUpdateWithoutNotificationPrefsInput, UserUncheckedUpdateWithoutNotificationPrefsInput>
    create: XOR<UserCreateWithoutNotificationPrefsInput, UserUncheckedCreateWithoutNotificationPrefsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationPrefsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationPrefsInput, UserUncheckedUpdateWithoutNotificationPrefsInput>
  }

  export type UserUpdateWithoutNotificationPrefsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUpdateOneWithoutUserNestedInput
    registeredPets?: PetUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationPrefsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUncheckedUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUncheckedUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUncheckedUpdateOneWithoutUserNestedInput
    registeredPets?: PetUncheckedUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PetCreateWithoutNotificationsInput = {
    id?: string
    name: string
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventCreateNestedManyWithoutPetInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_breed_idTopet_breedsInput
    owner: PetOwnerCreateNestedOneWithoutPetsInput
    registeredByUser?: UserCreateNestedOneWithoutRegisteredPetsInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_secondary_breed_idTopet_breedsInput
    species?: PetSpeciesCreateNestedOneWithoutPetsInput
    qrCodes?: QRCodeCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordCreateNestedManyWithoutPetInput
  }

  export type PetUncheckedCreateWithoutNotificationsInput = {
    id?: string
    ownerId: string
    registeredBy?: string | null
    name: string
    speciesId?: number | null
    breed_id?: number | null
    secondary_breed_id?: number | null
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventUncheckedCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventUncheckedCreateNestedManyWithoutPetInput
    qrCodes?: QRCodeUncheckedCreateNestedManyWithoutPetInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetCreateOrConnectWithoutNotificationsInput = {
    where: PetWhereUniqueInput
    create: XOR<PetCreateWithoutNotificationsInput, PetUncheckedCreateWithoutNotificationsInput>
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    executive?: ExecutiveCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerCreateNestedOneWithoutUserInput
    registeredPets?: PetCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    executive?: ExecutiveUncheckedCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeUncheckedCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerUncheckedCreateNestedOneWithoutUserInput
    registeredPets?: PetUncheckedCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type PetUpsertWithoutNotificationsInput = {
    update: XOR<PetUpdateWithoutNotificationsInput, PetUncheckedUpdateWithoutNotificationsInput>
    create: XOR<PetCreateWithoutNotificationsInput, PetUncheckedCreateWithoutNotificationsInput>
    where?: PetWhereInput
  }

  export type PetUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: PetWhereInput
    data: XOR<PetUpdateWithoutNotificationsInput, PetUncheckedUpdateWithoutNotificationsInput>
  }

  export type PetUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUpdateManyWithoutPetNestedInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_breed_idTopet_breedsNestedInput
    owner?: PetOwnerUpdateOneRequiredWithoutPetsNestedInput
    registeredByUser?: UserUpdateOneWithoutRegisteredPetsNestedInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_secondary_breed_idTopet_breedsNestedInput
    species?: PetSpeciesUpdateOneWithoutPetsNestedInput
    qrCodes?: QRCodeUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    registeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableIntFieldUpdateOperationsInput | number | null
    breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUncheckedUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUncheckedUpdateManyWithoutPetNestedInput
    qrCodes?: QRCodeUncheckedUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUncheckedUpdateManyWithoutPetNestedInput
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUpdateOneWithoutUserNestedInput
    registeredPets?: PetUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUncheckedUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUncheckedUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUncheckedUpdateOneWithoutUserNestedInput
    registeredPets?: PetUncheckedUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDeviceTokensInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    executive?: ExecutiveCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerCreateNestedOneWithoutUserInput
    registeredPets?: PetCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDeviceTokensInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    executive?: ExecutiveUncheckedCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeUncheckedCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerUncheckedCreateNestedOneWithoutUserInput
    registeredPets?: PetUncheckedCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDeviceTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeviceTokensInput, UserUncheckedCreateWithoutDeviceTokensInput>
  }

  export type UserUpsertWithoutDeviceTokensInput = {
    update: XOR<UserUpdateWithoutDeviceTokensInput, UserUncheckedUpdateWithoutDeviceTokensInput>
    create: XOR<UserCreateWithoutDeviceTokensInput, UserUncheckedCreateWithoutDeviceTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeviceTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeviceTokensInput, UserUncheckedUpdateWithoutDeviceTokensInput>
  }

  export type UserUpdateWithoutDeviceTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUpdateOneWithoutUserNestedInput
    registeredPets?: PetUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDeviceTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUncheckedUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUncheckedUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUncheckedUpdateOneWithoutUserNestedInput
    registeredPets?: PetUncheckedUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SupportMessageCreateWithoutTicketInput = {
    id?: string
    senderType: $Enums.SenderType
    message: string
    attachments?: SupportMessageCreateattachmentsInput | string[]
    isInternal?: boolean
    createdAt?: Date | string
    sender?: UserCreateNestedOneWithoutSupportMessagesInput
  }

  export type SupportMessageUncheckedCreateWithoutTicketInput = {
    id?: string
    senderId?: string | null
    senderType: $Enums.SenderType
    message: string
    attachments?: SupportMessageCreateattachmentsInput | string[]
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type SupportMessageCreateOrConnectWithoutTicketInput = {
    where: SupportMessageWhereUniqueInput
    create: XOR<SupportMessageCreateWithoutTicketInput, SupportMessageUncheckedCreateWithoutTicketInput>
  }

  export type SupportMessageCreateManyTicketInputEnvelope = {
    data: SupportMessageCreateManyTicketInput | SupportMessageCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutAssignedTicketsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    executive?: ExecutiveCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerCreateNestedOneWithoutUserInput
    registeredPets?: PetCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutSenderInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedTicketsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    executive?: ExecutiveUncheckedCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeUncheckedCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerUncheckedCreateNestedOneWithoutUserInput
    registeredPets?: PetUncheckedCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
  }

  export type PetCreateWithoutSupportTicketsInput = {
    id?: string
    name: string
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPetInput
    notifications?: NotificationCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventCreateNestedManyWithoutPetInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_breed_idTopet_breedsInput
    owner: PetOwnerCreateNestedOneWithoutPetsInput
    registeredByUser?: UserCreateNestedOneWithoutRegisteredPetsInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedCreateNestedOneWithoutPets_pets_secondary_breed_idTopet_breedsInput
    species?: PetSpeciesCreateNestedOneWithoutPetsInput
    qrCodes?: QRCodeCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordCreateNestedManyWithoutPetInput
  }

  export type PetUncheckedCreateWithoutSupportTicketsInput = {
    id?: string
    ownerId: string
    registeredBy?: string | null
    name: string
    speciesId?: number | null
    breed_id?: number | null
    secondary_breed_id?: number | null
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPetInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPetInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutPetInput
    locationEvents?: PetLocationEventUncheckedCreateNestedManyWithoutPetInput
    qrScanEvents?: QRScanEventUncheckedCreateNestedManyWithoutPetInput
    qrCodes?: QRCodeUncheckedCreateNestedManyWithoutPetInput
    vaccinationRecords?: VaccinationRecordUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetCreateOrConnectWithoutSupportTicketsInput = {
    where: PetWhereUniqueInput
    create: XOR<PetCreateWithoutSupportTicketsInput, PetUncheckedCreateWithoutSupportTicketsInput>
  }

  export type UserCreateWithoutSupportTicketsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    executive?: ExecutiveCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerCreateNestedOneWithoutUserInput
    registeredPets?: PetCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSupportTicketsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    executive?: ExecutiveUncheckedCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeUncheckedCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerUncheckedCreateNestedOneWithoutUserInput
    registeredPets?: PetUncheckedCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSupportTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
  }

  export type SupportMessageUpsertWithWhereUniqueWithoutTicketInput = {
    where: SupportMessageWhereUniqueInput
    update: XOR<SupportMessageUpdateWithoutTicketInput, SupportMessageUncheckedUpdateWithoutTicketInput>
    create: XOR<SupportMessageCreateWithoutTicketInput, SupportMessageUncheckedCreateWithoutTicketInput>
  }

  export type SupportMessageUpdateWithWhereUniqueWithoutTicketInput = {
    where: SupportMessageWhereUniqueInput
    data: XOR<SupportMessageUpdateWithoutTicketInput, SupportMessageUncheckedUpdateWithoutTicketInput>
  }

  export type SupportMessageUpdateManyWithWhereWithoutTicketInput = {
    where: SupportMessageScalarWhereInput
    data: XOR<SupportMessageUpdateManyMutationInput, SupportMessageUncheckedUpdateManyWithoutTicketInput>
  }

  export type UserUpsertWithoutAssignedTicketsInput = {
    update: XOR<UserUpdateWithoutAssignedTicketsInput, UserUncheckedUpdateWithoutAssignedTicketsInput>
    create: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedTicketsInput, UserUncheckedUpdateWithoutAssignedTicketsInput>
  }

  export type UserUpdateWithoutAssignedTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUpdateOneWithoutUserNestedInput
    registeredPets?: PetUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUncheckedUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUncheckedUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUncheckedUpdateOneWithoutUserNestedInput
    registeredPets?: PetUncheckedUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PetUpsertWithoutSupportTicketsInput = {
    update: XOR<PetUpdateWithoutSupportTicketsInput, PetUncheckedUpdateWithoutSupportTicketsInput>
    create: XOR<PetCreateWithoutSupportTicketsInput, PetUncheckedCreateWithoutSupportTicketsInput>
    where?: PetWhereInput
  }

  export type PetUpdateToOneWithWhereWithoutSupportTicketsInput = {
    where?: PetWhereInput
    data: XOR<PetUpdateWithoutSupportTicketsInput, PetUncheckedUpdateWithoutSupportTicketsInput>
  }

  export type PetUpdateWithoutSupportTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUpdateManyWithoutPetNestedInput
    notifications?: NotificationUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUpdateManyWithoutPetNestedInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_breed_idTopet_breedsNestedInput
    owner?: PetOwnerUpdateOneRequiredWithoutPetsNestedInput
    registeredByUser?: UserUpdateOneWithoutRegisteredPetsNestedInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_secondary_breed_idTopet_breedsNestedInput
    species?: PetSpeciesUpdateOneWithoutPetsNestedInput
    qrCodes?: QRCodeUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateWithoutSupportTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    registeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableIntFieldUpdateOperationsInput | number | null
    breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPetNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUncheckedUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUncheckedUpdateManyWithoutPetNestedInput
    qrCodes?: QRCodeUncheckedUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUncheckedUpdateManyWithoutPetNestedInput
  }

  export type UserUpsertWithoutSupportTicketsInput = {
    update: XOR<UserUpdateWithoutSupportTicketsInput, UserUncheckedUpdateWithoutSupportTicketsInput>
    create: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSupportTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSupportTicketsInput, UserUncheckedUpdateWithoutSupportTicketsInput>
  }

  export type UserUpdateWithoutSupportTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUpdateOneWithoutUserNestedInput
    registeredPets?: PetUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSupportTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUncheckedUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUncheckedUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUncheckedUpdateOneWithoutUserNestedInput
    registeredPets?: PetUncheckedUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSupportMessagesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    executive?: ExecutiveCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerCreateNestedOneWithoutUserInput
    registeredPets?: PetCreateNestedManyWithoutRegisteredByUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSupportMessagesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    executive?: ExecutiveUncheckedCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeUncheckedCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerUncheckedCreateNestedOneWithoutUserInput
    registeredPets?: PetUncheckedCreateNestedManyWithoutRegisteredByUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSupportMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSupportMessagesInput, UserUncheckedCreateWithoutSupportMessagesInput>
  }

  export type SupportTicketCreateWithoutMessagesInput = {
    id?: string
    ticketNumber: string
    subject: string
    description: string
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    assignedToUser?: UserCreateNestedOneWithoutAssignedTicketsInput
    pet?: PetCreateNestedOneWithoutSupportTicketsInput
    user?: UserCreateNestedOneWithoutSupportTicketsInput
  }

  export type SupportTicketUncheckedCreateWithoutMessagesInput = {
    id?: string
    ticketNumber: string
    userId?: string | null
    petId?: string | null
    subject: string
    description: string
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    assignedTo?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type SupportTicketCreateOrConnectWithoutMessagesInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutMessagesInput, SupportTicketUncheckedCreateWithoutMessagesInput>
  }

  export type UserUpsertWithoutSupportMessagesInput = {
    update: XOR<UserUpdateWithoutSupportMessagesInput, UserUncheckedUpdateWithoutSupportMessagesInput>
    create: XOR<UserCreateWithoutSupportMessagesInput, UserUncheckedCreateWithoutSupportMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSupportMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSupportMessagesInput, UserUncheckedUpdateWithoutSupportMessagesInput>
  }

  export type UserUpdateWithoutSupportMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUpdateOneWithoutUserNestedInput
    registeredPets?: PetUpdateManyWithoutRegisteredByUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSupportMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUncheckedUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUncheckedUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUncheckedUpdateOneWithoutUserNestedInput
    registeredPets?: PetUncheckedUpdateManyWithoutRegisteredByUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SupportTicketUpsertWithoutMessagesInput = {
    update: XOR<SupportTicketUpdateWithoutMessagesInput, SupportTicketUncheckedUpdateWithoutMessagesInput>
    create: XOR<SupportTicketCreateWithoutMessagesInput, SupportTicketUncheckedCreateWithoutMessagesInput>
    where?: SupportTicketWhereInput
  }

  export type SupportTicketUpdateToOneWithWhereWithoutMessagesInput = {
    where?: SupportTicketWhereInput
    data: XOR<SupportTicketUpdateWithoutMessagesInput, SupportTicketUncheckedUpdateWithoutMessagesInput>
  }

  export type SupportTicketUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUser?: UserUpdateOneWithoutAssignedTicketsNestedInput
    pet?: PetUpdateOneWithoutSupportTicketsNestedInput
    user?: UserUpdateOneWithoutSupportTicketsNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    petId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    executive?: ExecutiveCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerCreateNestedOneWithoutUserInput
    registeredPets?: PetCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleId?: string | null
    appleId?: string | null
    profilePicture?: string | null
    authProvider?: $Enums.AuthProvider | null
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    executive?: ExecutiveUncheckedCreateNestedOneWithoutUserInput
    locationTracks?: LocationTrackUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otpCodes?: OTPCodeUncheckedCreateNestedManyWithoutUserInput
    paymentEvents?: PaymentEventUncheckedCreateNestedManyWithoutUserInput
    petOwner?: PetOwnerUncheckedCreateNestedOneWithoutUserInput
    registeredPets?: PetUncheckedCreateNestedManyWithoutRegisteredByUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUpdateOneWithoutUserNestedInput
    registeredPets?: PetUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: NullableEnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider | null
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    executive?: ExecutiveUncheckedUpdateOneWithoutUserNestedInput
    locationTracks?: LocationTrackUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    otpCodes?: OTPCodeUncheckedUpdateManyWithoutUserNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutUserNestedInput
    petOwner?: PetOwnerUncheckedUpdateOneWithoutUserNestedInput
    registeredPets?: PetUncheckedUpdateManyWithoutRegisteredByUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ApplicationDocumentCreateWithoutApplicationInput = {
    id?: string
    documentType: $Enums.DocumentType
    fileName: string
    filePath: string
    mimeType: string
    sizeBytes: bigint | number
    createdAt?: Date | string
  }

  export type ApplicationDocumentUncheckedCreateWithoutApplicationInput = {
    id?: string
    documentType: $Enums.DocumentType
    fileName: string
    filePath: string
    mimeType: string
    sizeBytes: bigint | number
    createdAt?: Date | string
  }

  export type ApplicationDocumentCreateOrConnectWithoutApplicationInput = {
    where: ApplicationDocumentWhereUniqueInput
    create: XOR<ApplicationDocumentCreateWithoutApplicationInput, ApplicationDocumentUncheckedCreateWithoutApplicationInput>
  }

  export type ApplicationDocumentCreateManyApplicationInputEnvelope = {
    data: ApplicationDocumentCreateManyApplicationInput | ApplicationDocumentCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type CheckoutItemCreateWithoutApplicationInput = {
    id?: string
    sku: string
    itemName: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CheckoutItemUncheckedCreateWithoutApplicationInput = {
    id?: string
    sku: string
    itemName: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CheckoutItemCreateOrConnectWithoutApplicationInput = {
    where: CheckoutItemWhereUniqueInput
    create: XOR<CheckoutItemCreateWithoutApplicationInput, CheckoutItemUncheckedCreateWithoutApplicationInput>
  }

  export type CheckoutItemCreateManyApplicationInputEnvelope = {
    data: CheckoutItemCreateManyApplicationInput | CheckoutItemCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type RegisteredPetCreateWithoutApplicationInput = {
    id?: string
    petName: string
    breed: string
    dateOfBirth: Date | string
    ageOnRegistration: string
    lastRabiesVaccinationDate: Date | string
    veterinaryDoctorName: string
    veterinaryDoctorRegNumber: string
    veterinaryClinicOrHospitalName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gender: $Enums.Gender
    documents?: PetDocumentCreateNestedManyWithoutPetInput
  }

  export type RegisteredPetUncheckedCreateWithoutApplicationInput = {
    id?: string
    petName: string
    breed: string
    dateOfBirth: Date | string
    ageOnRegistration: string
    lastRabiesVaccinationDate: Date | string
    veterinaryDoctorName: string
    veterinaryDoctorRegNumber: string
    veterinaryClinicOrHospitalName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gender: $Enums.Gender
    documents?: PetDocumentUncheckedCreateNestedManyWithoutPetInput
  }

  export type RegisteredPetCreateOrConnectWithoutApplicationInput = {
    where: RegisteredPetWhereUniqueInput
    create: XOR<RegisteredPetCreateWithoutApplicationInput, RegisteredPetUncheckedCreateWithoutApplicationInput>
  }

  export type RegisteredPetCreateManyApplicationInputEnvelope = {
    data: RegisteredPetCreateManyApplicationInput | RegisteredPetCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type ApplicationDocumentUpsertWithWhereUniqueWithoutApplicationInput = {
    where: ApplicationDocumentWhereUniqueInput
    update: XOR<ApplicationDocumentUpdateWithoutApplicationInput, ApplicationDocumentUncheckedUpdateWithoutApplicationInput>
    create: XOR<ApplicationDocumentCreateWithoutApplicationInput, ApplicationDocumentUncheckedCreateWithoutApplicationInput>
  }

  export type ApplicationDocumentUpdateWithWhereUniqueWithoutApplicationInput = {
    where: ApplicationDocumentWhereUniqueInput
    data: XOR<ApplicationDocumentUpdateWithoutApplicationInput, ApplicationDocumentUncheckedUpdateWithoutApplicationInput>
  }

  export type ApplicationDocumentUpdateManyWithWhereWithoutApplicationInput = {
    where: ApplicationDocumentScalarWhereInput
    data: XOR<ApplicationDocumentUpdateManyMutationInput, ApplicationDocumentUncheckedUpdateManyWithoutApplicationInput>
  }

  export type ApplicationDocumentScalarWhereInput = {
    AND?: ApplicationDocumentScalarWhereInput | ApplicationDocumentScalarWhereInput[]
    OR?: ApplicationDocumentScalarWhereInput[]
    NOT?: ApplicationDocumentScalarWhereInput | ApplicationDocumentScalarWhereInput[]
    id?: UuidFilter<"ApplicationDocument"> | string
    applicationId?: UuidFilter<"ApplicationDocument"> | string
    documentType?: EnumDocumentTypeFilter<"ApplicationDocument"> | $Enums.DocumentType
    fileName?: StringFilter<"ApplicationDocument"> | string
    filePath?: StringFilter<"ApplicationDocument"> | string
    mimeType?: StringFilter<"ApplicationDocument"> | string
    sizeBytes?: BigIntFilter<"ApplicationDocument"> | bigint | number
    createdAt?: DateTimeFilter<"ApplicationDocument"> | Date | string
  }

  export type CheckoutItemUpsertWithWhereUniqueWithoutApplicationInput = {
    where: CheckoutItemWhereUniqueInput
    update: XOR<CheckoutItemUpdateWithoutApplicationInput, CheckoutItemUncheckedUpdateWithoutApplicationInput>
    create: XOR<CheckoutItemCreateWithoutApplicationInput, CheckoutItemUncheckedCreateWithoutApplicationInput>
  }

  export type CheckoutItemUpdateWithWhereUniqueWithoutApplicationInput = {
    where: CheckoutItemWhereUniqueInput
    data: XOR<CheckoutItemUpdateWithoutApplicationInput, CheckoutItemUncheckedUpdateWithoutApplicationInput>
  }

  export type CheckoutItemUpdateManyWithWhereWithoutApplicationInput = {
    where: CheckoutItemScalarWhereInput
    data: XOR<CheckoutItemUpdateManyMutationInput, CheckoutItemUncheckedUpdateManyWithoutApplicationInput>
  }

  export type CheckoutItemScalarWhereInput = {
    AND?: CheckoutItemScalarWhereInput | CheckoutItemScalarWhereInput[]
    OR?: CheckoutItemScalarWhereInput[]
    NOT?: CheckoutItemScalarWhereInput | CheckoutItemScalarWhereInput[]
    id?: UuidFilter<"CheckoutItem"> | string
    applicationId?: UuidFilter<"CheckoutItem"> | string
    sku?: StringFilter<"CheckoutItem"> | string
    itemName?: StringFilter<"CheckoutItem"> | string
    quantity?: IntFilter<"CheckoutItem"> | number
    unitPrice?: DecimalFilter<"CheckoutItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"CheckoutItem"> | Date | string
  }

  export type RegisteredPetUpsertWithWhereUniqueWithoutApplicationInput = {
    where: RegisteredPetWhereUniqueInput
    update: XOR<RegisteredPetUpdateWithoutApplicationInput, RegisteredPetUncheckedUpdateWithoutApplicationInput>
    create: XOR<RegisteredPetCreateWithoutApplicationInput, RegisteredPetUncheckedCreateWithoutApplicationInput>
  }

  export type RegisteredPetUpdateWithWhereUniqueWithoutApplicationInput = {
    where: RegisteredPetWhereUniqueInput
    data: XOR<RegisteredPetUpdateWithoutApplicationInput, RegisteredPetUncheckedUpdateWithoutApplicationInput>
  }

  export type RegisteredPetUpdateManyWithWhereWithoutApplicationInput = {
    where: RegisteredPetScalarWhereInput
    data: XOR<RegisteredPetUpdateManyMutationInput, RegisteredPetUncheckedUpdateManyWithoutApplicationInput>
  }

  export type RegisteredPetScalarWhereInput = {
    AND?: RegisteredPetScalarWhereInput | RegisteredPetScalarWhereInput[]
    OR?: RegisteredPetScalarWhereInput[]
    NOT?: RegisteredPetScalarWhereInput | RegisteredPetScalarWhereInput[]
    id?: UuidFilter<"RegisteredPet"> | string
    applicationId?: UuidFilter<"RegisteredPet"> | string
    petName?: StringFilter<"RegisteredPet"> | string
    breed?: StringFilter<"RegisteredPet"> | string
    dateOfBirth?: DateTimeFilter<"RegisteredPet"> | Date | string
    ageOnRegistration?: StringFilter<"RegisteredPet"> | string
    lastRabiesVaccinationDate?: DateTimeFilter<"RegisteredPet"> | Date | string
    veterinaryDoctorName?: StringFilter<"RegisteredPet"> | string
    veterinaryDoctorRegNumber?: StringFilter<"RegisteredPet"> | string
    veterinaryClinicOrHospitalName?: StringFilter<"RegisteredPet"> | string
    createdAt?: DateTimeFilter<"RegisteredPet"> | Date | string
    updatedAt?: DateTimeFilter<"RegisteredPet"> | Date | string
    gender?: EnumGenderFilter<"RegisteredPet"> | $Enums.Gender
  }

  export type PetDocumentCreateWithoutPetInput = {
    id?: string
    documentType: $Enums.DocumentType
    fileName: string
    filePath: string
    mimeType: string
    sizeBytes: bigint | number
    createdAt?: Date | string
  }

  export type PetDocumentUncheckedCreateWithoutPetInput = {
    id?: string
    documentType: $Enums.DocumentType
    fileName: string
    filePath: string
    mimeType: string
    sizeBytes: bigint | number
    createdAt?: Date | string
  }

  export type PetDocumentCreateOrConnectWithoutPetInput = {
    where: PetDocumentWhereUniqueInput
    create: XOR<PetDocumentCreateWithoutPetInput, PetDocumentUncheckedCreateWithoutPetInput>
  }

  export type PetDocumentCreateManyPetInputEnvelope = {
    data: PetDocumentCreateManyPetInput | PetDocumentCreateManyPetInput[]
    skipDuplicates?: boolean
  }

  export type PetRegistrationApplicationCreateWithoutPetsInput = {
    id?: string
    applicationType: $Enums.ApplicationType
    identifierType: $Enums.IdentifierType
    identifierNumber?: string | null
    submittedAt: Date | string
    city: string
    state: string
    country: string
    applicantType: $Enums.ApplicantType
    applicantName: string
    fatherOrHusbandName?: string | null
    applicantEmail: string
    applicantPhone: string
    aadhaarNumber?: string | null
    pincode: string
    address: string
    hasTokenNumber?: boolean
    declarationAcknowledgement: string
    acceptedTerms?: boolean
    registrationFee: Decimal | DecimalJsLike | number | string
    convenienceFee: Decimal | DecimalJsLike | number | string
    gst: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    deliveryAddressLine: string
    deliveryCity: string
    deliveryState: string
    deliveryPincode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: ApplicationDocumentCreateNestedManyWithoutApplicationInput
    checkoutItems?: CheckoutItemCreateNestedManyWithoutApplicationInput
  }

  export type PetRegistrationApplicationUncheckedCreateWithoutPetsInput = {
    id?: string
    applicationType: $Enums.ApplicationType
    identifierType: $Enums.IdentifierType
    identifierNumber?: string | null
    submittedAt: Date | string
    city: string
    state: string
    country: string
    applicantType: $Enums.ApplicantType
    applicantName: string
    fatherOrHusbandName?: string | null
    applicantEmail: string
    applicantPhone: string
    aadhaarNumber?: string | null
    pincode: string
    address: string
    hasTokenNumber?: boolean
    declarationAcknowledgement: string
    acceptedTerms?: boolean
    registrationFee: Decimal | DecimalJsLike | number | string
    convenienceFee: Decimal | DecimalJsLike | number | string
    gst: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    deliveryAddressLine: string
    deliveryCity: string
    deliveryState: string
    deliveryPincode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: ApplicationDocumentUncheckedCreateNestedManyWithoutApplicationInput
    checkoutItems?: CheckoutItemUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type PetRegistrationApplicationCreateOrConnectWithoutPetsInput = {
    where: PetRegistrationApplicationWhereUniqueInput
    create: XOR<PetRegistrationApplicationCreateWithoutPetsInput, PetRegistrationApplicationUncheckedCreateWithoutPetsInput>
  }

  export type PetDocumentUpsertWithWhereUniqueWithoutPetInput = {
    where: PetDocumentWhereUniqueInput
    update: XOR<PetDocumentUpdateWithoutPetInput, PetDocumentUncheckedUpdateWithoutPetInput>
    create: XOR<PetDocumentCreateWithoutPetInput, PetDocumentUncheckedCreateWithoutPetInput>
  }

  export type PetDocumentUpdateWithWhereUniqueWithoutPetInput = {
    where: PetDocumentWhereUniqueInput
    data: XOR<PetDocumentUpdateWithoutPetInput, PetDocumentUncheckedUpdateWithoutPetInput>
  }

  export type PetDocumentUpdateManyWithWhereWithoutPetInput = {
    where: PetDocumentScalarWhereInput
    data: XOR<PetDocumentUpdateManyMutationInput, PetDocumentUncheckedUpdateManyWithoutPetInput>
  }

  export type PetDocumentScalarWhereInput = {
    AND?: PetDocumentScalarWhereInput | PetDocumentScalarWhereInput[]
    OR?: PetDocumentScalarWhereInput[]
    NOT?: PetDocumentScalarWhereInput | PetDocumentScalarWhereInput[]
    id?: UuidFilter<"PetDocument"> | string
    petId?: UuidFilter<"PetDocument"> | string
    documentType?: EnumDocumentTypeFilter<"PetDocument"> | $Enums.DocumentType
    fileName?: StringFilter<"PetDocument"> | string
    filePath?: StringFilter<"PetDocument"> | string
    mimeType?: StringFilter<"PetDocument"> | string
    sizeBytes?: BigIntFilter<"PetDocument"> | bigint | number
    createdAt?: DateTimeFilter<"PetDocument"> | Date | string
  }

  export type PetRegistrationApplicationUpsertWithoutPetsInput = {
    update: XOR<PetRegistrationApplicationUpdateWithoutPetsInput, PetRegistrationApplicationUncheckedUpdateWithoutPetsInput>
    create: XOR<PetRegistrationApplicationCreateWithoutPetsInput, PetRegistrationApplicationUncheckedCreateWithoutPetsInput>
    where?: PetRegistrationApplicationWhereInput
  }

  export type PetRegistrationApplicationUpdateToOneWithWhereWithoutPetsInput = {
    where?: PetRegistrationApplicationWhereInput
    data: XOR<PetRegistrationApplicationUpdateWithoutPetsInput, PetRegistrationApplicationUncheckedUpdateWithoutPetsInput>
  }

  export type PetRegistrationApplicationUpdateWithoutPetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationType?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    identifierType?: EnumIdentifierTypeFieldUpdateOperationsInput | $Enums.IdentifierType
    identifierNumber?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    applicantName?: StringFieldUpdateOperationsInput | string
    fatherOrHusbandName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantEmail?: StringFieldUpdateOperationsInput | string
    applicantPhone?: StringFieldUpdateOperationsInput | string
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    hasTokenNumber?: BoolFieldUpdateOperationsInput | boolean
    declarationAcknowledgement?: StringFieldUpdateOperationsInput | string
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    convenienceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    deliveryAddressLine?: StringFieldUpdateOperationsInput | string
    deliveryCity?: StringFieldUpdateOperationsInput | string
    deliveryState?: StringFieldUpdateOperationsInput | string
    deliveryPincode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: ApplicationDocumentUpdateManyWithoutApplicationNestedInput
    checkoutItems?: CheckoutItemUpdateManyWithoutApplicationNestedInput
  }

  export type PetRegistrationApplicationUncheckedUpdateWithoutPetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationType?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    identifierType?: EnumIdentifierTypeFieldUpdateOperationsInput | $Enums.IdentifierType
    identifierNumber?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    applicantName?: StringFieldUpdateOperationsInput | string
    fatherOrHusbandName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantEmail?: StringFieldUpdateOperationsInput | string
    applicantPhone?: StringFieldUpdateOperationsInput | string
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    hasTokenNumber?: BoolFieldUpdateOperationsInput | boolean
    declarationAcknowledgement?: StringFieldUpdateOperationsInput | string
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    convenienceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    deliveryAddressLine?: StringFieldUpdateOperationsInput | string
    deliveryCity?: StringFieldUpdateOperationsInput | string
    deliveryState?: StringFieldUpdateOperationsInput | string
    deliveryPincode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: ApplicationDocumentUncheckedUpdateManyWithoutApplicationNestedInput
    checkoutItems?: CheckoutItemUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type PetRegistrationApplicationCreateWithoutDocumentsInput = {
    id?: string
    applicationType: $Enums.ApplicationType
    identifierType: $Enums.IdentifierType
    identifierNumber?: string | null
    submittedAt: Date | string
    city: string
    state: string
    country: string
    applicantType: $Enums.ApplicantType
    applicantName: string
    fatherOrHusbandName?: string | null
    applicantEmail: string
    applicantPhone: string
    aadhaarNumber?: string | null
    pincode: string
    address: string
    hasTokenNumber?: boolean
    declarationAcknowledgement: string
    acceptedTerms?: boolean
    registrationFee: Decimal | DecimalJsLike | number | string
    convenienceFee: Decimal | DecimalJsLike | number | string
    gst: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    deliveryAddressLine: string
    deliveryCity: string
    deliveryState: string
    deliveryPincode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checkoutItems?: CheckoutItemCreateNestedManyWithoutApplicationInput
    pets?: RegisteredPetCreateNestedManyWithoutApplicationInput
  }

  export type PetRegistrationApplicationUncheckedCreateWithoutDocumentsInput = {
    id?: string
    applicationType: $Enums.ApplicationType
    identifierType: $Enums.IdentifierType
    identifierNumber?: string | null
    submittedAt: Date | string
    city: string
    state: string
    country: string
    applicantType: $Enums.ApplicantType
    applicantName: string
    fatherOrHusbandName?: string | null
    applicantEmail: string
    applicantPhone: string
    aadhaarNumber?: string | null
    pincode: string
    address: string
    hasTokenNumber?: boolean
    declarationAcknowledgement: string
    acceptedTerms?: boolean
    registrationFee: Decimal | DecimalJsLike | number | string
    convenienceFee: Decimal | DecimalJsLike | number | string
    gst: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    deliveryAddressLine: string
    deliveryCity: string
    deliveryState: string
    deliveryPincode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checkoutItems?: CheckoutItemUncheckedCreateNestedManyWithoutApplicationInput
    pets?: RegisteredPetUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type PetRegistrationApplicationCreateOrConnectWithoutDocumentsInput = {
    where: PetRegistrationApplicationWhereUniqueInput
    create: XOR<PetRegistrationApplicationCreateWithoutDocumentsInput, PetRegistrationApplicationUncheckedCreateWithoutDocumentsInput>
  }

  export type PetRegistrationApplicationUpsertWithoutDocumentsInput = {
    update: XOR<PetRegistrationApplicationUpdateWithoutDocumentsInput, PetRegistrationApplicationUncheckedUpdateWithoutDocumentsInput>
    create: XOR<PetRegistrationApplicationCreateWithoutDocumentsInput, PetRegistrationApplicationUncheckedCreateWithoutDocumentsInput>
    where?: PetRegistrationApplicationWhereInput
  }

  export type PetRegistrationApplicationUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: PetRegistrationApplicationWhereInput
    data: XOR<PetRegistrationApplicationUpdateWithoutDocumentsInput, PetRegistrationApplicationUncheckedUpdateWithoutDocumentsInput>
  }

  export type PetRegistrationApplicationUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationType?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    identifierType?: EnumIdentifierTypeFieldUpdateOperationsInput | $Enums.IdentifierType
    identifierNumber?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    applicantName?: StringFieldUpdateOperationsInput | string
    fatherOrHusbandName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantEmail?: StringFieldUpdateOperationsInput | string
    applicantPhone?: StringFieldUpdateOperationsInput | string
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    hasTokenNumber?: BoolFieldUpdateOperationsInput | boolean
    declarationAcknowledgement?: StringFieldUpdateOperationsInput | string
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    convenienceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    deliveryAddressLine?: StringFieldUpdateOperationsInput | string
    deliveryCity?: StringFieldUpdateOperationsInput | string
    deliveryState?: StringFieldUpdateOperationsInput | string
    deliveryPincode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkoutItems?: CheckoutItemUpdateManyWithoutApplicationNestedInput
    pets?: RegisteredPetUpdateManyWithoutApplicationNestedInput
  }

  export type PetRegistrationApplicationUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationType?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    identifierType?: EnumIdentifierTypeFieldUpdateOperationsInput | $Enums.IdentifierType
    identifierNumber?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    applicantName?: StringFieldUpdateOperationsInput | string
    fatherOrHusbandName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantEmail?: StringFieldUpdateOperationsInput | string
    applicantPhone?: StringFieldUpdateOperationsInput | string
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    hasTokenNumber?: BoolFieldUpdateOperationsInput | boolean
    declarationAcknowledgement?: StringFieldUpdateOperationsInput | string
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    convenienceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    deliveryAddressLine?: StringFieldUpdateOperationsInput | string
    deliveryCity?: StringFieldUpdateOperationsInput | string
    deliveryState?: StringFieldUpdateOperationsInput | string
    deliveryPincode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkoutItems?: CheckoutItemUncheckedUpdateManyWithoutApplicationNestedInput
    pets?: RegisteredPetUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type RegisteredPetCreateWithoutDocumentsInput = {
    id?: string
    petName: string
    breed: string
    dateOfBirth: Date | string
    ageOnRegistration: string
    lastRabiesVaccinationDate: Date | string
    veterinaryDoctorName: string
    veterinaryDoctorRegNumber: string
    veterinaryClinicOrHospitalName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gender: $Enums.Gender
    application: PetRegistrationApplicationCreateNestedOneWithoutPetsInput
  }

  export type RegisteredPetUncheckedCreateWithoutDocumentsInput = {
    id?: string
    applicationId: string
    petName: string
    breed: string
    dateOfBirth: Date | string
    ageOnRegistration: string
    lastRabiesVaccinationDate: Date | string
    veterinaryDoctorName: string
    veterinaryDoctorRegNumber: string
    veterinaryClinicOrHospitalName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gender: $Enums.Gender
  }

  export type RegisteredPetCreateOrConnectWithoutDocumentsInput = {
    where: RegisteredPetWhereUniqueInput
    create: XOR<RegisteredPetCreateWithoutDocumentsInput, RegisteredPetUncheckedCreateWithoutDocumentsInput>
  }

  export type RegisteredPetUpsertWithoutDocumentsInput = {
    update: XOR<RegisteredPetUpdateWithoutDocumentsInput, RegisteredPetUncheckedUpdateWithoutDocumentsInput>
    create: XOR<RegisteredPetCreateWithoutDocumentsInput, RegisteredPetUncheckedCreateWithoutDocumentsInput>
    where?: RegisteredPetWhereInput
  }

  export type RegisteredPetUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: RegisteredPetWhereInput
    data: XOR<RegisteredPetUpdateWithoutDocumentsInput, RegisteredPetUncheckedUpdateWithoutDocumentsInput>
  }

  export type RegisteredPetUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    petName?: StringFieldUpdateOperationsInput | string
    breed?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    ageOnRegistration?: StringFieldUpdateOperationsInput | string
    lastRabiesVaccinationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    veterinaryDoctorName?: StringFieldUpdateOperationsInput | string
    veterinaryDoctorRegNumber?: StringFieldUpdateOperationsInput | string
    veterinaryClinicOrHospitalName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    application?: PetRegistrationApplicationUpdateOneRequiredWithoutPetsNestedInput
  }

  export type RegisteredPetUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    petName?: StringFieldUpdateOperationsInput | string
    breed?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    ageOnRegistration?: StringFieldUpdateOperationsInput | string
    lastRabiesVaccinationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    veterinaryDoctorName?: StringFieldUpdateOperationsInput | string
    veterinaryDoctorRegNumber?: StringFieldUpdateOperationsInput | string
    veterinaryClinicOrHospitalName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
  }

  export type PetRegistrationApplicationCreateWithoutCheckoutItemsInput = {
    id?: string
    applicationType: $Enums.ApplicationType
    identifierType: $Enums.IdentifierType
    identifierNumber?: string | null
    submittedAt: Date | string
    city: string
    state: string
    country: string
    applicantType: $Enums.ApplicantType
    applicantName: string
    fatherOrHusbandName?: string | null
    applicantEmail: string
    applicantPhone: string
    aadhaarNumber?: string | null
    pincode: string
    address: string
    hasTokenNumber?: boolean
    declarationAcknowledgement: string
    acceptedTerms?: boolean
    registrationFee: Decimal | DecimalJsLike | number | string
    convenienceFee: Decimal | DecimalJsLike | number | string
    gst: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    deliveryAddressLine: string
    deliveryCity: string
    deliveryState: string
    deliveryPincode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: ApplicationDocumentCreateNestedManyWithoutApplicationInput
    pets?: RegisteredPetCreateNestedManyWithoutApplicationInput
  }

  export type PetRegistrationApplicationUncheckedCreateWithoutCheckoutItemsInput = {
    id?: string
    applicationType: $Enums.ApplicationType
    identifierType: $Enums.IdentifierType
    identifierNumber?: string | null
    submittedAt: Date | string
    city: string
    state: string
    country: string
    applicantType: $Enums.ApplicantType
    applicantName: string
    fatherOrHusbandName?: string | null
    applicantEmail: string
    applicantPhone: string
    aadhaarNumber?: string | null
    pincode: string
    address: string
    hasTokenNumber?: boolean
    declarationAcknowledgement: string
    acceptedTerms?: boolean
    registrationFee: Decimal | DecimalJsLike | number | string
    convenienceFee: Decimal | DecimalJsLike | number | string
    gst: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    deliveryAddressLine: string
    deliveryCity: string
    deliveryState: string
    deliveryPincode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: ApplicationDocumentUncheckedCreateNestedManyWithoutApplicationInput
    pets?: RegisteredPetUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type PetRegistrationApplicationCreateOrConnectWithoutCheckoutItemsInput = {
    where: PetRegistrationApplicationWhereUniqueInput
    create: XOR<PetRegistrationApplicationCreateWithoutCheckoutItemsInput, PetRegistrationApplicationUncheckedCreateWithoutCheckoutItemsInput>
  }

  export type PetRegistrationApplicationUpsertWithoutCheckoutItemsInput = {
    update: XOR<PetRegistrationApplicationUpdateWithoutCheckoutItemsInput, PetRegistrationApplicationUncheckedUpdateWithoutCheckoutItemsInput>
    create: XOR<PetRegistrationApplicationCreateWithoutCheckoutItemsInput, PetRegistrationApplicationUncheckedCreateWithoutCheckoutItemsInput>
    where?: PetRegistrationApplicationWhereInput
  }

  export type PetRegistrationApplicationUpdateToOneWithWhereWithoutCheckoutItemsInput = {
    where?: PetRegistrationApplicationWhereInput
    data: XOR<PetRegistrationApplicationUpdateWithoutCheckoutItemsInput, PetRegistrationApplicationUncheckedUpdateWithoutCheckoutItemsInput>
  }

  export type PetRegistrationApplicationUpdateWithoutCheckoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationType?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    identifierType?: EnumIdentifierTypeFieldUpdateOperationsInput | $Enums.IdentifierType
    identifierNumber?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    applicantName?: StringFieldUpdateOperationsInput | string
    fatherOrHusbandName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantEmail?: StringFieldUpdateOperationsInput | string
    applicantPhone?: StringFieldUpdateOperationsInput | string
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    hasTokenNumber?: BoolFieldUpdateOperationsInput | boolean
    declarationAcknowledgement?: StringFieldUpdateOperationsInput | string
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    convenienceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    deliveryAddressLine?: StringFieldUpdateOperationsInput | string
    deliveryCity?: StringFieldUpdateOperationsInput | string
    deliveryState?: StringFieldUpdateOperationsInput | string
    deliveryPincode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: ApplicationDocumentUpdateManyWithoutApplicationNestedInput
    pets?: RegisteredPetUpdateManyWithoutApplicationNestedInput
  }

  export type PetRegistrationApplicationUncheckedUpdateWithoutCheckoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationType?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    identifierType?: EnumIdentifierTypeFieldUpdateOperationsInput | $Enums.IdentifierType
    identifierNumber?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    applicantName?: StringFieldUpdateOperationsInput | string
    fatherOrHusbandName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantEmail?: StringFieldUpdateOperationsInput | string
    applicantPhone?: StringFieldUpdateOperationsInput | string
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    hasTokenNumber?: BoolFieldUpdateOperationsInput | boolean
    declarationAcknowledgement?: StringFieldUpdateOperationsInput | string
    acceptedTerms?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    convenienceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gst?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    deliveryAddressLine?: StringFieldUpdateOperationsInput | string
    deliveryCity?: StringFieldUpdateOperationsInput | string
    deliveryState?: StringFieldUpdateOperationsInput | string
    deliveryPincode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: ApplicationDocumentUncheckedUpdateManyWithoutApplicationNestedInput
    pets?: RegisteredPetUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    tableName: string
    recordId: string
    operationType: $Enums.OperationType
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedColumns?: AuditLogCreatechangedColumnsInput | string[]
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type DeviceTokenCreateManyUserInput = {
    id?: string
    deviceToken: string
    platform: $Enums.Platform
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type LocationTrackCreateManyUserInput = {
    id?: string
    locationType: $Enums.LocationType
    position?: string | null
    accuracy?: Decimal | DecimalJsLike | number | string | null
    locationName?: string | null
    countryCode?: string | null
    state?: string | null
    city?: string | null
    ipAddress?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    petId?: string | null
    qrScanId?: string | null
    notificationType: $Enums.NotificationType
    title: string
    message: string
    channels?: NotificationCreatechannelsInput | string[]
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    sentAt?: Date | string | null
    readAt?: Date | string | null
  }

  export type OrderCreateManyUserInput = {
    id?: string
    razorpayOrderId?: string | null
    receipt?: string | null
    amountInPaise: bigint | number
    currency?: string
    status?: $Enums.OrderStatus
    notes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    rawOrderPayload?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OTPCodeCreateManyUserInput = {
    id?: string
    codeHash: string
    purpose: $Enums.OTPPurpose
    deliveryMethod?: string | null
    expiresAt: Date | string
    isUsed?: boolean
    attemptsCount?: number
    maxAttempts?: number
    createdAt?: Date | string
  }

  export type PaymentEventCreateManyUserInput = {
    id?: string
    petId?: string | null
    qrId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentPurpose: $Enums.PaymentPurpose
    status?: $Enums.PaymentStatus
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    razorpaySignature?: string | null
    paymentMethod?: string | null
    failureReason?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type PetCreateManyRegisteredByUserInput = {
    id?: string
    ownerId: string
    name: string
    speciesId?: number | null
    breed_id?: number | null
    secondary_breed_id?: number | null
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportMessageCreateManySenderInput = {
    id?: string
    ticketId: string
    senderType: $Enums.SenderType
    message: string
    attachments?: SupportMessageCreateattachmentsInput | string[]
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type SupportTicketCreateManyAssignedToUserInput = {
    id?: string
    ticketNumber: string
    userId?: string | null
    petId?: string | null
    subject: string
    description: string
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type SupportTicketCreateManyUserInput = {
    id?: string
    ticketNumber: string
    petId?: string | null
    subject: string
    description: string
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    assignedTo?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type UserSessionCreateManyUserInput = {
    id?: string
    refreshTokenHash: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    operationType?: EnumOperationTypeFieldUpdateOperationsInput | $Enums.OperationType
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedColumns?: AuditLogUpdatechangedColumnsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    operationType?: EnumOperationTypeFieldUpdateOperationsInput | $Enums.OperationType
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedColumns?: AuditLogUpdatechangedColumnsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    operationType?: EnumOperationTypeFieldUpdateOperationsInput | $Enums.OperationType
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedColumns?: AuditLogUpdatechangedColumnsInput | string[]
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceToken?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceToken?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceToken?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationTrackUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    position?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationTrackUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    position?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationTrackUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    position?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrScanId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    channels?: NotificationUpdatechannelsInput | string[]
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pet?: PetUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: NullableStringFieldUpdateOperationsInput | string | null
    qrScanId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    channels?: NotificationUpdatechannelsInput | string[]
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: NullableStringFieldUpdateOperationsInput | string | null
    qrScanId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    channels?: NotificationUpdatechannelsInput | string[]
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    receipt?: NullableStringFieldUpdateOperationsInput | string | null
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawOrderPayload?: NullableJsonNullValueInput | InputJsonValue
    payments?: PaymentUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    receipt?: NullableStringFieldUpdateOperationsInput | string | null
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawOrderPayload?: NullableJsonNullValueInput | InputJsonValue
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    receipt?: NullableStringFieldUpdateOperationsInput | string | null
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawOrderPayload?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OTPCodeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    purpose?: EnumOTPPurposeFieldUpdateOperationsInput | $Enums.OTPPurpose
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    attemptsCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPCodeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    purpose?: EnumOTPPurposeFieldUpdateOperationsInput | $Enums.OTPPurpose
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    attemptsCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPCodeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    purpose?: EnumOTPPurposeFieldUpdateOperationsInput | $Enums.OTPPurpose
    deliveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    attemptsCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentPurpose?: EnumPaymentPurposeFieldUpdateOperationsInput | $Enums.PaymentPurpose
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pet?: PetUpdateOneWithoutPaymentEventsNestedInput
    qrCode?: QRCodeUpdateOneWithoutPaymentEventsNestedInput
    refunds?: RefundUpdateManyWithoutPaymentEventNestedInput
  }

  export type PaymentEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: NullableStringFieldUpdateOperationsInput | string | null
    qrId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentPurpose?: EnumPaymentPurposeFieldUpdateOperationsInput | $Enums.PaymentPurpose
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refunds?: RefundUncheckedUpdateManyWithoutPaymentEventNestedInput
  }

  export type PaymentEventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: NullableStringFieldUpdateOperationsInput | string | null
    qrId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentPurpose?: EnumPaymentPurposeFieldUpdateOperationsInput | $Enums.PaymentPurpose
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PetUpdateWithoutRegisteredByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUpdateManyWithoutPetNestedInput
    notifications?: NotificationUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUpdateManyWithoutPetNestedInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_breed_idTopet_breedsNestedInput
    owner?: PetOwnerUpdateOneRequiredWithoutPetsNestedInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_secondary_breed_idTopet_breedsNestedInput
    species?: PetSpeciesUpdateOneWithoutPetsNestedInput
    qrCodes?: QRCodeUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateWithoutRegisteredByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableIntFieldUpdateOperationsInput | number | null
    breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPetNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUncheckedUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUncheckedUpdateManyWithoutPetNestedInput
    qrCodes?: QRCodeUncheckedUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUncheckedUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateManyWithoutRegisteredByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableIntFieldUpdateOperationsInput | number | null
    breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportMessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    message?: StringFieldUpdateOperationsInput | string
    attachments?: SupportMessageUpdateattachmentsInput | string[]
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: SupportTicketUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type SupportMessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    message?: StringFieldUpdateOperationsInput | string
    attachments?: SupportMessageUpdateattachmentsInput | string[]
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    message?: StringFieldUpdateOperationsInput | string
    attachments?: SupportMessageUpdateattachmentsInput | string[]
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUpdateWithoutAssignedToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: SupportMessageUpdateManyWithoutTicketNestedInput
    pet?: PetUpdateOneWithoutSupportTicketsNestedInput
    user?: UserUpdateOneWithoutSupportTicketsNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutAssignedToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    petId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: SupportMessageUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateManyWithoutAssignedToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    petId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupportTicketUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: SupportMessageUpdateManyWithoutTicketNestedInput
    assignedToUser?: UserUpdateOneWithoutAssignedTicketsNestedInput
    pet?: PetUpdateOneWithoutSupportTicketsNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    petId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: SupportMessageUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    petId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetCreateManyOwnerInput = {
    id?: string
    registeredBy?: string | null
    name: string
    speciesId?: number | null
    breed_id?: number | null
    secondary_breed_id?: number | null
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PetUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUpdateManyWithoutPetNestedInput
    notifications?: NotificationUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUpdateManyWithoutPetNestedInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_breed_idTopet_breedsNestedInput
    registeredByUser?: UserUpdateOneWithoutRegisteredPetsNestedInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_secondary_breed_idTopet_breedsNestedInput
    species?: PetSpeciesUpdateOneWithoutPetsNestedInput
    qrCodes?: QRCodeUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    registeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableIntFieldUpdateOperationsInput | number | null
    breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPetNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUncheckedUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUncheckedUpdateManyWithoutPetNestedInput
    qrCodes?: QRCodeUncheckedUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUncheckedUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    registeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableIntFieldUpdateOperationsInput | number | null
    breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetBreedCreateManySpeciesInput = {
    id?: number
    breedName: string
    sizeCategory?: $Enums.SizeCategory | null
    typicalLifespanYears?: number | null
  }

  export type PetCreateManySpeciesInput = {
    id?: string
    ownerId: string
    registeredBy?: string | null
    name: string
    breed_id?: number | null
    secondary_breed_id?: number | null
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PetBreedUpdateWithoutSpeciesInput = {
    breedName?: StringFieldUpdateOperationsInput | string
    sizeCategory?: NullableEnumSizeCategoryFieldUpdateOperationsInput | $Enums.SizeCategory | null
    typicalLifespanYears?: NullableIntFieldUpdateOperationsInput | number | null
    pets_pets_breed_idTopet_breeds?: PetUpdateManyWithoutPet_breeds_pets_breed_idTopet_breedsNestedInput
    pets_pets_secondary_breed_idTopet_breeds?: PetUpdateManyWithoutPet_breeds_pets_secondary_breed_idTopet_breedsNestedInput
  }

  export type PetBreedUncheckedUpdateWithoutSpeciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    breedName?: StringFieldUpdateOperationsInput | string
    sizeCategory?: NullableEnumSizeCategoryFieldUpdateOperationsInput | $Enums.SizeCategory | null
    typicalLifespanYears?: NullableIntFieldUpdateOperationsInput | number | null
    pets_pets_breed_idTopet_breeds?: PetUncheckedUpdateManyWithoutPet_breeds_pets_breed_idTopet_breedsNestedInput
    pets_pets_secondary_breed_idTopet_breeds?: PetUncheckedUpdateManyWithoutPet_breeds_pets_secondary_breed_idTopet_breedsNestedInput
  }

  export type PetBreedUncheckedUpdateManyWithoutSpeciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    breedName?: StringFieldUpdateOperationsInput | string
    sizeCategory?: NullableEnumSizeCategoryFieldUpdateOperationsInput | $Enums.SizeCategory | null
    typicalLifespanYears?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PetUpdateWithoutSpeciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUpdateManyWithoutPetNestedInput
    notifications?: NotificationUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUpdateManyWithoutPetNestedInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_breed_idTopet_breedsNestedInput
    owner?: PetOwnerUpdateOneRequiredWithoutPetsNestedInput
    registeredByUser?: UserUpdateOneWithoutRegisteredPetsNestedInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_secondary_breed_idTopet_breedsNestedInput
    qrCodes?: QRCodeUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateWithoutSpeciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    registeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPetNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUncheckedUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUncheckedUpdateManyWithoutPetNestedInput
    qrCodes?: QRCodeUncheckedUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUncheckedUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateManyWithoutSpeciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    registeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetCreateManyPet_breeds_pets_breed_idTopet_breedsInput = {
    id?: string
    ownerId: string
    registeredBy?: string | null
    name: string
    speciesId?: number | null
    secondary_breed_id?: number | null
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PetCreateManyPet_breeds_pets_secondary_breed_idTopet_breedsInput = {
    id?: string
    ownerId: string
    registeredBy?: string | null
    name: string
    speciesId?: number | null
    breed_id?: number | null
    gender: $Enums.Gender
    birthDate?: Date | string | null
    color?: string | null
    weightKg?: Decimal | DecimalJsLike | number | string | null
    heightCm?: Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: string | null
    isSpayedNeutered?: boolean | null
    microchip_id?: string | null
    registrationNumber?: string | null
    status?: $Enums.PetStatus
    specialNeeds?: string | null
    behavioralNotes?: string | null
    profileImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PetUpdateWithoutPet_breeds_pets_breed_idTopet_breedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUpdateManyWithoutPetNestedInput
    notifications?: NotificationUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUpdateManyWithoutPetNestedInput
    owner?: PetOwnerUpdateOneRequiredWithoutPetsNestedInput
    registeredByUser?: UserUpdateOneWithoutRegisteredPetsNestedInput
    pet_breeds_pets_secondary_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_secondary_breed_idTopet_breedsNestedInput
    species?: PetSpeciesUpdateOneWithoutPetsNestedInput
    qrCodes?: QRCodeUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateWithoutPet_breeds_pets_breed_idTopet_breedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    registeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPetNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUncheckedUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUncheckedUpdateManyWithoutPetNestedInput
    qrCodes?: QRCodeUncheckedUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUncheckedUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateManyWithoutPet_breeds_pets_breed_idTopet_breedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    registeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetUpdateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUpdateManyWithoutPetNestedInput
    notifications?: NotificationUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUpdateManyWithoutPetNestedInput
    pet_breeds_pets_breed_idTopet_breeds?: PetBreedUpdateOneWithoutPets_pets_breed_idTopet_breedsNestedInput
    owner?: PetOwnerUpdateOneRequiredWithoutPetsNestedInput
    registeredByUser?: UserUpdateOneWithoutRegisteredPetsNestedInput
    species?: PetSpeciesUpdateOneWithoutPetsNestedInput
    qrCodes?: QRCodeUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    registeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableIntFieldUpdateOperationsInput | number | null
    breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPetNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPetNestedInput
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutPetNestedInput
    locationEvents?: PetLocationEventUncheckedUpdateManyWithoutPetNestedInput
    qrScanEvents?: QRScanEventUncheckedUpdateManyWithoutPetNestedInput
    qrCodes?: QRCodeUncheckedUpdateManyWithoutPetNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutPetNestedInput
    vaccinationRecords?: VaccinationRecordUncheckedUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateManyWithoutPet_breeds_pets_secondary_breed_idTopet_breedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    registeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    speciesId?: NullableIntFieldUpdateOperationsInput | number | null
    breed_id?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weightKg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightCm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distinctiveMarks?: NullableStringFieldUpdateOperationsInput | string | null
    isSpayedNeutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    microchip_id?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPetStatusFieldUpdateOperationsInput | $Enums.PetStatus
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    behavioralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordCreateManyPetInput = {
    id?: string
    visitDate: Date | string
    veterinarianName?: string | null
    clinicName?: string | null
    diagnosis?: string | null
    treatment?: string | null
    medications?: NullableJsonNullValueInput | InputJsonValue
    followUpRequired?: boolean
    followUpDate?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    documentUrls?: MedicalRecordCreatedocumentUrlsInput | string[]
    createdAt?: Date | string
  }

  export type NotificationCreateManyPetInput = {
    id?: string
    userId?: string | null
    qrScanId?: string | null
    notificationType: $Enums.NotificationType
    title: string
    message: string
    channels?: NotificationCreatechannelsInput | string[]
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    sentAt?: Date | string | null
    readAt?: Date | string | null
  }

  export type PaymentEventCreateManyPetInput = {
    id?: string
    userId?: string | null
    qrId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentPurpose: $Enums.PaymentPurpose
    status?: $Enums.PaymentStatus
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    razorpaySignature?: string | null
    paymentMethod?: string | null
    failureReason?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type PetLocationEventCreateManyPetInput = {
    id?: string
    qrScanId?: string | null
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    accuracy?: Decimal | DecimalJsLike | number | string | null
    scannerIp?: string | null
    userAgent?: string | null
    deviceType?: $Enums.DeviceType | null
    locationName?: string | null
    countryCode?: string | null
    city?: string | null
    state?: string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type QRScanEventCreateManyPetInput = {
    id?: string
    qrId: string
    scanTimestamp?: Date | string
    scannerIp?: string | null
    userAgent?: string | null
    deviceType?: $Enums.DeviceType | null
    scanLocation?: string | null
    locationAccuracy?: Decimal | DecimalJsLike | number | string | null
    locationName?: string | null
    countryCode?: string | null
    city?: string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    scanResult: $Enums.ScanResult
    createdAt?: Date | string
  }

  export type QRCodeCreateManyPetInput = {
    id?: string
    poolId?: string | null
    qrCodeString: string
    qrCodeHash: string
    qrImageUrl?: string | null
    status?: $Enums.QRStatus
    assignedAt?: Date | string | null
    activatedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SupportTicketCreateManyPetInput = {
    id?: string
    ticketNumber: string
    userId?: string | null
    subject: string
    description: string
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    assignedTo?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type VaccinationRecordCreateManyPetInput = {
    id?: string
    vaccineTypeId: number
    administeredDate: Date | string
    expirationDate?: Date | string | null
    batchNumber?: string | null
    veterinarianName?: string | null
    clinicName?: string | null
    notes?: string | null
    certificateUrl?: string | null
    createdAt?: Date | string
  }

  export type MedicalRecordUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    veterinarianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableJsonNullValueInput | InputJsonValue
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    documentUrls?: MedicalRecordUpdatedocumentUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordUncheckedUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    veterinarianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableJsonNullValueInput | InputJsonValue
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    documentUrls?: MedicalRecordUpdatedocumentUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordUncheckedUpdateManyWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    veterinarianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableJsonNullValueInput | InputJsonValue
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    documentUrls?: MedicalRecordUpdatedocumentUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrScanId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    channels?: NotificationUpdatechannelsInput | string[]
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    qrScanId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    channels?: NotificationUpdatechannelsInput | string[]
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    qrScanId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    channels?: NotificationUpdatechannelsInput | string[]
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentEventUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentPurpose?: EnumPaymentPurposeFieldUpdateOperationsInput | $Enums.PaymentPurpose
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: QRCodeUpdateOneWithoutPaymentEventsNestedInput
    user?: UserUpdateOneWithoutPaymentEventsNestedInput
    refunds?: RefundUpdateManyWithoutPaymentEventNestedInput
  }

  export type PaymentEventUncheckedUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    qrId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentPurpose?: EnumPaymentPurposeFieldUpdateOperationsInput | $Enums.PaymentPurpose
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refunds?: RefundUncheckedUpdateManyWithoutPaymentEventNestedInput
  }

  export type PaymentEventUncheckedUpdateManyWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    qrId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentPurpose?: EnumPaymentPurposeFieldUpdateOperationsInput | $Enums.PaymentPurpose
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PetLocationEventUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    scannerIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableEnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qrScanEvent?: QRScanEventUpdateOneWithoutLocationEventsNestedInput
  }

  export type PetLocationEventUncheckedUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrScanId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    scannerIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableEnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetLocationEventUncheckedUpdateManyWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrScanId?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    scannerIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableEnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QRScanEventUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    scanTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    scannerIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableEnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType | null
    scanLocation?: NullableStringFieldUpdateOperationsInput | string | null
    locationAccuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    scanResult?: EnumScanResultFieldUpdateOperationsInput | $Enums.ScanResult
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: QRCodeUpdateOneRequiredWithoutScanEventsNestedInput
    locationEvents?: PetLocationEventUpdateManyWithoutQrScanEventNestedInput
  }

  export type QRScanEventUncheckedUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    scanTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    scannerIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableEnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType | null
    scanLocation?: NullableStringFieldUpdateOperationsInput | string | null
    locationAccuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    scanResult?: EnumScanResultFieldUpdateOperationsInput | $Enums.ScanResult
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationEvents?: PetLocationEventUncheckedUpdateManyWithoutQrScanEventNestedInput
  }

  export type QRScanEventUncheckedUpdateManyWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    scanTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    scannerIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableEnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType | null
    scanLocation?: NullableStringFieldUpdateOperationsInput | string | null
    locationAccuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    scanResult?: EnumScanResultFieldUpdateOperationsInput | $Enums.ScanResult
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QRCodeUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrCodeString?: StringFieldUpdateOperationsInput | string
    qrCodeHash?: StringFieldUpdateOperationsInput | string
    qrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQRStatusFieldUpdateOperationsInput | $Enums.QRStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentEvents?: PaymentEventUpdateManyWithoutQrCodeNestedInput
    pool?: QRCodePoolUpdateOneWithoutQrCodesNestedInput
    scanEvents?: QRScanEventUpdateManyWithoutQrCodeNestedInput
  }

  export type QRCodeUncheckedUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    poolId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeString?: StringFieldUpdateOperationsInput | string
    qrCodeHash?: StringFieldUpdateOperationsInput | string
    qrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQRStatusFieldUpdateOperationsInput | $Enums.QRStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutQrCodeNestedInput
    scanEvents?: QRScanEventUncheckedUpdateManyWithoutQrCodeNestedInput
  }

  export type QRCodeUncheckedUpdateManyWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    poolId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeString?: StringFieldUpdateOperationsInput | string
    qrCodeHash?: StringFieldUpdateOperationsInput | string
    qrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQRStatusFieldUpdateOperationsInput | $Enums.QRStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: SupportMessageUpdateManyWithoutTicketNestedInput
    assignedToUser?: UserUpdateOneWithoutAssignedTicketsNestedInput
    user?: UserUpdateOneWithoutSupportTicketsNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: SupportMessageUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateManyWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VaccinationRecordUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    administeredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    veterinarianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccineType?: VaccineTypeUpdateOneRequiredWithoutVaccinationRecordsNestedInput
  }

  export type VaccinationRecordUncheckedUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaccineTypeId?: IntFieldUpdateOperationsInput | number
    administeredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    veterinarianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationRecordUncheckedUpdateManyWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaccineTypeId?: IntFieldUpdateOperationsInput | number
    administeredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    veterinarianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationRecordCreateManyVaccineTypeInput = {
    id?: string
    petId: string
    administeredDate: Date | string
    expirationDate?: Date | string | null
    batchNumber?: string | null
    veterinarianName?: string | null
    clinicName?: string | null
    notes?: string | null
    certificateUrl?: string | null
    createdAt?: Date | string
  }

  export type VaccinationRecordUpdateWithoutVaccineTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    administeredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    veterinarianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pet?: PetUpdateOneRequiredWithoutVaccinationRecordsNestedInput
  }

  export type VaccinationRecordUncheckedUpdateWithoutVaccineTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    administeredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    veterinarianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationRecordUncheckedUpdateManyWithoutVaccineTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    administeredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    veterinarianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QRCodeCreateManyPoolInput = {
    id?: string
    qrCodeString: string
    qrCodeHash: string
    qrImageUrl?: string | null
    status?: $Enums.QRStatus
    assignedToPet?: string | null
    assignedAt?: Date | string | null
    activatedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type QRCodeUpdateWithoutPoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrCodeString?: StringFieldUpdateOperationsInput | string
    qrCodeHash?: StringFieldUpdateOperationsInput | string
    qrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQRStatusFieldUpdateOperationsInput | $Enums.QRStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentEvents?: PaymentEventUpdateManyWithoutQrCodeNestedInput
    pet?: PetUpdateOneWithoutQrCodesNestedInput
    scanEvents?: QRScanEventUpdateManyWithoutQrCodeNestedInput
  }

  export type QRCodeUncheckedUpdateWithoutPoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrCodeString?: StringFieldUpdateOperationsInput | string
    qrCodeHash?: StringFieldUpdateOperationsInput | string
    qrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQRStatusFieldUpdateOperationsInput | $Enums.QRStatus
    assignedToPet?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentEvents?: PaymentEventUncheckedUpdateManyWithoutQrCodeNestedInput
    scanEvents?: QRScanEventUncheckedUpdateManyWithoutQrCodeNestedInput
  }

  export type QRCodeUncheckedUpdateManyWithoutPoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrCodeString?: StringFieldUpdateOperationsInput | string
    qrCodeHash?: StringFieldUpdateOperationsInput | string
    qrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQRStatusFieldUpdateOperationsInput | $Enums.QRStatus
    assignedToPet?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentEventCreateManyQrCodeInput = {
    id?: string
    userId?: string | null
    petId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    paymentPurpose: $Enums.PaymentPurpose
    status?: $Enums.PaymentStatus
    razorpayOrderId?: string | null
    razorpayPaymentId?: string | null
    razorpaySignature?: string | null
    paymentMethod?: string | null
    failureReason?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type QRScanEventCreateManyQrCodeInput = {
    id?: string
    petId?: string | null
    scanTimestamp?: Date | string
    scannerIp?: string | null
    userAgent?: string | null
    deviceType?: $Enums.DeviceType | null
    scanLocation?: string | null
    locationAccuracy?: Decimal | DecimalJsLike | number | string | null
    locationName?: string | null
    countryCode?: string | null
    city?: string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    scanResult: $Enums.ScanResult
    createdAt?: Date | string
  }

  export type PaymentEventUpdateWithoutQrCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentPurpose?: EnumPaymentPurposeFieldUpdateOperationsInput | $Enums.PaymentPurpose
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pet?: PetUpdateOneWithoutPaymentEventsNestedInput
    user?: UserUpdateOneWithoutPaymentEventsNestedInput
    refunds?: RefundUpdateManyWithoutPaymentEventNestedInput
  }

  export type PaymentEventUncheckedUpdateWithoutQrCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    petId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentPurpose?: EnumPaymentPurposeFieldUpdateOperationsInput | $Enums.PaymentPurpose
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refunds?: RefundUncheckedUpdateManyWithoutPaymentEventNestedInput
  }

  export type PaymentEventUncheckedUpdateManyWithoutQrCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    petId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentPurpose?: EnumPaymentPurposeFieldUpdateOperationsInput | $Enums.PaymentPurpose
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QRScanEventUpdateWithoutQrCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    scanTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    scannerIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableEnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType | null
    scanLocation?: NullableStringFieldUpdateOperationsInput | string | null
    locationAccuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    scanResult?: EnumScanResultFieldUpdateOperationsInput | $Enums.ScanResult
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pet?: PetUpdateOneWithoutQrScanEventsNestedInput
    locationEvents?: PetLocationEventUpdateManyWithoutQrScanEventNestedInput
  }

  export type QRScanEventUncheckedUpdateWithoutQrCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: NullableStringFieldUpdateOperationsInput | string | null
    scanTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    scannerIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableEnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType | null
    scanLocation?: NullableStringFieldUpdateOperationsInput | string | null
    locationAccuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    scanResult?: EnumScanResultFieldUpdateOperationsInput | $Enums.ScanResult
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationEvents?: PetLocationEventUncheckedUpdateManyWithoutQrScanEventNestedInput
  }

  export type QRScanEventUncheckedUpdateManyWithoutQrCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: NullableStringFieldUpdateOperationsInput | string | null
    scanTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    scannerIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableEnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType | null
    scanLocation?: NullableStringFieldUpdateOperationsInput | string | null
    locationAccuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    scanResult?: EnumScanResultFieldUpdateOperationsInput | $Enums.ScanResult
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetLocationEventCreateManyQrScanEventInput = {
    id?: string
    petId: string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    accuracy?: Decimal | DecimalJsLike | number | string | null
    scannerIp?: string | null
    userAgent?: string | null
    deviceType?: $Enums.DeviceType | null
    locationName?: string | null
    countryCode?: string | null
    city?: string | null
    state?: string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PetLocationEventUpdateWithoutQrScanEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    scannerIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableEnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pet?: PetUpdateOneRequiredWithoutLocationEventsNestedInput
  }

  export type PetLocationEventUncheckedUpdateWithoutQrScanEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    scannerIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableEnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetLocationEventUncheckedUpdateManyWithoutQrScanEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accuracy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    scannerIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableEnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    scannerContactInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyOrderInput = {
    id?: string
    razorpayPaymentId: string
    razorpayOrderId: string
    amountInPaise: bigint | number
    currency?: string
    method?: string | null
    status?: $Enums.PaymentStatusNew
    captured?: boolean
    capturedAt?: Date | string | null
    bank?: string | null
    vpa?: string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    fee?: bigint | number | null
    tax?: bigint | number | null
    currencyConversion?: NullableJsonNullValueInput | InputJsonValue
    signatureValid?: boolean | null
    signatureVerifiedAt?: Date | string | null
    verificationMethod?: $Enums.VerificationMethod | null
    rawPaymentPayload?: NullableJsonNullValueInput | InputJsonValue
    clientMeta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayPaymentId?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: StringFieldUpdateOperationsInput | string
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusNewFieldUpdateOperationsInput | $Enums.PaymentStatusNew
    captured?: BoolFieldUpdateOperationsInput | boolean
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bank?: NullableStringFieldUpdateOperationsInput | string | null
    vpa?: NullableStringFieldUpdateOperationsInput | string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    fee?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currencyConversion?: NullableJsonNullValueInput | InputJsonValue
    signatureValid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    signatureVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableEnumVerificationMethodFieldUpdateOperationsInput | $Enums.VerificationMethod | null
    rawPaymentPayload?: NullableJsonNullValueInput | InputJsonValue
    clientMeta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refunds?: RefundUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayPaymentId?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: StringFieldUpdateOperationsInput | string
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusNewFieldUpdateOperationsInput | $Enums.PaymentStatusNew
    captured?: BoolFieldUpdateOperationsInput | boolean
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bank?: NullableStringFieldUpdateOperationsInput | string | null
    vpa?: NullableStringFieldUpdateOperationsInput | string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    fee?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currencyConversion?: NullableJsonNullValueInput | InputJsonValue
    signatureValid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    signatureVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableEnumVerificationMethodFieldUpdateOperationsInput | $Enums.VerificationMethod | null
    rawPaymentPayload?: NullableJsonNullValueInput | InputJsonValue
    clientMeta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refunds?: RefundUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayPaymentId?: StringFieldUpdateOperationsInput | string
    razorpayOrderId?: StringFieldUpdateOperationsInput | string
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusNewFieldUpdateOperationsInput | $Enums.PaymentStatusNew
    captured?: BoolFieldUpdateOperationsInput | boolean
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bank?: NullableStringFieldUpdateOperationsInput | string | null
    vpa?: NullableStringFieldUpdateOperationsInput | string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    fee?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tax?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currencyConversion?: NullableJsonNullValueInput | InputJsonValue
    signatureValid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    signatureVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableEnumVerificationMethodFieldUpdateOperationsInput | $Enums.VerificationMethod | null
    rawPaymentPayload?: NullableJsonNullValueInput | InputJsonValue
    clientMeta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundCreateManyPaymentInput = {
    id?: string
    razorpayRefundId?: string | null
    paymentEventId?: string | null
    amountInPaise: bigint | number
    refundAmount?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    initiatedBy?: string | null
    status?: $Enums.RefundStatus
    processedAt?: Date | string | null
    rawRefundPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type RefundUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    refundAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    initiatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawRefundPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentEvent?: PaymentEventUpdateOneWithoutRefundsNestedInput
  }

  export type RefundUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentEventId?: NullableStringFieldUpdateOperationsInput | string | null
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    refundAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    initiatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawRefundPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundUncheckedUpdateManyWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentEventId?: NullableStringFieldUpdateOperationsInput | string | null
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    refundAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    initiatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawRefundPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundCreateManyPaymentEventInput = {
    id?: string
    razorpayRefundId?: string | null
    razorpayPaymentId: string
    amountInPaise: bigint | number
    refundAmount?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    initiatedBy?: string | null
    status?: $Enums.RefundStatus
    processedAt?: Date | string | null
    rawRefundPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type RefundUpdateWithoutPaymentEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    refundAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    initiatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawRefundPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutRefundsNestedInput
  }

  export type RefundUncheckedUpdateWithoutPaymentEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: StringFieldUpdateOperationsInput | string
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    refundAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    initiatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawRefundPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundUncheckedUpdateManyWithoutPaymentEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: StringFieldUpdateOperationsInput | string
    amountInPaise?: BigIntFieldUpdateOperationsInput | bigint | number
    refundAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    initiatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawRefundPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportMessageCreateManyTicketInput = {
    id?: string
    senderId?: string | null
    senderType: $Enums.SenderType
    message: string
    attachments?: SupportMessageCreateattachmentsInput | string[]
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type SupportMessageUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    message?: StringFieldUpdateOperationsInput | string
    attachments?: SupportMessageUpdateattachmentsInput | string[]
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneWithoutSupportMessagesNestedInput
  }

  export type SupportMessageUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    message?: StringFieldUpdateOperationsInput | string
    attachments?: SupportMessageUpdateattachmentsInput | string[]
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportMessageUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    message?: StringFieldUpdateOperationsInput | string
    attachments?: SupportMessageUpdateattachmentsInput | string[]
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationDocumentCreateManyApplicationInput = {
    id?: string
    documentType: $Enums.DocumentType
    fileName: string
    filePath: string
    mimeType: string
    sizeBytes: bigint | number
    createdAt?: Date | string
  }

  export type CheckoutItemCreateManyApplicationInput = {
    id?: string
    sku: string
    itemName: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type RegisteredPetCreateManyApplicationInput = {
    id?: string
    petName: string
    breed: string
    dateOfBirth: Date | string
    ageOnRegistration: string
    lastRabiesVaccinationDate: Date | string
    veterinaryDoctorName: string
    veterinaryDoctorRegNumber: string
    veterinaryClinicOrHospitalName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gender: $Enums.Gender
  }

  export type ApplicationDocumentUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationDocumentUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationDocumentUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckoutItemUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckoutItemUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckoutItemUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegisteredPetUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    petName?: StringFieldUpdateOperationsInput | string
    breed?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    ageOnRegistration?: StringFieldUpdateOperationsInput | string
    lastRabiesVaccinationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    veterinaryDoctorName?: StringFieldUpdateOperationsInput | string
    veterinaryDoctorRegNumber?: StringFieldUpdateOperationsInput | string
    veterinaryClinicOrHospitalName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    documents?: PetDocumentUpdateManyWithoutPetNestedInput
  }

  export type RegisteredPetUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    petName?: StringFieldUpdateOperationsInput | string
    breed?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    ageOnRegistration?: StringFieldUpdateOperationsInput | string
    lastRabiesVaccinationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    veterinaryDoctorName?: StringFieldUpdateOperationsInput | string
    veterinaryDoctorRegNumber?: StringFieldUpdateOperationsInput | string
    veterinaryClinicOrHospitalName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    documents?: PetDocumentUncheckedUpdateManyWithoutPetNestedInput
  }

  export type RegisteredPetUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    petName?: StringFieldUpdateOperationsInput | string
    breed?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    ageOnRegistration?: StringFieldUpdateOperationsInput | string
    lastRabiesVaccinationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    veterinaryDoctorName?: StringFieldUpdateOperationsInput | string
    veterinaryDoctorRegNumber?: StringFieldUpdateOperationsInput | string
    veterinaryClinicOrHospitalName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
  }

  export type PetDocumentCreateManyPetInput = {
    id?: string
    documentType: $Enums.DocumentType
    fileName: string
    filePath: string
    mimeType: string
    sizeBytes: bigint | number
    createdAt?: Date | string
  }

  export type PetDocumentUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetDocumentUncheckedUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetDocumentUncheckedUpdateManyWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}